{
  "supports": [],
  "depends": [],
  "inputs": [],
  "libraries": [],
  "files": [],
  "controls": [
    {
      "tags": {
        "severity": "medium",
        "gid": "account_expiration",
        "rid": "account_disable_post_pw_expiration",
        "gtitle": "Set Account Expiration Parameters"
      },
      "id": "account_expiration",
      "title": [
        {
          "#text": "Set Account Expiration Following Inactivity",
          "@_lang": "en-US"
        }
      ],
      "desc": "To specify the number of days after a password expires (which signifies inactivity) until an account is permanently disabled, add or correct the following line in:If a password is currently on the verge of expiration, thenday(s) remain(s) until the account is automatically disabled. However, if the password will not expire for another 60 days, then 60 days plusday(s) could elapse until the account would be automatically disabled. See theman page for more information.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "account_expiration",
        "rid": "account_temp_expire_date",
        "gtitle": "Set Account Expiration Parameters"
      },
      "id": "account_expiration",
      "title": [
        {
          "#text": "Assign Expiration Date to Temporary Accounts",
          "@_lang": "en-US"
        }
      ],
      "desc": "Temporary accounts are established as part of normal account activation procedures when there is a need for short-term accounts. In the event temporary or emergency accounts are required, configure the system to terminate them after a documented time period. For every temporary and emergency account, run the following command to set an expiration date on it, substitutingandappropriately:indicates the documented expiration date for the account. For U.S. Government systems, the operating system must be configured to automatically terminate these types of accounts after a period of 72 hours.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "account_expiration",
        "rid": "account_unique_name",
        "gtitle": "Set Account Expiration Parameters"
      },
      "id": "account_expiration",
      "title": [
        {
          "#text": "Ensure All Accounts on the System Have Unique Names",
          "@_lang": "en-US"
        }
      ],
      "desc": "Ensure accounts on the system have unique names. To ensure all accounts have unique names, run the following command:If a username is returned, change or delete the username.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "account_expiration",
        "rid": "account_use_centralized_automated_auth",
        "gtitle": "Set Account Expiration Parameters"
      },
      "id": "account_expiration",
      "title": [
        {
          "#text": "Use Centralized and Automated Authentication",
          "@_lang": "en-US"
        }
      ],
      "desc": "Implement an automated system for managing user accounts that minimizes the risk of errors, either intentional or deliberate. This system should integrate with an existing enterprise user management system, such as one based on Identity Management tools such as Active Directory, Kerberos, Directory Server, etc.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "account_expiration",
        "rid": "policy_temp_passwords_immediate_change",
        "gtitle": "Set Account Expiration Parameters"
      },
      "id": "account_expiration",
      "title": [
        {
          "#text": "Policy Requires Immediate Change of Temporary Passwords",
          "@_lang": "en-US"
        }
      ],
      "desc": "Temporary passwords for Ubuntu 20.04 operating system logons must require an immediate change to a permanent password. Verify that a policy exists that ensures when a user is created, it is creating using a method that forces a user to change their password upon their next login.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "accounts-banners",
        "rid": "file_groupowner_etc_issue",
        "gtitle": "Warning Banners for System Accesses",
        "fix_id": "file_groupowner_etc_issue"
      },
      "id": "accounts-banners",
      "title": [
        {
          "#text": "Verify Group Ownership of System Login Banner",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chgrp 0 /etc/issue"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "accounts-banners",
        "rid": "file_groupowner_etc_motd",
        "gtitle": "Warning Banners for System Accesses",
        "fix_id": "file_groupowner_etc_motd"
      },
      "id": "accounts-banners",
      "title": [
        {
          "#text": "Verify Group Ownership of Message of the Day Banner",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chgrp 0 /etc/motd"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "accounts-banners",
        "rid": "file_owner_etc_issue",
        "gtitle": "Warning Banners for System Accesses",
        "fix_id": "file_owner_etc_issue"
      },
      "id": "accounts-banners",
      "title": [
        {
          "#text": "Verify ownership of System Login Banner",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chown 0 /etc/issue"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "accounts-banners",
        "rid": "file_owner_etc_motd",
        "gtitle": "Warning Banners for System Accesses",
        "fix_id": "file_owner_etc_motd"
      },
      "id": "accounts-banners",
      "title": [
        {
          "#text": "Verify ownership of Message of the Day Banner",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chown 0 /etc/motd"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "accounts-banners",
        "rid": "file_permissions_etc_issue",
        "gtitle": "Warning Banners for System Accesses",
        "fix_id": "file_permissions_etc_issue"
      },
      "id": "accounts-banners",
      "title": [
        {
          "#text": "Verify permissions on System Login Banner",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chmod 0644 /etc/issue"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "accounts-banners",
        "rid": "file_permissions_etc_motd",
        "gtitle": "Warning Banners for System Accesses",
        "fix_id": "file_permissions_etc_motd"
      },
      "id": "accounts-banners",
      "title": [
        {
          "#text": "Verify permissions on Message of the Day Banner",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chmod 0644 /etc/motd"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "accounts-pam",
        "rid": "package_pam_pwquality_installed",
        "gtitle": "Protect Accounts by Configuring PAM",
        "fix_id": "package_pam_pwquality_installed"
      },
      "id": "accounts-pam",
      "title": [
        {
          "#text": "Install pam_pwquality Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be installed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "DEBIAN_FRONTEND=noninteractive apt-get install -y \"libpam-pwquality\""
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "accounts-pam",
        "rid": "display_login_attempts",
        "gtitle": "Protect Accounts by Configuring PAM",
        "fix_id": "display_login_attempts"
      },
      "id": "accounts-pam",
      "title": [
        {
          "#text": "Ensure PAM Displays Last Logon/Access Notification",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure the system to notify users of last logon/access using, add or correct thesettings into read as follows:And make sure that theoption is not set.",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'libpam-runtime' 2&gt;/dev/null | grep -q installed; then if [ -e \"/etc/pam.d/login\" ] ; then valueRegex=\"\" defaultValue=\"\" # non-empty values need to be preceded by an equals sign [ -n \"${valueRegex}\" ] &amp;&amp; valueRegex=\"=${valueRegex}\" # add an equals sign to non-empty values [ -n \"${defaultValue}\" ] &amp;&amp; defaultValue=\"=${defaultValue}\" # fix 'type' if it's wrong if grep -q -P \"^\\\\s*(?\"'!'\"session\\\\s)[[:alnum:]]+\\\\s+[[:alnum:]]+\\\\s+pam_lastlog.so\" &lt; \"/etc/pam.d/login\" ; then sed --follow-symlinks -i -E -e \"s/^(\\\\s*)[[:alnum:]]+(\\\\s+[[:alnum:]]+\\\\s+pam_lastlog.so)/\\\\1session\\\\2/\" \"/etc/pam.d/login\" fi # fix 'control' if it's wrong if grep -q -P \"^\\\\s*session\\\\s+(?\"'!'\"required)[[:alnum:]]+\\\\s+pam_lastlog.so\" &lt; \"/etc/pam.d/login\" ; then sed --follow-symlinks -i -E -e \"s/^(\\\\s*session\\\\s+)[[:alnum:]]+(\\\\s+pam_lastlog.so)/\\\\1required\\\\2/\" \"/etc/pam.d/login\" fi # fix the value for 'option' if one exists but does not match 'valueRegex' if grep -q -P \"^\\\\s*session\\\\s+required\\\\s+pam_lastlog.so(\\\\s.+)?\\\\s+showfailed(?\"'!'\"${valueRegex}(\\\\s|\\$))\" &lt; \"/etc/pam.d/login\" ; then sed --follow-symlinks -i -E -e \"s/^(\\\\s*session\\\\s+required\\\\s+pam_lastlog.so(\\\\s.+)?\\\\s)showfailed=[^[:space:]]*/\\\\1showfailed${defaultValue}/\" \"/etc/pam.d/login\" # add 'option=default' if option is not set elif grep -q -E \"^\\\\s*session\\\\s+required\\\\s+pam_lastlog.so\" &lt; \"/etc/pam.d/login\" &amp;&amp; grep -E \"^\\\\s*session\\\\s+required\\\\s+pam_lastlog.so\" &lt; \"/etc/pam.d/login\" | grep -q -E -v \"\\\\sshowfailed(=|\\\\s|\\$)\" ; then sed --follow-symlinks -i -E -e \"s/^(\\\\s*session\\\\s+required\\\\s+pam_lastlog.so[^\\ ]*)/\\\\1 showfailed${defaultValue}/\" \"/etc/pam.d/login\" # add a new entry if none exists elif ! grep -q -P \"^\\\\s*session\\\\s+required\\\\s+pam_lastlog.so(\\\\s.+)?\\\\s+showfailed${valueRegex}(\\\\s|\\$)\" &lt; \"/etc/pam.d/login\" ; then echo \"session required pam_lastlog.so showfailed${defaultValue}\" &gt;&gt; \"/etc/pam.d/login\" fi else echo \"/etc/pam.d/login doesn't exist\" &gt;&amp;2 fi # remove 'silent' option sed -i --follow-symlinks -E -e 's/^([^#]+pam_lastlog\\.so[^#]*)\\ssilent/\\1/' '/etc/pam.d/login' else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gid": "accounts-physical",
        "rid": "disable_ctrlaltdel_burstaction",
        "gtitle": "Protect Physical Console Access",
        "fix_id": "disable_ctrlaltdel_burstaction"
      },
      "id": "accounts-physical",
      "title": [
        {
          "#text": "Disable Ctrl-Alt-Del Burst Action",
          "@_lang": "en-US"
        }
      ],
      "desc": "By default,will reboot the system if thekey sequence is pressed Ctrl-Alt-Delete more than 7 times in 2 seconds.To configure the system to ignore thesetting, add or modify the following to:",
      "impact": 0.7,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'systemd' 2&gt;/dev/null | grep -q installed; then # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/systemd/system.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^CtrlAltDelBurstAction=\") # shellcheck disable=SC2059 printf -v formatted_output \"%s=%s\" \"$stripped_key\" \"none\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^CtrlAltDelBurstAction=\\\\&gt;\" \"/etc/systemd/system.conf\"; then \"${sed_command[@]}\" \"s/^CtrlAltDelBurstAction=\\\\&gt;.*/$formatted_output/gi\" \"/etc/systemd/system.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/systemd/system.conf\" &gt;&gt; \"/etc/systemd/system.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/systemd/system.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gid": "accounts-physical",
        "rid": "disable_ctrlaltdel_reboot",
        "gtitle": "Protect Physical Console Access",
        "fix_id": "disable_ctrlaltdel_reboot"
      },
      "id": "accounts-physical",
      "title": [
        {
          "#text": "Disable Ctrl-Alt-Del Reboot Activation",
          "@_lang": "en-US"
        }
      ],
      "desc": "By default,will reboot the system if thekey sequence is pressed.To configure the system to ignore thekey sequence from the command line instead of rebooting the system, do either of the following:orDo not simply delete thefile, as this file may be restored during future system updates.",
      "impact": 0.7,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then systemctl disable --now ctrl-alt-del.target systemctl mask --now ctrl-alt-del.target else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "accounts-session",
        "rid": "accounts_logon_fail_delay",
        "gtitle": "Secure Session Configuration Files for Login Accounts"
      },
      "id": "accounts-session",
      "title": [
        {
          "#text": "Ensure the Logon Failure Delay is Set Correctly in login.defs",
          "@_lang": "en-US"
        }
      ],
      "desc": "To ensure the logon failure delay controlled byis set properly, add or correct thesetting into read as follows:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "accounts-session",
        "rid": "accounts_max_concurrent_login_sessions",
        "gtitle": "Secure Session Configuration Files for Login Accounts"
      },
      "id": "accounts-session",
      "title": [
        {
          "#text": "Limit the Number of Concurrent Login Sessions Allowed Per User",
          "@_lang": "en-US"
        }
      ],
      "desc": "Limiting the number of allowed users and sessions per user can limit risks related to Denial of Service attacks. This addresses concurrent sessions for a single account and does not address concurrent sessions by a single user via multiple accounts. To set the number of concurrent sessions per user add the following line inor a file under:",
      "impact": 0.3,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "accounts-session",
        "rid": "accounts_polyinstantiated_tmp",
        "gtitle": "Secure Session Configuration Files for Login Accounts",
        "fix_id": "accounts_polyinstantiated_tmp"
      },
      "id": "accounts-session",
      "title": [
        {
          "#text": "Configure Polyinstantiation of /tmp Directories",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure polyinstantiated /tmp directories, first create the parent directories which will hold the polyinstantiation child directories. Use the following command:Then, add the following entry to:",
      "impact": 0.3,
      "descs": {
        "fix": "if ! [ -d /tmp/tmp-inst ] ; then mkdir --mode 000 /tmp/tmp-inst fi chmod 000 /tmp/tmp-inst chcon --reference=/tmp /tmp/tmp-inst if ! grep -Eq '^\\s*/tmp\\s+/tmp/tmp-inst/\\s+level\\s+root,adm$' /etc/security/namespace.conf ; then if grep -Eq '^\\s*/tmp\\s+' /etc/security/namespace.conf ; then sed -i '/^\\s*\\/tmp/d' /etc/security/namespace.conf fi echo \"/tmp /tmp/tmp-inst/ level root,adm\" &gt;&gt; /etc/security/namespace.conf fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "accounts-session",
        "rid": "accounts_polyinstantiated_var_tmp",
        "gtitle": "Secure Session Configuration Files for Login Accounts",
        "fix_id": "accounts_polyinstantiated_var_tmp"
      },
      "id": "accounts-session",
      "title": [
        {
          "#text": "Configure Polyinstantiation of /var/tmp Directories",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure polyinstantiated /tmp directories, first create the parent directories which will hold the polyinstantiation child directories. Use the following command:Then, add the following entry to:",
      "impact": 0.3,
      "descs": {
        "fix": "if ! [ -d /tmp-inst ] ; then mkdir --mode 000 /var/tmp/tmp-inst fi chmod 000 /var/tmp/tmp-inst chcon --reference=/var/tmp/ /var/tmp/tmp-inst if ! grep -Eq '^\\s*/var/tmp\\s+/var/tmp/tmp-inst/\\s+level\\s+root,adm$' /etc/security/namespace.conf ; then if grep -Eq '^\\s*/var/tmp\\s+' /etc/security/namespace.conf ; then sed -i '/^\\s*\\/var\\/tmp/d' /etc/security/namespace.conf fi echo \"/var/tmp /var/tmp/tmp-inst/ level root,adm\" &gt;&gt; /etc/security/namespace.conf fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "accounts-session",
        "rid": "accounts_tmout",
        "gtitle": "Secure Session Configuration Files for Login Accounts",
        "fix_id": "accounts_tmout"
      },
      "id": "accounts-session",
      "title": [
        {
          "#text": "Set Interactive Session Timeout",
          "@_lang": "en-US"
        }
      ],
      "desc": "Setting theoption inensures that all user sessions will terminate based on inactivity. Thesetting in a file loaded by, e.g.should read as follows:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then var_accounts_tmout=\"\" # if 0, no occurence of tmout found, if 1, occurence found tmout_found=0 for f in /etc/profile /etc/profile.d/*.sh; do if grep --silent '^\\s*TMOUT' $f; then sed -i -E \"s/^(\\s*)TMOUT\\s*=\\s*(\\w|\\$)*(.*)$/\\1TMOUT=$var_accounts_tmout\\3/g\" $f tmout_found=1 fi done if [ $tmout_found -eq 0 ]; then echo -e \" # Set TMOUT to $var_accounts_tmout per security requirements\" &gt;&gt; /etc/profile.d/tmout.sh echo \"TMOUT=$var_accounts_tmout\" &gt;&gt; /etc/profile.d/tmout.sh fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "accounts-session",
        "rid": "accounts_user_dot_group_ownership",
        "gtitle": "Secure Session Configuration Files for Login Accounts"
      },
      "id": "accounts-session",
      "title": [
        {
          "#text": "User Initialization Files Must Be Group-Owned By The Primary User",
          "@_lang": "en-US"
        }
      ],
      "desc": "Change the group owner of interactive users files to the group found infor the user. To change the group owner of a local interactive user home directory, use the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "accounts-session",
        "rid": "accounts_user_dot_user_ownership",
        "gtitle": "Secure Session Configuration Files for Login Accounts"
      },
      "id": "accounts-session",
      "title": [
        {
          "#text": "User Initialization Files Must Be Owned By the Primary User",
          "@_lang": "en-US"
        }
      ],
      "desc": "Set the owner of the user initialization files for interactive users to the primary owner with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "accounts-session",
        "rid": "accounts_user_interactive_home_directory_exists",
        "gtitle": "Secure Session Configuration Files for Login Accounts"
      },
      "id": "accounts-session",
      "title": [
        {
          "#text": "All Interactive Users Home Directories Must Exist",
          "@_lang": "en-US"
        }
      ],
      "desc": "Create home directories to all interactive users that currently do not have a home directory assigned. Use the following commands to create the user home directory assigned in:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "accounts-session",
        "rid": "accounts_users_own_home_directories",
        "gtitle": "Secure Session Configuration Files for Login Accounts"
      },
      "id": "accounts-session",
      "title": [
        {
          "#text": "Ensure users own their home directories",
          "@_lang": "en-US"
        }
      ],
      "desc": "The user home directory is space defined for the particular user to set local environment variables and to store personal files. Since the user is accountable for files stored in the user home directory, the user must be the owner of the directory.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "accounts-session",
        "rid": "file_permissions_home_directories",
        "gtitle": "Secure Session Configuration Files for Login Accounts"
      },
      "id": "accounts-session",
      "title": [
        {
          "#text": "All Interactive User Home Directories Must Have mode 0750 Or Less Permissive",
          "@_lang": "en-US"
        }
      ],
      "desc": "Change the mode of interactive users home directories to. To change the mode of interactive users home directory, use the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "accounts-session",
        "rid": "file_permissions_home_dirs",
        "gtitle": "Secure Session Configuration Files for Login Accounts"
      },
      "id": "accounts-session",
      "title": [
        {
          "#text": "Ensure that User Home Directories are not Group-Writable or World-Readable",
          "@_lang": "en-US"
        }
      ],
      "desc": "For each human user of the system, view the permissions of the user's home directory:Ensure that the directory is not group-writable and that it is not world-readable. If necessary, repair the permissions:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "aide",
        "rid": "package_aide_installed",
        "gtitle": "Verify Integrity with AIDE",
        "fix_id": "package_aide_installed"
      },
      "id": "aide",
      "title": [
        {
          "#text": "Install AIDE",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be installed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"aide\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "aide",
        "rid": "aide_build_database",
        "gtitle": "Verify Integrity with AIDE",
        "fix_id": "aide_build_database"
      },
      "id": "aide",
      "title": [
        {
          "#text": "Build and Test AIDE Database",
          "@_lang": "en-US"
        }
      ],
      "desc": "Run the following command to generate a new database:By default, the database will be written to the file. Storing the database, the configuration file, and the binary(or hashes of these files), in a secure location (such as on read-only media) provides additional assurance about their integrity. The newly-generated database can be installed as follows:To initiate a manual check, run the following command:If this check produces any unexpected output, investigate.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"aide\" /usr/sbin/aideinit /bin/mv /var/lib/aide/aide.db.new /var/lib/aide/aide.db else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "aide",
        "rid": "aide_check_audit_tools",
        "gtitle": "Verify Integrity with AIDE",
        "fix_id": "aide_check_audit_tools"
      },
      "id": "aide",
      "title": [
        {
          "#text": "Configure AIDE to Verify the Audit Tools",
          "@_lang": "en-US"
        }
      ],
      "desc": "The operating system file integrity tool must be configured to protect the integrity of the audit tools.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"aide\" if grep -i '^.*/usr/sbin/auditctl.*$' /etc/aide/aide.conf; then sed -i \"s#.*/usr/sbin/auditctl.*#/usr/sbin/auditctl p+i+n+u+g+s+b+acl+xattrs+sha512#\" /etc/aide/aide.conf else echo \"/usr/sbin/auditctl p+i+n+u+g+s+b+acl+xattrs+sha512\" &gt;&gt; /etc/aide/aide.conf fi if grep -i '^.*/usr/sbin/auditd.*$' /etc/aide/aide.conf; then sed -i \"s#.*/usr/sbin/auditd.*#/usr/sbin/auditd p+i+n+u+g+s+b+acl+xattrs+sha512#\" /etc/aide/aide.conf else echo \"/usr/sbin/auditd p+i+n+u+g+s+b+acl+xattrs+sha512\" &gt;&gt; /etc/aide/aide.conf fi if grep -i '^.*/usr/sbin/ausearch.*$' /etc/aide/aide.conf; then sed -i \"s#.*/usr/sbin/ausearch.*#/usr/sbin/ausearch p+i+n+u+g+s+b+acl+xattrs+sha512#\" /etc/aide/aide.conf else echo \"/usr/sbin/ausearch p+i+n+u+g+s+b+acl+xattrs+sha512\" &gt;&gt; /etc/aide/aide.conf fi if grep -i '^.*/usr/sbin/aureport.*$' /etc/aide/aide.conf; then sed -i \"s#.*/usr/sbin/aureport.*#/usr/sbin/aureport p+i+n+u+g+s+b+acl+xattrs+sha512#\" /etc/aide/aide.conf else echo \"/usr/sbin/aureport p+i+n+u+g+s+b+acl+xattrs+sha512\" &gt;&gt; /etc/aide/aide.conf fi if grep -i '^.*/usr/sbin/autrace.*$' /etc/aide/aide.conf; then sed -i \"s#.*/usr/sbin/autrace.*#/usr/sbin/autrace p+i+n+u+g+s+b+acl+xattrs+sha512#\" /etc/aide/aide.conf else echo \"/usr/sbin/autrace p+i+n+u+g+s+b+acl+xattrs+sha512\" &gt;&gt; /etc/aide/aide.conf fi if grep -i '^.*/usr/sbin/augenrules.*$' /etc/aide/aide.conf; then sed -i \"s#.*/usr/sbin/augenrules.*#/usr/sbin/augenrules p+i+n+u+g+s+b+acl+xattrs+sha512#\" /etc/aide/aide.conf else echo \"/usr/sbin/augenrules p+i+n+u+g+s+b+acl+xattrs+sha512\" &gt;&gt; /etc/aide/aide.conf fi if grep -i '^.*/usr/sbin/audispd.*$' /etc/aide/aide.conf; then sed -i \"s#.*/usr/sbin/audispd.*#/usr/sbin/audispd p+i+n+u+g+s+b+acl+xattrs+sha512#\" /etc/aide/aide.conf else echo \"/usr/sbin/audispd p+i+n+u+g+s+b+acl+xattrs+sha512\" &gt;&gt; /etc/aide/aide.conf fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "aide",
        "rid": "aide_periodic_cron_checking",
        "gtitle": "Verify Integrity with AIDE",
        "fix_id": "aide_periodic_cron_checking"
      },
      "id": "aide",
      "title": [
        {
          "#text": "Configure Periodic Execution of AIDE",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, AIDE should be configured to run a weekly scan. To implement a daily execution of AIDE at 4:05am using cron, add the following line to:To implement a weekly execution of AIDE at 4:05am using cron, add the following line to:AIDE can be executed periodically through other means; this is merely one example. The usage of cron's special time codes, such asandis acceptable.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"aide\" # AiDE usually adds its own cron jobs to /etc/cron.daily. If script is there, this rule is # compliant. Otherwise, we copy the script to the /etc/cron.weekly if ! egrep -q '^(/usr/bin/)?aide\\.wrapper\\s+' /etc/cron.*/*; then cp -f /usr/share/aide/config/cron.daily/aide /etc/cron.weekly/ fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "apparmor",
        "rid": "apparmor_configured",
        "gtitle": "AppArmor",
        "fix_id": "apparmor_configured"
      },
      "id": "apparmor",
      "title": [
        {
          "#text": "Ensure AppArmor is Active and Configured",
          "@_lang": "en-US"
        }
      ],
      "desc": "Verify that the Apparmor tool is configured to control whitelisted applications and user home directory access control.Theservice can be enabled with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "include enable_apparmor class enable_apparmor { service {'apparmor': enable =&gt; true, ensure =&gt; 'running', } }"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "apport",
        "rid": "service_apport_disabled",
        "gtitle": "Apport Service",
        "fix_id": "service_apport_disabled"
      },
      "id": "apport",
      "title": [
        {
          "#text": "Disable Apport Service",
          "@_lang": "en-US"
        }
      ],
      "desc": "The Apport modifies certain kernel configuration values at runtime which may decrease the overall security of the system and expose sensitive data. Theservice can be disabled with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" stop 'apport.service' \"$SYSTEMCTL_EXEC\" disable 'apport.service' \"$SYSTEMCTL_EXEC\" mask 'apport.service' # Disable socket activation if we have a unit file for it if \"$SYSTEMCTL_EXEC\" list-unit-files | grep -q '^apport.socket'; then \"$SYSTEMCTL_EXEC\" stop 'apport.socket' \"$SYSTEMCTL_EXEC\" mask 'apport.socket' fi # The service may not be running because it has been started and failed, # so let's reset the state so OVAL checks pass. # Service should be 'inactive', not 'failed' after reboot though. \"$SYSTEMCTL_EXEC\" reset-failed 'apport.service' || true"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "apt",
        "rid": "apt_conf_disallow_unauthenticated",
        "gtitle": "APT service configuration"
      },
      "id": "apt",
      "title": [
        {
          "#text": "Disable unauthenticated repositories in APT configuration",
          "@_lang": "en-US"
        }
      ],
      "desc": "Unauthenticated repositories should not be used for updates.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_dac_actions",
        "rid": "audit_rules_dac_modification_chmod",
        "gtitle": "Record Events that Modify the System's Discretionary Access Controls"
      },
      "id": "audit_dac_actions",
      "title": [
        {
          "#text": "Record Events that Modify the System's Discretionary Access Controls - chmod",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file permission changes for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_dac_actions",
        "rid": "audit_rules_dac_modification_chown",
        "gtitle": "Record Events that Modify the System's Discretionary Access Controls"
      },
      "id": "audit_dac_actions",
      "title": [
        {
          "#text": "Record Events that Modify the System's Discretionary Access Controls - chown",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file permission changes for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_dac_actions",
        "rid": "audit_rules_dac_modification_fchmod",
        "gtitle": "Record Events that Modify the System's Discretionary Access Controls"
      },
      "id": "audit_dac_actions",
      "title": [
        {
          "#text": "Record Events that Modify the System's Discretionary Access Controls - fchmod",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file permission changes for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_dac_actions",
        "rid": "audit_rules_dac_modification_fchmodat",
        "gtitle": "Record Events that Modify the System's Discretionary Access Controls"
      },
      "id": "audit_dac_actions",
      "title": [
        {
          "#text": "Record Events that Modify the System's Discretionary Access Controls - fchmodat",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file permission changes for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_dac_actions",
        "rid": "audit_rules_dac_modification_fchown",
        "gtitle": "Record Events that Modify the System's Discretionary Access Controls"
      },
      "id": "audit_dac_actions",
      "title": [
        {
          "#text": "Record Events that Modify the System's Discretionary Access Controls - fchown",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file permission changes for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_dac_actions",
        "rid": "audit_rules_dac_modification_fchownat",
        "gtitle": "Record Events that Modify the System's Discretionary Access Controls"
      },
      "id": "audit_dac_actions",
      "title": [
        {
          "#text": "Record Events that Modify the System's Discretionary Access Controls - fchownat",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file permission changes for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_dac_actions",
        "rid": "audit_rules_dac_modification_fremovexattr",
        "gtitle": "Record Events that Modify the System's Discretionary Access Controls"
      },
      "id": "audit_dac_actions",
      "title": [
        {
          "#text": "Record Events that Modify the System's Discretionary Access Controls - fremovexattr",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file permission changes for all users and root.If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_dac_actions",
        "rid": "audit_rules_dac_modification_fsetxattr",
        "gtitle": "Record Events that Modify the System's Discretionary Access Controls"
      },
      "id": "audit_dac_actions",
      "title": [
        {
          "#text": "Record Events that Modify the System's Discretionary Access Controls - fsetxattr",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file permission changes for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_dac_actions",
        "rid": "audit_rules_dac_modification_lchown",
        "gtitle": "Record Events that Modify the System's Discretionary Access Controls"
      },
      "id": "audit_dac_actions",
      "title": [
        {
          "#text": "Record Events that Modify the System's Discretionary Access Controls - lchown",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file permission changes for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_dac_actions",
        "rid": "audit_rules_dac_modification_lremovexattr",
        "gtitle": "Record Events that Modify the System's Discretionary Access Controls"
      },
      "id": "audit_dac_actions",
      "title": [
        {
          "#text": "Record Events that Modify the System's Discretionary Access Controls - lremovexattr",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file permission changes for all users and root.If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_dac_actions",
        "rid": "audit_rules_dac_modification_lsetxattr",
        "gtitle": "Record Events that Modify the System's Discretionary Access Controls"
      },
      "id": "audit_dac_actions",
      "title": [
        {
          "#text": "Record Events that Modify the System's Discretionary Access Controls - lsetxattr",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file permission changes for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_dac_actions",
        "rid": "audit_rules_dac_modification_removexattr",
        "gtitle": "Record Events that Modify the System's Discretionary Access Controls"
      },
      "id": "audit_dac_actions",
      "title": [
        {
          "#text": "Record Events that Modify the System's Discretionary Access Controls - removexattr",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file permission changes for all users and root.If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_dac_actions",
        "rid": "audit_rules_dac_modification_setxattr",
        "gtitle": "Record Events that Modify the System's Discretionary Access Controls"
      },
      "id": "audit_dac_actions",
      "title": [
        {
          "#text": "Record Events that Modify the System's Discretionary Access Controls - setxattr",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file permission changes for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_dac_actions",
        "rid": "audit_rules_dac_modification_umount",
        "gtitle": "Record Events that Modify the System's Discretionary Access Controls",
        "fix_id": "audit_rules_dac_modification_umount"
      },
      "id": "audit_dac_actions",
      "title": [
        {
          "#text": "Record Events that Modify the System's Discretionary Access Controls - umount",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file system umount changes. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'audit' 2&gt;/dev/null | grep -q installed; then ACTION_ARCH_FILTERS=\"-a always,exit -F arch=b32\" OTHER_FILTERS=\"\" AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"umount\" KEY=\"perm_mod\" SYSCALL_GROUPING=\"\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' # Load macro arguments into arrays read -a syscall_a &lt;&lt;&lt; $SYSCALL read -a syscall_grouping &lt;&lt;&lt; $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspected for presence and correctness # of a particular audit rule. The scheme is as follows: # # ----------------------------------------------------------------------------------------- # Tool used to load audit rules | Rule already defined | Audit rules file to inspect | # ----------------------------------------------------------------------------------------- # auditctl | Doesn't matter | /etc/audit/audit.rules | # ----------------------------------------------------------------------------------------- # augenrules | Yes | /etc/audit/rules.d/*.rules | # augenrules | No | /etc/audit/rules.d/$key.rules | # ----------------------------------------------------------------------------------------- # files_to_inspect=() # If audit tool is 'augenrules', then check if the audit rule is defined # If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection # If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection default_file=\"/etc/audit/rules.d/$KEY.rules\" # As other_filters may include paths, lets use a different delimiter for it # The \"F\" script expression tells sed to print the filenames where the expressions matched readarray -t files_to_inspect &lt; &lt;(sed -s -n -e \"/$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules) # Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet if [ ${#files_to_inspect[@]} -eq \"0\" ] then file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\" files_to_inspect=(\"$file_to_inspect\") if [ ! -e \"$file_to_inspect\" ] then touch \"$file_to_inspect\" chmod 0640 \"$file_to_inspect\" fi fi # Indicator that we want to append $full_rule into $audit_file or edit a rule in it append_expected_rule=0 # After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead skip=1 for audit_file in \"${files_to_inspect[@]}\" do # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern, # i.e, collect rules that match: # * the action, list and arch, (2-nd argument) # * the other filters, (3-rd argument) # * the auid filters, (4-rd argument) readarray -t similar_rules &lt; &lt;(sed -e \"/$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\") candidate_rules=() # Filter out rules that have more fields then required. This will remove rules more specific than the required scope for s_rule in \"${similar_rules[@]}\" do # Strip all the options and fields we know of, # than check if there was any field left over extra_fields=$(sed -E -e \"s/$ACTION_ARCH_FILTERS//\" -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"&lt;&lt;&lt; \"$s_rule\") grep -q -- \"-F\" &lt;&lt;&lt; \"$extra_fields\" if [ $? -ne 0 ] then candidate_rules+=(\"$s_rule\") fi done if [[ ${#syscall_a[@]} -ge 1 ]] then # Check if the syscall we want is present in any of the similar existing rules for rule in \"${candidate_rules[@]}\" do rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs) all_syscalls_found=0 for syscall in \"${syscall_a[@]}\" do grep -q -- \"\\b${syscall}\\b\" &lt;&lt;&lt; \"$rule_syscalls\" if [ $? -eq 1 ] then # A syscall was not found in the candidate rule all_syscalls_found=1 fi done if [[ $all_syscalls_found -eq 0 ]] then # We found a rule with all the syscall(s) we want; skip rest of macro skip=0 break fi # Check if this rule can be grouped with our target syscall and keep track of it for syscall_g in \"${syscall_grouping[@]}\" do if grep -q -- \"\\b${syscall_g}\\b\" &lt;&lt;&lt; \"$rule_syscalls\" then file_to_edit=${audit_file} rule_to_edit=${rule} rule_syscalls_to_edit=${rule_syscalls} fi done done else # If there is any candidate rule, it is compliant; skip rest of macro if [[ $candidate_rules ]] then skip=0 fi fi if [ \"$skip\" -eq 0 ]; then break fi done if [ \"$skip\" -ne 0 ]; then # We checked all rules that matched the expected resemblance pattern (action, arch &amp; auid) # At this point we know if we need to either append the $full_rule or group # the syscall together with an exsiting rule # Append the full_rule if it cannot be grouped to any other rule if [ -z ${rule_to_edit+x} ] then # Build full_rule while avoid adding double spaces when other_filters is empty if [[ ${syscall_a} ]] then syscall_string=\"\" for syscall in \"${syscall_a[@]}\" do syscall_string+=\" -S $syscall\" done fi other_string=$([[ $OTHER_FILTERS ]] &amp;&amp; echo \" $OTHER_FILTERS\") auid_string=$([[ $AUID_FILTERS ]] &amp;&amp; echo \" $AUID_FILTERS\") full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" echo \"$full_rule\" &gt;&gt; \"$default_file\" chmod o-rwx ${default_file} else # Check if the syscalls are declared as a comma separated list or # as multiple -S parameters if grep -q -- \",\" &lt;&lt;&lt; \"${rule_syscalls_to_edit}\" then delimiter=\",\" else delimiter=\" -S \" fi new_grouped_syscalls=\"${rule_syscalls_to_edit}\" for syscall in \"${syscall_a[@]}\" do grep -q -- \"\\b${syscall}\\b\" &lt;&lt;&lt; \"${rule_syscalls_to_edit}\" if [ $? -eq 1 ] then # A syscall was not found in the candidate rule new_grouped_syscalls+=\"${delimiter}${syscall}\" fi done # Group the syscall in the rule sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\" fi fi # Load macro arguments into arrays read -a syscall_a &lt;&lt;&lt; $SYSCALL read -a syscall_grouping &lt;&lt;&lt; $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspected for presence and correctness # of a particular audit rule. The scheme is as follows: # # ----------------------------------------------------------------------------------------- # Tool used to load audit rules | Rule already defined | Audit rules file to inspect | # ----------------------------------------------------------------------------------------- # auditctl | Doesn't matter | /etc/audit/audit.rules | # ----------------------------------------------------------------------------------------- # augenrules | Yes | /etc/audit/rules.d/*.rules | # augenrules | No | /etc/audit/rules.d/$key.rules | # ----------------------------------------------------------------------------------------- # files_to_inspect=() # If audit tool is 'auditctl', then add '/etc/audit/audit.rules' # file to the list of files to be inspected default_file=\"/etc/audit/audit.rules\" files_to_inspect+=('/etc/audit/audit.rules' ) # Indicator that we want to append $full_rule into $audit_file or edit a rule in it append_expected_rule=0 # After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead skip=1 for audit_file in \"${files_to_inspect[@]}\" do # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern, # i.e, collect rules that match: # * the action, list and arch, (2-nd argument) # * the other filters, (3-rd argument) # * the auid filters, (4-rd argument) readarray -t similar_rules &lt; &lt;(sed -e \"/$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\") candidate_rules=() # Filter out rules that have more fields then required. This will remove rules more specific than the required scope for s_rule in \"${similar_rules[@]}\" do # Strip all the options and fields we know of, # than check if there was any field left over extra_fields=$(sed -E -e \"s/$ACTION_ARCH_FILTERS//\" -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"&lt;&lt;&lt; \"$s_rule\") grep -q -- \"-F\" &lt;&lt;&lt; \"$extra_fields\" if [ $? -ne 0 ] then candidate_rules+=(\"$s_rule\") fi done if [[ ${#syscall_a[@]} -ge 1 ]] then # Check if the syscall we want is present in any of the similar existing rules for rule in \"${candidate_rules[@]}\" do rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs) all_syscalls_found=0 for syscall in \"${syscall_a[@]}\" do grep -q -- \"\\b${syscall}\\b\" &lt;&lt;&lt; \"$rule_syscalls\" if [ $? -eq 1 ] then # A syscall was not found in the candidate rule all_syscalls_found=1 fi done if [[ $all_syscalls_found -eq 0 ]] then # We found a rule with all the syscall(s) we want; skip rest of macro skip=0 break fi # Check if this rule can be grouped with our target syscall and keep track of it for syscall_g in \"${syscall_grouping[@]}\" do if grep -q -- \"\\b${syscall_g}\\b\" &lt;&lt;&lt; \"$rule_syscalls\" then file_to_edit=${audit_file} rule_to_edit=${rule} rule_syscalls_to_edit=${rule_syscalls} fi done done else # If there is any candidate rule, it is compliant; skip rest of macro if [[ $candidate_rules ]] then skip=0 fi fi if [ \"$skip\" -eq 0 ]; then break fi done if [ \"$skip\" -ne 0 ]; then # We checked all rules that matched the expected resemblance pattern (action, arch &amp; auid) # At this point we know if we need to either append the $full_rule or group # the syscall together with an exsiting rule # Append the full_rule if it cannot be grouped to any other rule if [ -z ${rule_to_edit+x} ] then # Build full_rule while avoid adding double spaces when other_filters is empty if [[ ${syscall_a} ]] then syscall_string=\"\" for syscall in \"${syscall_a[@]}\" do syscall_string+=\" -S $syscall\" done fi other_string=$([[ $OTHER_FILTERS ]] &amp;&amp; echo \" $OTHER_FILTERS\") auid_string=$([[ $AUID_FILTERS ]] &amp;&amp; echo \" $AUID_FILTERS\") full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" echo \"$full_rule\" &gt;&gt; \"$default_file\" chmod o-rwx ${default_file} else # Check if the syscalls are declared as a comma separated list or # as multiple -S parameters if grep -q -- \",\" &lt;&lt;&lt; \"${rule_syscalls_to_edit}\" then delimiter=\",\" else delimiter=\" -S \" fi new_grouped_syscalls=\"${rule_syscalls_to_edit}\" for syscall in \"${syscall_a[@]}\" do grep -q -- \"\\b${syscall}\\b\" &lt;&lt;&lt; \"${rule_syscalls_to_edit}\" if [ $? -eq 1 ] then # A syscall was not found in the candidate rule new_grouped_syscalls+=\"${delimiter}${syscall}\" fi done # Group the syscall in the rule sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\" fi fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_dac_actions",
        "rid": "audit_rules_dac_modification_umount2",
        "gtitle": "Record Events that Modify the System's Discretionary Access Controls"
      },
      "id": "audit_dac_actions",
      "title": [
        {
          "#text": "Record Events that Modify the System's Discretionary Access Controls - umount2",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file system umount2 changes. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_execution_acl_commands",
        "rid": "audit_rules_execution_chacl",
        "gtitle": "Record Execution Attempts to Run ACL Privileged Commands"
      },
      "id": "audit_execution_acl_commands",
      "title": [
        {
          "#text": "Record Any Attempts to Run chacl",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect any execution attempt of thecommand for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_execution_acl_commands",
        "rid": "audit_rules_execution_setfacl",
        "gtitle": "Record Execution Attempts to Run ACL Privileged Commands"
      },
      "id": "audit_execution_acl_commands",
      "title": [
        {
          "#text": "Record Any Attempts to Run setfacl",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect any execution attempt of thecommand for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_execution_selinux_commands",
        "rid": "audit_rules_execution_chcon",
        "gtitle": "Record Execution Attempts to Run SELinux Privileged Commands"
      },
      "id": "audit_execution_selinux_commands",
      "title": [
        {
          "#text": "Record Any Attempts to Run chcon",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect any execution attempt of thecommand for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_file_deletion_events",
        "rid": "audit_rules_file_deletion_events_rename",
        "gtitle": "Record File Deletion Events by User"
      },
      "id": "audit_file_deletion_events",
      "title": [
        {
          "#text": "Ensure auditd Collects File Deletion Events by User - rename",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file deletion events for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory, setting ARCH to either b32 or b64 as appropriate for your system:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile, setting ARCH to either b32 or b64 as appropriate for your system:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_file_deletion_events",
        "rid": "audit_rules_file_deletion_events_renameat",
        "gtitle": "Record File Deletion Events by User"
      },
      "id": "audit_file_deletion_events",
      "title": [
        {
          "#text": "Ensure auditd Collects File Deletion Events by User - renameat",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file deletion events for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory, setting ARCH to either b32 or b64 as appropriate for your system:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile, setting ARCH to either b32 or b64 as appropriate for your system:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_file_deletion_events",
        "rid": "audit_rules_file_deletion_events_rmdir",
        "gtitle": "Record File Deletion Events by User"
      },
      "id": "audit_file_deletion_events",
      "title": [
        {
          "#text": "Ensure auditd Collects File Deletion Events by User - rmdir",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file deletion events for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory, setting ARCH to either b32 or b64 as appropriate for your system:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile, setting ARCH to either b32 or b64 as appropriate for your system:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_file_deletion_events",
        "rid": "audit_rules_file_deletion_events_unlink",
        "gtitle": "Record File Deletion Events by User"
      },
      "id": "audit_file_deletion_events",
      "title": [
        {
          "#text": "Ensure auditd Collects File Deletion Events by User - unlink",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file deletion events for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory, setting ARCH to either b32 or b64 as appropriate for your system:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile, setting ARCH to either b32 or b64 as appropriate for your system:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_file_deletion_events",
        "rid": "audit_rules_file_deletion_events_unlinkat",
        "gtitle": "Record File Deletion Events by User"
      },
      "id": "audit_file_deletion_events",
      "title": [
        {
          "#text": "Ensure auditd Collects File Deletion Events by User - unlinkat",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file deletion events for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory, setting ARCH to either b32 or b64 as appropriate for your system:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile, setting ARCH to either b32 or b64 as appropriate for your system:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_file_modification",
        "rid": "audit_rules_unsuccessful_file_modification_creat",
        "gtitle": "Record Unauthorized Access Attempts Events to Files (unsuccessful)"
      },
      "id": "audit_file_modification",
      "title": [
        {
          "#text": "Record Unsuccessful Access Attempts to Files - creat",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect unauthorized file accesses for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory:If the system is 64 bit then also add the following lines:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile:If the system is 64 bit then also add the following lines:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_file_modification",
        "rid": "audit_rules_unsuccessful_file_modification_ftruncate",
        "gtitle": "Record Unauthorized Access Attempts Events to Files (unsuccessful)"
      },
      "id": "audit_file_modification",
      "title": [
        {
          "#text": "Record Unsuccessful Access Attempts to Files - ftruncate",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect unauthorized file accesses for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory:If the system is 64 bit then also add the following lines:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile:If the system is 64 bit then also add the following lines:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_file_modification",
        "rid": "audit_rules_unsuccessful_file_modification_open",
        "gtitle": "Record Unauthorized Access Attempts Events to Files (unsuccessful)"
      },
      "id": "audit_file_modification",
      "title": [
        {
          "#text": "Record Unsuccessful Access Attempts to Files - open",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect unauthorized file accesses for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory:If the system is 64 bit then also add the following lines:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile:If the system is 64 bit then also add the following lines:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_file_modification",
        "rid": "audit_rules_unsuccessful_file_modification_open_by_handle_at",
        "gtitle": "Record Unauthorized Access Attempts Events to Files (unsuccessful)"
      },
      "id": "audit_file_modification",
      "title": [
        {
          "#text": "Record Unsuccessful Access Attempts to Files - open_by_handle_at",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect unauthorized file accesses for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory:If the system is 64 bit then also add the following lines:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile:If the system is 64 bit then also add the following lines:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_file_modification",
        "rid": "audit_rules_unsuccessful_file_modification_openat",
        "gtitle": "Record Unauthorized Access Attempts Events to Files (unsuccessful)"
      },
      "id": "audit_file_modification",
      "title": [
        {
          "#text": "Record Unsuccessful Access Attempts to Files - openat",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect unauthorized file accesses for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory:If the system is 64 bit then also add the following lines:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile:If the system is 64 bit then also add the following lines:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_file_modification",
        "rid": "audit_rules_unsuccessful_file_modification_truncate",
        "gtitle": "Record Unauthorized Access Attempts Events to Files (unsuccessful)"
      },
      "id": "audit_file_modification",
      "title": [
        {
          "#text": "Record Unsuccessful Access Attempts to Files - truncate",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect unauthorized file accesses for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory:If the system is 64 bit then also add the following lines:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile:If the system is 64 bit then also add the following lines:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_kernel_module_loading",
        "rid": "audit_rules_kernel_module_loading_delete",
        "gtitle": "Record Information on Kernel Modules Loading and Unloading",
        "fix_id": "audit_rules_kernel_module_loading_delete"
      },
      "id": "audit_kernel_module_loading",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on Kernel Module Unloading - delete_module",
          "@_lang": "en-US"
        }
      ],
      "desc": "To capture kernel module unloading events, use following line, setting ARCH to either b32 for 32-bit system, or having two lines for both b32 and b64 in case your system is 64-bit:Place to add the line depends on a waydaemon is configured. If it is configured to use theprogram (the default), add the line to a file with suffixin the directory. If thedaemon is configured to use theutility, add the line to file.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'audit' 2&gt;/dev/null | grep -q installed; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system # Note: 32-bit and 64-bit kernel syscall numbers not always line up =&gt; # it's required on a 64-bit system to check also for the presence # of 32-bit's equivalent of the corresponding rule. # (See `man 7 audit.rules` for details ) [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"\"  AUID_FILTERS=\"\"  SYSCALL=\"delete_module\"  KEY=\"modules\"  SYSCALL_GROUPING=\"delete_module\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'  # Load macro arguments into arrays read -a syscall_a &lt;&lt;&lt; $SYSCALL read -a syscall_grouping &lt;&lt;&lt; $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspected for presence and correctness # of a particular audit rule. The scheme is as follows: # # ----------------------------------------------------------------------------------------- # Tool used to load audit rules | Rule already defined | Audit rules file to inspect | # ----------------------------------------------------------------------------------------- # auditctl | Doesn't matter | /etc/audit/audit.rules | # ----------------------------------------------------------------------------------------- # augenrules | Yes | /etc/audit/rules.d/*.rules | # augenrules | No | /etc/audit/rules.d/$key.rules | # ----------------------------------------------------------------------------------------- # files_to_inspect=() # If audit tool is 'augenrules', then check if the audit rule is defined # If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection # If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection default_file=\"/etc/audit/rules.d/$KEY.rules\" # As other_filters may include paths, lets use a different delimiter for it # The \"F\" script expression tells sed to print the filenames where the expressions matched readarray -t files_to_inspect &lt; &lt;(sed -s -n -e \"/$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules) # Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet if [ ${#files_to_inspect[@]} -eq \"0\" ] then file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\" files_to_inspect=(\"$file_to_inspect\") if [ ! -e \"$file_to_inspect\" ] then touch \"$file_to_inspect\" chmod 0640 \"$file_to_inspect\" fi fi # Indicator that we want to append $full_rule into $audit_file or edit a rule in it append_expected_rule=0 # After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead skip=1 for audit_file in \"${files_to_inspect[@]}\" do # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern, # i.e, collect rules that match: # * the action, list and arch, (2-nd argument) # * the other filters, (3-rd argument) # * the auid filters, (4-rd argument) readarray -t similar_rules &lt; &lt;(sed -e \"/$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\") candidate_rules=() # Filter out rules that have more fields then required. This will remove rules more specific than the required scope for s_rule in \"${similar_rules[@]}\" do # Strip all the options and fields we know of, # than check if there was any field left over extra_fields=$(sed -E -e \"s/$ACTION_ARCH_FILTERS//\" -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"&lt;&lt;&lt; \"$s_rule\") grep -q -- \"-F\" &lt;&lt;&lt; \"$extra_fields\" if [ $? -ne 0 ] then candidate_rules+=(\"$s_rule\") fi done if [[ ${#syscall_a[@]} -ge 1 ]] then # Check if the syscall we want is present in any of the similar existing rules for rule in \"${candidate_rules[@]}\" do rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs) all_syscalls_found=0 for syscall in \"${syscall_a[@]}\" do grep -q -- \"\\b${syscall}\\b\" &lt;&lt;&lt; \"$rule_syscalls\" if [ $? -eq 1 ] then # A syscall was not found in the candidate rule all_syscalls_found=1 fi done if [[ $all_syscalls_found -eq 0 ]] then # We found a rule with all the syscall(s) we want; skip rest of macro skip=0 break fi # Check if this rule can be grouped with our target syscall and keep track of it for syscall_g in \"${syscall_grouping[@]}\" do if grep -q -- \"\\b${syscall_g}\\b\" &lt;&lt;&lt; \"$rule_syscalls\" then file_to_edit=${audit_file} rule_to_edit=${rule} rule_syscalls_to_edit=${rule_syscalls} fi done done else # If there is any candidate rule, it is compliant; skip rest of macro if [[ $candidate_rules ]] then skip=0 fi fi if [ \"$skip\" -eq 0 ]; then break fi done if [ \"$skip\" -ne 0 ]; then # We checked all rules that matched the expected resemblance pattern (action, arch &amp; auid) # At this point we know if we need to either append the $full_rule or group # the syscall together with an exsiting rule # Append the full_rule if it cannot be grouped to any other rule if [ -z ${rule_to_edit+x} ] then # Build full_rule while avoid adding double spaces when other_filters is empty if [[ ${syscall_a} ]] then syscall_string=\"\" for syscall in \"${syscall_a[@]}\" do syscall_string+=\" -S $syscall\" done fi other_string=$([[ $OTHER_FILTERS ]] &amp;&amp; echo \" $OTHER_FILTERS\") auid_string=$([[ $AUID_FILTERS ]] &amp;&amp; echo \" $AUID_FILTERS\") full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" echo \"$full_rule\" &gt;&gt; \"$default_file\" chmod o-rwx ${default_file} else # Check if the syscalls are declared as a comma separated list or # as multiple -S parameters if grep -q -- \",\" &lt;&lt;&lt; \"${rule_syscalls_to_edit}\" then delimiter=\",\" else delimiter=\" -S \" fi new_grouped_syscalls=\"${rule_syscalls_to_edit}\" for syscall in \"${syscall_a[@]}\" do grep -q -- \"\\b${syscall}\\b\" &lt;&lt;&lt; \"${rule_syscalls_to_edit}\" if [ $? -eq 1 ] then # A syscall was not found in the candidate rule new_grouped_syscalls+=\"${delimiter}${syscall}\" fi done # Group the syscall in the rule sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\" fi fi  # Load macro arguments into arrays read -a syscall_a &lt;&lt;&lt; $SYSCALL read -a syscall_grouping &lt;&lt;&lt; $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspected for presence and correctness # of a particular audit rule. The scheme is as follows: # # ----------------------------------------------------------------------------------------- # Tool used to load audit rules | Rule already defined | Audit rules file to inspect | # ----------------------------------------------------------------------------------------- # auditctl | Doesn't matter | /etc/audit/audit.rules | # ----------------------------------------------------------------------------------------- # augenrules | Yes | /etc/audit/rules.d/*.rules | # augenrules | No | /etc/audit/rules.d/$key.rules | # ----------------------------------------------------------------------------------------- # files_to_inspect=() # If audit tool is 'auditctl', then add '/etc/audit/audit.rules' # file to the list of files to be inspected default_file=\"/etc/audit/audit.rules\" files_to_inspect+=('/etc/audit/audit.rules' ) # Indicator that we want to append $full_rule into $audit_file or edit a rule in it append_expected_rule=0 # After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead skip=1 for audit_file in \"${files_to_inspect[@]}\" do # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern, # i.e, collect rules that match: # * the action, list and arch, (2-nd argument) # * the other filters, (3-rd argument) # * the auid filters, (4-rd argument) readarray -t similar_rules &lt; &lt;(sed -e \"/$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\") candidate_rules=() # Filter out rules that have more fields then required. This will remove rules more specific than the required scope for s_rule in \"${similar_rules[@]}\" do # Strip all the options and fields we know of, # than check if there was any field left over extra_fields=$(sed -E -e \"s/$ACTION_ARCH_FILTERS//\" -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"&lt;&lt;&lt; \"$s_rule\") grep -q -- \"-F\" &lt;&lt;&lt; \"$extra_fields\" if [ $? -ne 0 ] then candidate_rules+=(\"$s_rule\") fi done if [[ ${#syscall_a[@]} -ge 1 ]] then # Check if the syscall we want is present in any of the similar existing rules for rule in \"${candidate_rules[@]}\" do rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs) all_syscalls_found=0 for syscall in \"${syscall_a[@]}\" do grep -q -- \"\\b${syscall}\\b\" &lt;&lt;&lt; \"$rule_syscalls\" if [ $? -eq 1 ] then # A syscall was not found in the candidate rule all_syscalls_found=1 fi done if [[ $all_syscalls_found -eq 0 ]] then # We found a rule with all the syscall(s) we want; skip rest of macro skip=0 break fi # Check if this rule can be grouped with our target syscall and keep track of it for syscall_g in \"${syscall_grouping[@]}\" do if grep -q -- \"\\b${syscall_g}\\b\" &lt;&lt;&lt; \"$rule_syscalls\" then file_to_edit=${audit_file} rule_to_edit=${rule} rule_syscalls_to_edit=${rule_syscalls} fi done done else # If there is any candidate rule, it is compliant; skip rest of macro if [[ $candidate_rules ]] then skip=0 fi fi if [ \"$skip\" -eq 0 ]; then break fi done if [ \"$skip\" -ne 0 ]; then # We checked all rules that matched the expected resemblance pattern (action, arch &amp; auid) # At this point we know if we need to either append the $full_rule or group # the syscall together with an exsiting rule # Append the full_rule if it cannot be grouped to any other rule if [ -z ${rule_to_edit+x} ] then # Build full_rule while avoid adding double spaces when other_filters is empty if [[ ${syscall_a} ]] then syscall_string=\"\" for syscall in \"${syscall_a[@]}\" do syscall_string+=\" -S $syscall\" done fi other_string=$([[ $OTHER_FILTERS ]] &amp;&amp; echo \" $OTHER_FILTERS\") auid_string=$([[ $AUID_FILTERS ]] &amp;&amp; echo \" $AUID_FILTERS\") full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" echo \"$full_rule\" &gt;&gt; \"$default_file\" chmod o-rwx ${default_file} else # Check if the syscalls are declared as a comma separated list or # as multiple -S parameters if grep -q -- \",\" &lt;&lt;&lt; \"${rule_syscalls_to_edit}\" then delimiter=\",\" else delimiter=\" -S \" fi new_grouped_syscalls=\"${rule_syscalls_to_edit}\" for syscall in \"${syscall_a[@]}\" do grep -q -- \"\\b${syscall}\\b\" &lt;&lt;&lt; \"${rule_syscalls_to_edit}\" if [ $? -eq 1 ] then # A syscall was not found in the candidate rule new_grouped_syscalls+=\"${delimiter}${syscall}\" fi done # Group the syscall in the rule sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\" fi fi done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_kernel_module_loading",
        "rid": "audit_rules_kernel_module_loading_finit",
        "gtitle": "Record Information on Kernel Modules Loading and Unloading",
        "fix_id": "audit_rules_kernel_module_loading_finit"
      },
      "id": "audit_kernel_module_loading",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on Kernel Module Loading and Unloading - finit_module",
          "@_lang": "en-US"
        }
      ],
      "desc": "If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directoryto capture kernel module loading and unloading events, setting ARCH to either b32 or b64 as appropriate for your system:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile in order to capture kernel module loading and unloading events, setting ARCH to either b32 or b64 as appropriate for your system:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'audit' 2&gt;/dev/null | grep -q installed; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system # Note: 32-bit and 64-bit kernel syscall numbers not always line up =&gt; # it's required on a 64-bit system to check also for the presence # of 32-bit's equivalent of the corresponding rule. # (See `man 7 audit.rules` for details ) [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"\"  AUID_FILTERS=\"\"  SYSCALL=\"finit_module\"  KEY=\"modules\"  SYSCALL_GROUPING=\"init_module finit_module\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'  # Load macro arguments into arrays read -a syscall_a &lt;&lt;&lt; $SYSCALL read -a syscall_grouping &lt;&lt;&lt; $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspected for presence and correctness # of a particular audit rule. The scheme is as follows: # # ----------------------------------------------------------------------------------------- # Tool used to load audit rules | Rule already defined | Audit rules file to inspect | # ----------------------------------------------------------------------------------------- # auditctl | Doesn't matter | /etc/audit/audit.rules | # ----------------------------------------------------------------------------------------- # augenrules | Yes | /etc/audit/rules.d/*.rules | # augenrules | No | /etc/audit/rules.d/$key.rules | # ----------------------------------------------------------------------------------------- # files_to_inspect=() # If audit tool is 'augenrules', then check if the audit rule is defined # If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection # If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection default_file=\"/etc/audit/rules.d/$KEY.rules\" # As other_filters may include paths, lets use a different delimiter for it # The \"F\" script expression tells sed to print the filenames where the expressions matched readarray -t files_to_inspect &lt; &lt;(sed -s -n -e \"/$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules) # Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet if [ ${#files_to_inspect[@]} -eq \"0\" ] then file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\" files_to_inspect=(\"$file_to_inspect\") if [ ! -e \"$file_to_inspect\" ] then touch \"$file_to_inspect\" chmod 0640 \"$file_to_inspect\" fi fi # Indicator that we want to append $full_rule into $audit_file or edit a rule in it append_expected_rule=0 # After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead skip=1 for audit_file in \"${files_to_inspect[@]}\" do # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern, # i.e, collect rules that match: # * the action, list and arch, (2-nd argument) # * the other filters, (3-rd argument) # * the auid filters, (4-rd argument) readarray -t similar_rules &lt; &lt;(sed -e \"/$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\") candidate_rules=() # Filter out rules that have more fields then required. This will remove rules more specific than the required scope for s_rule in \"${similar_rules[@]}\" do # Strip all the options and fields we know of, # than check if there was any field left over extra_fields=$(sed -E -e \"s/$ACTION_ARCH_FILTERS//\" -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"&lt;&lt;&lt; \"$s_rule\") grep -q -- \"-F\" &lt;&lt;&lt; \"$extra_fields\" if [ $? -ne 0 ] then candidate_rules+=(\"$s_rule\") fi done if [[ ${#syscall_a[@]} -ge 1 ]] then # Check if the syscall we want is present in any of the similar existing rules for rule in \"${candidate_rules[@]}\" do rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs) all_syscalls_found=0 for syscall in \"${syscall_a[@]}\" do grep -q -- \"\\b${syscall}\\b\" &lt;&lt;&lt; \"$rule_syscalls\" if [ $? -eq 1 ] then # A syscall was not found in the candidate rule all_syscalls_found=1 fi done if [[ $all_syscalls_found -eq 0 ]] then # We found a rule with all the syscall(s) we want; skip rest of macro skip=0 break fi # Check if this rule can be grouped with our target syscall and keep track of it for syscall_g in \"${syscall_grouping[@]}\" do if grep -q -- \"\\b${syscall_g}\\b\" &lt;&lt;&lt; \"$rule_syscalls\" then file_to_edit=${audit_file} rule_to_edit=${rule} rule_syscalls_to_edit=${rule_syscalls} fi done done else # If there is any candidate rule, it is compliant; skip rest of macro if [[ $candidate_rules ]] then skip=0 fi fi if [ \"$skip\" -eq 0 ]; then break fi done if [ \"$skip\" -ne 0 ]; then # We checked all rules that matched the expected resemblance pattern (action, arch &amp; auid) # At this point we know if we need to either append the $full_rule or group # the syscall together with an exsiting rule # Append the full_rule if it cannot be grouped to any other rule if [ -z ${rule_to_edit+x} ] then # Build full_rule while avoid adding double spaces when other_filters is empty if [[ ${syscall_a} ]] then syscall_string=\"\" for syscall in \"${syscall_a[@]}\" do syscall_string+=\" -S $syscall\" done fi other_string=$([[ $OTHER_FILTERS ]] &amp;&amp; echo \" $OTHER_FILTERS\") auid_string=$([[ $AUID_FILTERS ]] &amp;&amp; echo \" $AUID_FILTERS\") full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" echo \"$full_rule\" &gt;&gt; \"$default_file\" chmod o-rwx ${default_file} else # Check if the syscalls are declared as a comma separated list or # as multiple -S parameters if grep -q -- \",\" &lt;&lt;&lt; \"${rule_syscalls_to_edit}\" then delimiter=\",\" else delimiter=\" -S \" fi new_grouped_syscalls=\"${rule_syscalls_to_edit}\" for syscall in \"${syscall_a[@]}\" do grep -q -- \"\\b${syscall}\\b\" &lt;&lt;&lt; \"${rule_syscalls_to_edit}\" if [ $? -eq 1 ] then # A syscall was not found in the candidate rule new_grouped_syscalls+=\"${delimiter}${syscall}\" fi done # Group the syscall in the rule sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\" fi fi  # Load macro arguments into arrays read -a syscall_a &lt;&lt;&lt; $SYSCALL read -a syscall_grouping &lt;&lt;&lt; $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspected for presence and correctness # of a particular audit rule. The scheme is as follows: # # ----------------------------------------------------------------------------------------- # Tool used to load audit rules | Rule already defined | Audit rules file to inspect | # ----------------------------------------------------------------------------------------- # auditctl | Doesn't matter | /etc/audit/audit.rules | # ----------------------------------------------------------------------------------------- # augenrules | Yes | /etc/audit/rules.d/*.rules | # augenrules | No | /etc/audit/rules.d/$key.rules | # ----------------------------------------------------------------------------------------- # files_to_inspect=() # If audit tool is 'auditctl', then add '/etc/audit/audit.rules' # file to the list of files to be inspected default_file=\"/etc/audit/audit.rules\" files_to_inspect+=('/etc/audit/audit.rules' ) # Indicator that we want to append $full_rule into $audit_file or edit a rule in it append_expected_rule=0 # After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead skip=1 for audit_file in \"${files_to_inspect[@]}\" do # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern, # i.e, collect rules that match: # * the action, list and arch, (2-nd argument) # * the other filters, (3-rd argument) # * the auid filters, (4-rd argument) readarray -t similar_rules &lt; &lt;(sed -e \"/$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\") candidate_rules=() # Filter out rules that have more fields then required. This will remove rules more specific than the required scope for s_rule in \"${similar_rules[@]}\" do # Strip all the options and fields we know of, # than check if there was any field left over extra_fields=$(sed -E -e \"s/$ACTION_ARCH_FILTERS//\" -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"&lt;&lt;&lt; \"$s_rule\") grep -q -- \"-F\" &lt;&lt;&lt; \"$extra_fields\" if [ $? -ne 0 ] then candidate_rules+=(\"$s_rule\") fi done if [[ ${#syscall_a[@]} -ge 1 ]] then # Check if the syscall we want is present in any of the similar existing rules for rule in \"${candidate_rules[@]}\" do rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs) all_syscalls_found=0 for syscall in \"${syscall_a[@]}\" do grep -q -- \"\\b${syscall}\\b\" &lt;&lt;&lt; \"$rule_syscalls\" if [ $? -eq 1 ] then # A syscall was not found in the candidate rule all_syscalls_found=1 fi done if [[ $all_syscalls_found -eq 0 ]] then # We found a rule with all the syscall(s) we want; skip rest of macro skip=0 break fi # Check if this rule can be grouped with our target syscall and keep track of it for syscall_g in \"${syscall_grouping[@]}\" do if grep -q -- \"\\b${syscall_g}\\b\" &lt;&lt;&lt; \"$rule_syscalls\" then file_to_edit=${audit_file} rule_to_edit=${rule} rule_syscalls_to_edit=${rule_syscalls} fi done done else # If there is any candidate rule, it is compliant; skip rest of macro if [[ $candidate_rules ]] then skip=0 fi fi if [ \"$skip\" -eq 0 ]; then break fi done if [ \"$skip\" -ne 0 ]; then # We checked all rules that matched the expected resemblance pattern (action, arch &amp; auid) # At this point we know if we need to either append the $full_rule or group # the syscall together with an exsiting rule # Append the full_rule if it cannot be grouped to any other rule if [ -z ${rule_to_edit+x} ] then # Build full_rule while avoid adding double spaces when other_filters is empty if [[ ${syscall_a} ]] then syscall_string=\"\" for syscall in \"${syscall_a[@]}\" do syscall_string+=\" -S $syscall\" done fi other_string=$([[ $OTHER_FILTERS ]] &amp;&amp; echo \" $OTHER_FILTERS\") auid_string=$([[ $AUID_FILTERS ]] &amp;&amp; echo \" $AUID_FILTERS\") full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" echo \"$full_rule\" &gt;&gt; \"$default_file\" chmod o-rwx ${default_file} else # Check if the syscalls are declared as a comma separated list or # as multiple -S parameters if grep -q -- \",\" &lt;&lt;&lt; \"${rule_syscalls_to_edit}\" then delimiter=\",\" else delimiter=\" -S \" fi new_grouped_syscalls=\"${rule_syscalls_to_edit}\" for syscall in \"${syscall_a[@]}\" do grep -q -- \"\\b${syscall}\\b\" &lt;&lt;&lt; \"${rule_syscalls_to_edit}\" if [ $? -eq 1 ] then # A syscall was not found in the candidate rule new_grouped_syscalls+=\"${delimiter}${syscall}\" fi done # Group the syscall in the rule sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\" fi fi done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_kernel_module_loading",
        "rid": "audit_rules_kernel_module_loading_init",
        "gtitle": "Record Information on Kernel Modules Loading and Unloading",
        "fix_id": "audit_rules_kernel_module_loading_init"
      },
      "id": "audit_kernel_module_loading",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on Kernel Module Loading - init_module",
          "@_lang": "en-US"
        }
      ],
      "desc": "To capture kernel module loading events, use following line, setting ARCH to either b32 for 32-bit system, or having two lines for both b32 and b64 in case your system is 64-bit:Place to add the line depends on a waydaemon is configured. If it is configured to use theprogram (the default), add the line to a file with suffixin the directory. If thedaemon is configured to use theutility, add the line to file.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'audit' 2&gt;/dev/null | grep -q installed; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system # Note: 32-bit and 64-bit kernel syscall numbers not always line up =&gt; # it's required on a 64-bit system to check also for the presence # of 32-bit's equivalent of the corresponding rule. # (See `man 7 audit.rules` for details ) [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"\"  AUID_FILTERS=\"\"  SYSCALL=\"init_module\"  KEY=\"modules\"  SYSCALL_GROUPING=\"init_module finit_module\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'  # Load macro arguments into arrays read -a syscall_a &lt;&lt;&lt; $SYSCALL read -a syscall_grouping &lt;&lt;&lt; $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspected for presence and correctness # of a particular audit rule. The scheme is as follows: # # ----------------------------------------------------------------------------------------- # Tool used to load audit rules | Rule already defined | Audit rules file to inspect | # ----------------------------------------------------------------------------------------- # auditctl | Doesn't matter | /etc/audit/audit.rules | # ----------------------------------------------------------------------------------------- # augenrules | Yes | /etc/audit/rules.d/*.rules | # augenrules | No | /etc/audit/rules.d/$key.rules | # ----------------------------------------------------------------------------------------- # files_to_inspect=() # If audit tool is 'augenrules', then check if the audit rule is defined # If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection # If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection default_file=\"/etc/audit/rules.d/$KEY.rules\" # As other_filters may include paths, lets use a different delimiter for it # The \"F\" script expression tells sed to print the filenames where the expressions matched readarray -t files_to_inspect &lt; &lt;(sed -s -n -e \"/$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules) # Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet if [ ${#files_to_inspect[@]} -eq \"0\" ] then file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\" files_to_inspect=(\"$file_to_inspect\") if [ ! -e \"$file_to_inspect\" ] then touch \"$file_to_inspect\" chmod 0640 \"$file_to_inspect\" fi fi # Indicator that we want to append $full_rule into $audit_file or edit a rule in it append_expected_rule=0 # After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead skip=1 for audit_file in \"${files_to_inspect[@]}\" do # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern, # i.e, collect rules that match: # * the action, list and arch, (2-nd argument) # * the other filters, (3-rd argument) # * the auid filters, (4-rd argument) readarray -t similar_rules &lt; &lt;(sed -e \"/$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\") candidate_rules=() # Filter out rules that have more fields then required. This will remove rules more specific than the required scope for s_rule in \"${similar_rules[@]}\" do # Strip all the options and fields we know of, # than check if there was any field left over extra_fields=$(sed -E -e \"s/$ACTION_ARCH_FILTERS//\" -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"&lt;&lt;&lt; \"$s_rule\") grep -q -- \"-F\" &lt;&lt;&lt; \"$extra_fields\" if [ $? -ne 0 ] then candidate_rules+=(\"$s_rule\") fi done if [[ ${#syscall_a[@]} -ge 1 ]] then # Check if the syscall we want is present in any of the similar existing rules for rule in \"${candidate_rules[@]}\" do rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs) all_syscalls_found=0 for syscall in \"${syscall_a[@]}\" do grep -q -- \"\\b${syscall}\\b\" &lt;&lt;&lt; \"$rule_syscalls\" if [ $? -eq 1 ] then # A syscall was not found in the candidate rule all_syscalls_found=1 fi done if [[ $all_syscalls_found -eq 0 ]] then # We found a rule with all the syscall(s) we want; skip rest of macro skip=0 break fi # Check if this rule can be grouped with our target syscall and keep track of it for syscall_g in \"${syscall_grouping[@]}\" do if grep -q -- \"\\b${syscall_g}\\b\" &lt;&lt;&lt; \"$rule_syscalls\" then file_to_edit=${audit_file} rule_to_edit=${rule} rule_syscalls_to_edit=${rule_syscalls} fi done done else # If there is any candidate rule, it is compliant; skip rest of macro if [[ $candidate_rules ]] then skip=0 fi fi if [ \"$skip\" -eq 0 ]; then break fi done if [ \"$skip\" -ne 0 ]; then # We checked all rules that matched the expected resemblance pattern (action, arch &amp; auid) # At this point we know if we need to either append the $full_rule or group # the syscall together with an exsiting rule # Append the full_rule if it cannot be grouped to any other rule if [ -z ${rule_to_edit+x} ] then # Build full_rule while avoid adding double spaces when other_filters is empty if [[ ${syscall_a} ]] then syscall_string=\"\" for syscall in \"${syscall_a[@]}\" do syscall_string+=\" -S $syscall\" done fi other_string=$([[ $OTHER_FILTERS ]] &amp;&amp; echo \" $OTHER_FILTERS\") auid_string=$([[ $AUID_FILTERS ]] &amp;&amp; echo \" $AUID_FILTERS\") full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" echo \"$full_rule\" &gt;&gt; \"$default_file\" chmod o-rwx ${default_file} else # Check if the syscalls are declared as a comma separated list or # as multiple -S parameters if grep -q -- \",\" &lt;&lt;&lt; \"${rule_syscalls_to_edit}\" then delimiter=\",\" else delimiter=\" -S \" fi new_grouped_syscalls=\"${rule_syscalls_to_edit}\" for syscall in \"${syscall_a[@]}\" do grep -q -- \"\\b${syscall}\\b\" &lt;&lt;&lt; \"${rule_syscalls_to_edit}\" if [ $? -eq 1 ] then # A syscall was not found in the candidate rule new_grouped_syscalls+=\"${delimiter}${syscall}\" fi done # Group the syscall in the rule sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\" fi fi  # Load macro arguments into arrays read -a syscall_a &lt;&lt;&lt; $SYSCALL read -a syscall_grouping &lt;&lt;&lt; $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspected for presence and correctness # of a particular audit rule. The scheme is as follows: # # ----------------------------------------------------------------------------------------- # Tool used to load audit rules | Rule already defined | Audit rules file to inspect | # ----------------------------------------------------------------------------------------- # auditctl | Doesn't matter | /etc/audit/audit.rules | # ----------------------------------------------------------------------------------------- # augenrules | Yes | /etc/audit/rules.d/*.rules | # augenrules | No | /etc/audit/rules.d/$key.rules | # ----------------------------------------------------------------------------------------- # files_to_inspect=() # If audit tool is 'auditctl', then add '/etc/audit/audit.rules' # file to the list of files to be inspected default_file=\"/etc/audit/audit.rules\" files_to_inspect+=('/etc/audit/audit.rules' ) # Indicator that we want to append $full_rule into $audit_file or edit a rule in it append_expected_rule=0 # After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead skip=1 for audit_file in \"${files_to_inspect[@]}\" do # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern, # i.e, collect rules that match: # * the action, list and arch, (2-nd argument) # * the other filters, (3-rd argument) # * the auid filters, (4-rd argument) readarray -t similar_rules &lt; &lt;(sed -e \"/$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\") candidate_rules=() # Filter out rules that have more fields then required. This will remove rules more specific than the required scope for s_rule in \"${similar_rules[@]}\" do # Strip all the options and fields we know of, # than check if there was any field left over extra_fields=$(sed -E -e \"s/$ACTION_ARCH_FILTERS//\" -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"&lt;&lt;&lt; \"$s_rule\") grep -q -- \"-F\" &lt;&lt;&lt; \"$extra_fields\" if [ $? -ne 0 ] then candidate_rules+=(\"$s_rule\") fi done if [[ ${#syscall_a[@]} -ge 1 ]] then # Check if the syscall we want is present in any of the similar existing rules for rule in \"${candidate_rules[@]}\" do rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs) all_syscalls_found=0 for syscall in \"${syscall_a[@]}\" do grep -q -- \"\\b${syscall}\\b\" &lt;&lt;&lt; \"$rule_syscalls\" if [ $? -eq 1 ] then # A syscall was not found in the candidate rule all_syscalls_found=1 fi done if [[ $all_syscalls_found -eq 0 ]] then # We found a rule with all the syscall(s) we want; skip rest of macro skip=0 break fi # Check if this rule can be grouped with our target syscall and keep track of it for syscall_g in \"${syscall_grouping[@]}\" do if grep -q -- \"\\b${syscall_g}\\b\" &lt;&lt;&lt; \"$rule_syscalls\" then file_to_edit=${audit_file} rule_to_edit=${rule} rule_syscalls_to_edit=${rule_syscalls} fi done done else # If there is any candidate rule, it is compliant; skip rest of macro if [[ $candidate_rules ]] then skip=0 fi fi if [ \"$skip\" -eq 0 ]; then break fi done if [ \"$skip\" -ne 0 ]; then # We checked all rules that matched the expected resemblance pattern (action, arch &amp; auid) # At this point we know if we need to either append the $full_rule or group # the syscall together with an exsiting rule # Append the full_rule if it cannot be grouped to any other rule if [ -z ${rule_to_edit+x} ] then # Build full_rule while avoid adding double spaces when other_filters is empty if [[ ${syscall_a} ]] then syscall_string=\"\" for syscall in \"${syscall_a[@]}\" do syscall_string+=\" -S $syscall\" done fi other_string=$([[ $OTHER_FILTERS ]] &amp;&amp; echo \" $OTHER_FILTERS\") auid_string=$([[ $AUID_FILTERS ]] &amp;&amp; echo \" $AUID_FILTERS\") full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" echo \"$full_rule\" &gt;&gt; \"$default_file\" chmod o-rwx ${default_file} else # Check if the syscalls are declared as a comma separated list or # as multiple -S parameters if grep -q -- \",\" &lt;&lt;&lt; \"${rule_syscalls_to_edit}\" then delimiter=\",\" else delimiter=\" -S \" fi new_grouped_syscalls=\"${rule_syscalls_to_edit}\" for syscall in \"${syscall_a[@]}\" do grep -q -- \"\\b${syscall}\\b\" &lt;&lt;&lt; \"${rule_syscalls_to_edit}\" if [ $? -eq 1 ] then # A syscall was not found in the candidate rule new_grouped_syscalls+=\"${delimiter}${syscall}\" fi done # Group the syscall in the rule sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\" fi fi done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_login_events",
        "rid": "audit_rules_login_events_faillog",
        "gtitle": "Record Attempts to Alter Logon and Logout Events"
      },
      "id": "audit_login_events",
      "title": [
        {
          "#text": "Record Attempts to Alter Logon and Logout Events - faillog",
          "@_lang": "en-US"
        }
      ],
      "desc": "The audit system already collects login information for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directoryin order to watch for attempted manual edits of files involved in storing logon events:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile in order to watch for unattempted manual edits of files involved in storing logon events:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_login_events",
        "rid": "audit_rules_login_events_lastlog",
        "gtitle": "Record Attempts to Alter Logon and Logout Events"
      },
      "id": "audit_login_events",
      "title": [
        {
          "#text": "Record Attempts to Alter Logon and Logout Events - lastlog",
          "@_lang": "en-US"
        }
      ],
      "desc": "The audit system already collects login information for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directoryin order to watch for attempted manual edits of files involved in storing logon events:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile in order to watch for unattempted manual edits of files involved in storing logon events:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_login_events",
        "rid": "audit_rules_login_events_tallylog",
        "gtitle": "Record Attempts to Alter Logon and Logout Events"
      },
      "id": "audit_login_events",
      "title": [
        {
          "#text": "Record Attempts to Alter Logon and Logout Events - tallylog",
          "@_lang": "en-US"
        }
      ],
      "desc": "The audit system already collects login information for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directoryin order to watch for attempted manual edits of files involved in storing logon events:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile in order to watch for unattempted manual edits of files involved in storing logon events:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands",
        "gtitle": "Record Information on the Use of Privileged Commands"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands",
          "@_lang": "en-US"
        }
      ],
      "desc": "The audit system should collect information about usage of privileged commands for all users and root. To find the relevant setuid / setgid programs, run the following command for each local partition:If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directoryfor each setuid / setgid program on the system, replacing thepart with the full path of that setuid / setgid program in the list:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form tofor each setuid / setgid program on the system, replacing thepart with the full path of that setuid / setgid program in the list:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_at",
        "gtitle": "Record Information on the Use of Privileged Commands"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - at",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_chage",
        "gtitle": "Record Information on the Use of Privileged Commands"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - chage",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_chfn",
        "gtitle": "Record Information on the Use of Privileged Commands"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - chfn",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_chsh",
        "gtitle": "Record Information on the Use of Privileged Commands"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - chsh",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_crontab",
        "gtitle": "Record Information on the Use of Privileged Commands"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - crontab",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_gpasswd",
        "gtitle": "Record Information on the Use of Privileged Commands"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - gpasswd",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_insmod",
        "gtitle": "Record Information on the Use of Privileged Commands"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - insmod",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_kmod",
        "gtitle": "Record Information on the Use of Privileged Commands"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - kmod",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_modprobe",
        "gtitle": "Record Information on the Use of Privileged Commands"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - modprobe",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_mount",
        "gtitle": "Record Information on the Use of Privileged Commands"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - mount",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_newgidmap",
        "gtitle": "Record Information on the Use of Privileged Commands"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - newgidmap",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_newgrp",
        "gtitle": "Record Information on the Use of Privileged Commands"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - newgrp",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_newuidmap",
        "gtitle": "Record Information on the Use of Privileged Commands"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - newuidmap",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_pam_timestamp_check",
        "gtitle": "Record Information on the Use of Privileged Commands"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - pam_timestamp_check",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_passwd",
        "gtitle": "Record Information on the Use of Privileged Commands"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - passwd",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_postdrop",
        "gtitle": "Record Information on the Use of Privileged Commands"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - postdrop",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_postqueue",
        "gtitle": "Record Information on the Use of Privileged Commands"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - postqueue",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_rmmod",
        "gtitle": "Record Information on the Use of Privileged Commands"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - rmmod",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_ssh_agent",
        "gtitle": "Record Information on the Use of Privileged Commands"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Record Any Attempts to Run ssh-agent",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect any execution attempt of thecommand for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_ssh_keysign",
        "gtitle": "Record Information on the Use of Privileged Commands"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - ssh-keysign",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_su",
        "gtitle": "Record Information on the Use of Privileged Commands"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - su",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_sudo",
        "gtitle": "Record Information on the Use of Privileged Commands"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - sudo",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_sudoedit",
        "gtitle": "Record Information on the Use of Privileged Commands"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - sudoedit",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_umount",
        "gtitle": "Record Information on the Use of Privileged Commands"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - umount",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_unix_chkpwd",
        "gtitle": "Record Information on the Use of Privileged Commands"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - unix_chkpwd",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_usermod",
        "gtitle": "Record Information on the Use of Privileged Commands"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - usermod",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_time_rules",
        "rid": "audit_rules_time_adjtimex",
        "gtitle": "Records Events that Modify Date and Time Information",
        "fix_id": "audit_rules_time_adjtimex"
      },
      "id": "audit_time_rules",
      "title": [
        {
          "#text": "Record attempts to alter time through adjtimex",
          "@_lang": "en-US"
        }
      ],
      "desc": "If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:The -k option allows for the specification of a key in string form that can be used for better reporting capability through ausearch and aureport. Multiple system calls can be defined on the same line to save space if desired, but is not required. See an example of multiple combined syscalls:",
      "impact": 0.5,
      "descs": {
        "fix": "- name: Gather the package facts package_facts: manager: auto tags: - CJIS-5.4.1.1 - NIST-800-171-3.1.7 - NIST-800-53-AC-6(9) - NIST-800-53-AU-12(c) - NIST-800-53-AU-2(d) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.4.2.b - audit_rules_time_adjtimex - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy - name: Set architecture for audit tasks set_fact: audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }} when: '\"audit\" in ansible_facts.packages' tags: - CJIS-5.4.1.1 - NIST-800-171-3.1.7 - NIST-800-53-AC-6(9) - NIST-800-53-AU-12(c) - NIST-800-53-AU-2(d) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.4.2.b - audit_rules_time_adjtimex - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy - name: Perform remediation of Audit rules for adjtimex for x86 platform block: - name: Declare list of syscalls set_fact: syscalls: - adjtimex syscall_grouping: - adjtimex - settimeofday - stime - name: Check existence of adjtimex in /etc/audit/rules.d/ find: paths: /etc/audit/rules.d contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$ patterns: '*.rules' register: find_command loop: '{{ (syscall_grouping + syscalls) | unique }}' - name: Reset syscalls found per file set_fact: syscalls_per_file: {} found_paths_dict: {} - name: Declare syscalls found per file set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\" loop: '{{ find_command.results | selectattr(''matched'') | list }}' - name: Declare files where syscalls were found set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}\" - name: Count occurrences of syscalls in paths set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}\" loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}' - name: Get path with most syscalls set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}\" when: found_paths | length &gt;= 1 - name: No file with syscall found, set path to /etc/audit/rules.d/audit_time_rules.rules set_fact: audit_file=\"/etc/audit/rules.d/audit_time_rules.rules\" when: found_paths | length == 0 - name: Declare found syscalls set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}\" - name: Declare missing syscalls set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\" - name: Replace the audit rule in {{ audit_file }} lineinfile: path: '{{ audit_file }}' regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+) line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4 backrefs: true state: present when: syscalls_found | length &gt; 0 and missing_syscalls | length &gt; 0 - name: Add the audit rule to {{ audit_file }} lineinfile: path: '{{ audit_file }}' line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=audit_time_rules create: true mode: o-rwx state: present when: syscalls_found | length == 0 - name: Declare list of syscalls set_fact: syscalls: - adjtimex syscall_grouping: - adjtimex - settimeofday - stime - name: Check existence of adjtimex in /etc/audit/audit.rules find: paths: /etc/audit contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$ patterns: audit.rules register: find_command loop: '{{ (syscall_grouping + syscalls) | unique }}' - name: Set path to /etc/audit/audit.rules set_fact: audit_file=\"/etc/audit/audit.rules\" - name: Declare found syscalls set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}\" - name: Declare missing syscalls set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\" - name: Replace the audit rule in {{ audit_file }} lineinfile: path: '{{ audit_file }}' regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+) line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4 backrefs: true state: present when: syscalls_found | length &gt; 0 and missing_syscalls | length &gt; 0 - name: Add the audit rule to {{ audit_file }} lineinfile: path: '{{ audit_file }}' line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=audit_time_rules create: true mode: o-rwx state: present when: syscalls_found | length == 0 when: '\"audit\" in ansible_facts.packages' tags: - CJIS-5.4.1.1 - NIST-800-171-3.1.7 - NIST-800-53-AC-6(9) - NIST-800-53-AU-12(c) - NIST-800-53-AU-2(d) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.4.2.b - audit_rules_time_adjtimex - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy - name: Perform remediation of Audit rules for adjtimex for x86_64 platform block: - name: Declare list of syscalls set_fact: syscalls: - adjtimex syscall_grouping: - adjtimex - settimeofday - name: Check existence of adjtimex in /etc/audit/rules.d/ find: paths: /etc/audit/rules.d contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$ patterns: '*.rules' register: find_command loop: '{{ (syscall_grouping + syscalls) | unique }}' - name: Reset syscalls found per file set_fact: syscalls_per_file: {} found_paths_dict: {} - name: Declare syscalls found per file set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\" loop: '{{ find_command.results | selectattr(''matched'') | list }}' - name: Declare files where syscalls were found set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}\" - name: Count occurrences of syscalls in paths set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}\" loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}' - name: Get path with most syscalls set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}\" when: found_paths | length &gt;= 1 - name: No file with syscall found, set path to /etc/audit/rules.d/audit_time_rules.rules set_fact: audit_file=\"/etc/audit/rules.d/audit_time_rules.rules\" when: found_paths | length == 0 - name: Declare found syscalls set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}\" - name: Declare missing syscalls set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\" - name: Replace the audit rule in {{ audit_file }} lineinfile: path: '{{ audit_file }}' regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+) line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4 backrefs: true state: present when: syscalls_found | length &gt; 0 and missing_syscalls | length &gt; 0 - name: Add the audit rule to {{ audit_file }} lineinfile: path: '{{ audit_file }}' line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=audit_time_rules create: true mode: o-rwx state: present when: syscalls_found | length == 0 - name: Declare list of syscalls set_fact: syscalls: - adjtimex syscall_grouping: - adjtimex - settimeofday - stime - name: Check existence of adjtimex in /etc/audit/audit.rules find: paths: /etc/audit contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$ patterns: audit.rules register: find_command loop: '{{ (syscall_grouping + syscalls) | unique }}' - name: Set path to /etc/audit/audit.rules set_fact: audit_file=\"/etc/audit/audit.rules\" - name: Declare found syscalls set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}\" - name: Declare missing syscalls set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\" - name: Replace the audit rule in {{ audit_file }} lineinfile: path: '{{ audit_file }}' regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+) line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4 backrefs: true state: present when: syscalls_found | length &gt; 0 and missing_syscalls | length &gt; 0 - name: Add the audit rule to {{ audit_file }} lineinfile: path: '{{ audit_file }}' line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=audit_time_rules create: true mode: o-rwx state: present when: syscalls_found | length == 0 when: - '\"audit\" in ansible_facts.packages' - audit_arch == \"b64\" tags: - CJIS-5.4.1.1 - NIST-800-171-3.1.7 - NIST-800-53-AC-6(9) - NIST-800-53-AU-12(c) - NIST-800-53-AU-2(d) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.4.2.b - audit_rules_time_adjtimex - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_time_rules",
        "rid": "audit_rules_time_clock_settime",
        "gtitle": "Records Events that Modify Date and Time Information",
        "fix_id": "audit_rules_time_clock_settime"
      },
      "id": "audit_time_rules",
      "title": [
        {
          "#text": "Record Attempts to Alter Time Through clock_settime",
          "@_lang": "en-US"
        }
      ],
      "desc": "If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:The -k option allows for the specification of a key in string form that can be used for better reporting capability through ausearch and aureport. Multiple system calls can be defined on the same line to save space if desired, but is not required. See an example of multiple combined syscalls:",
      "impact": 0.5,
      "descs": {
        "fix": "- name: Gather the package facts package_facts: manager: auto tags: - CJIS-5.4.1.1 - NIST-800-171-3.1.7 - NIST-800-53-AC-6(9) - NIST-800-53-AU-12(c) - NIST-800-53-AU-2(d) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.4.2.b - audit_rules_time_clock_settime - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy - name: Set architecture for audit tasks set_fact: audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }} when: '\"audit\" in ansible_facts.packages' tags: - CJIS-5.4.1.1 - NIST-800-171-3.1.7 - NIST-800-53-AC-6(9) - NIST-800-53-AU-12(c) - NIST-800-53-AU-2(d) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.4.2.b - audit_rules_time_clock_settime - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy - name: Perform remediation of Audit rules for clock_settime for x86 platform block: - name: Declare list of syscalls set_fact: syscalls: - clock_settime syscall_grouping: [] - name: Check existence of clock_settime in /etc/audit/rules.d/ find: paths: /etc/audit/rules.d contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F a0=0x0 (-k\\s+|-F\\s+key=)\\S+\\s*$ patterns: '*.rules' register: find_command loop: '{{ (syscall_grouping + syscalls) | unique }}' - name: Reset syscalls found per file set_fact: syscalls_per_file: {} found_paths_dict: {} - name: Declare syscalls found per file set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\" loop: '{{ find_command.results | selectattr(''matched'') | list }}' - name: Declare files where syscalls were found set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}\" - name: Count occurrences of syscalls in paths set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}\" loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}' - name: Get path with most syscalls set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}\" when: found_paths | length &gt;= 1 - name: No file with syscall found, set path to /etc/audit/rules.d/time-change.rules set_fact: audit_file=\"/etc/audit/rules.d/time-change.rules\" when: found_paths | length == 0 - name: Declare found syscalls set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}\" - name: Declare missing syscalls set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\" - name: Replace the audit rule in {{ audit_file }} lineinfile: path: '{{ audit_file }}' regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F a0=0x0 (?:-k |-F key=)\\w+) line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4 backrefs: true state: present when: syscalls_found | length &gt; 0 and missing_syscalls | length &gt; 0 - name: Add the audit rule to {{ audit_file }} lineinfile: path: '{{ audit_file }}' line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F a0=0x0 -F key=time-change create: true mode: o-rwx state: present when: syscalls_found | length == 0 - name: Declare list of syscalls set_fact: syscalls: - clock_settime syscall_grouping: [] - name: Check existence of clock_settime in /etc/audit/audit.rules find: paths: /etc/audit contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F a0=0x0 (-k\\s+|-F\\s+key=)\\S+\\s*$ patterns: audit.rules register: find_command loop: '{{ (syscall_grouping + syscalls) | unique }}' - name: Set path to /etc/audit/audit.rules set_fact: audit_file=\"/etc/audit/audit.rules\" - name: Declare found syscalls set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}\" - name: Declare missing syscalls set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\" - name: Replace the audit rule in {{ audit_file }} lineinfile: path: '{{ audit_file }}' regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F a0=0x0 (?:-k |-F key=)\\w+) line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4 backrefs: true state: present when: syscalls_found | length &gt; 0 and missing_syscalls | length &gt; 0 - name: Add the audit rule to {{ audit_file }} lineinfile: path: '{{ audit_file }}' line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F a0=0x0 -F key=time-change create: true mode: o-rwx state: present when: syscalls_found | length == 0 when: '\"audit\" in ansible_facts.packages' tags: - CJIS-5.4.1.1 - NIST-800-171-3.1.7 - NIST-800-53-AC-6(9) - NIST-800-53-AU-12(c) - NIST-800-53-AU-2(d) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.4.2.b - audit_rules_time_clock_settime - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy - name: Perform remediation of Audit rules for clock_settime for x86_64 platform block: - name: Declare list of syscalls set_fact: syscalls: - clock_settime syscall_grouping: [] - name: Check existence of clock_settime in /etc/audit/rules.d/ find: paths: /etc/audit/rules.d contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F a0=0x0 (-k\\s+|-F\\s+key=)\\S+\\s*$ patterns: '*.rules' register: find_command loop: '{{ (syscall_grouping + syscalls) | unique }}' - name: Reset syscalls found per file set_fact: syscalls_per_file: {} found_paths_dict: {} - name: Declare syscalls found per file set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\" loop: '{{ find_command.results | selectattr(''matched'') | list }}' - name: Declare files where syscalls were found set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}\" - name: Count occurrences of syscalls in paths set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}\" loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}' - name: Get path with most syscalls set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}\" when: found_paths | length &gt;= 1 - name: No file with syscall found, set path to /etc/audit/rules.d/time-change.rules set_fact: audit_file=\"/etc/audit/rules.d/time-change.rules\" when: found_paths | length == 0 - name: Declare found syscalls set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}\" - name: Declare missing syscalls set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\" - name: Replace the audit rule in {{ audit_file }} lineinfile: path: '{{ audit_file }}' regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F a0=0x0 (?:-k |-F key=)\\w+) line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4 backrefs: true state: present when: syscalls_found | length &gt; 0 and missing_syscalls | length &gt; 0 - name: Add the audit rule to {{ audit_file }} lineinfile: path: '{{ audit_file }}' line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F a0=0x0 -F key=time-change create: true mode: o-rwx state: present when: syscalls_found | length == 0 - name: Declare list of syscalls set_fact: syscalls: - clock_settime syscall_grouping: [] - name: Check existence of clock_settime in /etc/audit/audit.rules find: paths: /etc/audit contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* -F a0=0x0 (-k\\s+|-F\\s+key=)\\S+\\s*$ patterns: audit.rules register: find_command loop: '{{ (syscall_grouping + syscalls) | unique }}' - name: Set path to /etc/audit/audit.rules set_fact: audit_file=\"/etc/audit/audit.rules\" - name: Declare found syscalls set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}\" - name: Declare missing syscalls set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\" - name: Replace the audit rule in {{ audit_file }} lineinfile: path: '{{ audit_file }}' regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( -F a0=0x0 (?:-k |-F key=)\\w+) line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4 backrefs: true state: present when: syscalls_found | length &gt; 0 and missing_syscalls | length &gt; 0 - name: Add the audit rule to {{ audit_file }} lineinfile: path: '{{ audit_file }}' line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F a0=0x0 -F key=time-change create: true mode: o-rwx state: present when: syscalls_found | length == 0 when: - '\"audit\" in ansible_facts.packages' - audit_arch == \"b64\" tags: - CJIS-5.4.1.1 - NIST-800-171-3.1.7 - NIST-800-53-AC-6(9) - NIST-800-53-AU-12(c) - NIST-800-53-AU-2(d) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.4.2.b - audit_rules_time_clock_settime - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_time_rules",
        "rid": "audit_rules_time_settimeofday",
        "gtitle": "Records Events that Modify Date and Time Information",
        "fix_id": "audit_rules_time_settimeofday"
      },
      "id": "audit_time_rules",
      "title": [
        {
          "#text": "Record attempts to alter time through settimeofday",
          "@_lang": "en-US"
        }
      ],
      "desc": "If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:The -k option allows for the specification of a key in string form that can be used for better reporting capability through ausearch and aureport. Multiple system calls can be defined on the same line to save space if desired, but is not required. See an example of multiple combined syscalls:",
      "impact": 0.5,
      "descs": {
        "fix": "- name: Gather the package facts package_facts: manager: auto tags: - CJIS-5.4.1.1 - NIST-800-171-3.1.7 - NIST-800-53-AC-6(9) - NIST-800-53-AU-12(c) - NIST-800-53-AU-2(d) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.4.2.b - audit_rules_time_settimeofday - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy - name: Set architecture for audit tasks set_fact: audit_arch: b{{ ansible_architecture | regex_replace('.*(\\d\\d$)','\\1') }} when: '\"audit\" in ansible_facts.packages' tags: - CJIS-5.4.1.1 - NIST-800-171-3.1.7 - NIST-800-53-AC-6(9) - NIST-800-53-AU-12(c) - NIST-800-53-AU-2(d) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.4.2.b - audit_rules_time_settimeofday - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy - name: Perform remediation of Audit rules for settimeofday for x86 platform block: - name: Declare list of syscalls set_fact: syscalls: - settimeofday syscall_grouping: - adjtimex - settimeofday - stime - name: Check existence of settimeofday in /etc/audit/rules.d/ find: paths: /etc/audit/rules.d contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$ patterns: '*.rules' register: find_command loop: '{{ (syscall_grouping + syscalls) | unique }}' - name: Reset syscalls found per file set_fact: syscalls_per_file: {} found_paths_dict: {} - name: Declare syscalls found per file set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\" loop: '{{ find_command.results | selectattr(''matched'') | list }}' - name: Declare files where syscalls were found set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}\" - name: Count occurrences of syscalls in paths set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}\" loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}' - name: Get path with most syscalls set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}\" when: found_paths | length &gt;= 1 - name: No file with syscall found, set path to /etc/audit/rules.d/audit_time_rules.rules set_fact: audit_file=\"/etc/audit/rules.d/audit_time_rules.rules\" when: found_paths | length == 0 - name: Declare found syscalls set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}\" - name: Declare missing syscalls set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\" - name: Replace the audit rule in {{ audit_file }} lineinfile: path: '{{ audit_file }}' regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+) line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4 backrefs: true state: present when: syscalls_found | length &gt; 0 and missing_syscalls | length &gt; 0 - name: Add the audit rule to {{ audit_file }} lineinfile: path: '{{ audit_file }}' line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=audit_time_rules create: true mode: o-rwx state: present when: syscalls_found | length == 0 - name: Declare list of syscalls set_fact: syscalls: - settimeofday syscall_grouping: - adjtimex - settimeofday - stime - name: Check existence of settimeofday in /etc/audit/audit.rules find: paths: /etc/audit contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$ patterns: audit.rules register: find_command loop: '{{ (syscall_grouping + syscalls) | unique }}' - name: Set path to /etc/audit/audit.rules set_fact: audit_file=\"/etc/audit/audit.rules\" - name: Declare found syscalls set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}\" - name: Declare missing syscalls set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\" - name: Replace the audit rule in {{ audit_file }} lineinfile: path: '{{ audit_file }}' regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+) line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4 backrefs: true state: present when: syscalls_found | length &gt; 0 and missing_syscalls | length &gt; 0 - name: Add the audit rule to {{ audit_file }} lineinfile: path: '{{ audit_file }}' line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=audit_time_rules create: true mode: o-rwx state: present when: syscalls_found | length == 0 when: '\"audit\" in ansible_facts.packages' tags: - CJIS-5.4.1.1 - NIST-800-171-3.1.7 - NIST-800-53-AC-6(9) - NIST-800-53-AU-12(c) - NIST-800-53-AU-2(d) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.4.2.b - audit_rules_time_settimeofday - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy - name: Perform remediation of Audit rules for settimeofday for x86_64 platform block: - name: Declare list of syscalls set_fact: syscalls: - settimeofday syscall_grouping: - adjtimex - settimeofday - stime - name: Check existence of settimeofday in /etc/audit/rules.d/ find: paths: /etc/audit/rules.d contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$ patterns: '*.rules' register: find_command loop: '{{ (syscall_grouping + syscalls) | unique }}' - name: Reset syscalls found per file set_fact: syscalls_per_file: {} found_paths_dict: {} - name: Declare syscalls found per file set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\" loop: '{{ find_command.results | selectattr(''matched'') | list }}' - name: Declare files where syscalls were found set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}\" - name: Count occurrences of syscalls in paths set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}\" loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}' - name: Get path with most syscalls set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}\" when: found_paths | length &gt;= 1 - name: No file with syscall found, set path to /etc/audit/rules.d/audit_time_rules.rules set_fact: audit_file=\"/etc/audit/rules.d/audit_time_rules.rules\" when: found_paths | length == 0 - name: Declare found syscalls set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}\" - name: Declare missing syscalls set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\" - name: Replace the audit rule in {{ audit_file }} lineinfile: path: '{{ audit_file }}' regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+) line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4 backrefs: true state: present when: syscalls_found | length &gt; 0 and missing_syscalls | length &gt; 0 - name: Add the audit rule to {{ audit_file }} lineinfile: path: '{{ audit_file }}' line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=audit_time_rules create: true mode: o-rwx state: present when: syscalls_found | length == 0 - name: Declare list of syscalls set_fact: syscalls: - settimeofday syscall_grouping: - adjtimex - settimeofday - stime - name: Check existence of settimeofday in /etc/audit/audit.rules find: paths: /etc/audit contains: -a always,exit -F arch=b64(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$ patterns: audit.rules register: find_command loop: '{{ (syscall_grouping + syscalls) | unique }}' - name: Set path to /etc/audit/audit.rules set_fact: audit_file=\"/etc/audit/audit.rules\" - name: Declare found syscalls set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}\" - name: Declare missing syscalls set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\" - name: Replace the audit rule in {{ audit_file }} lineinfile: path: '{{ audit_file }}' regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+) line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4 backrefs: true state: present when: syscalls_found | length &gt; 0 and missing_syscalls | length &gt; 0 - name: Add the audit rule to {{ audit_file }} lineinfile: path: '{{ audit_file }}' line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=audit_time_rules create: true mode: o-rwx state: present when: syscalls_found | length == 0 when: - '\"audit\" in ansible_facts.packages' - audit_arch == \"b64\" tags: - CJIS-5.4.1.1 - NIST-800-171-3.1.7 - NIST-800-53-AC-6(9) - NIST-800-53-AU-12(c) - NIST-800-53-AU-2(d) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.4.2.b - audit_rules_time_settimeofday - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_time_rules",
        "rid": "audit_rules_time_stime",
        "gtitle": "Records Events that Modify Date and Time Information",
        "fix_id": "audit_rules_time_stime"
      },
      "id": "audit_time_rules",
      "title": [
        {
          "#text": "Record Attempts to Alter Time Through stime",
          "@_lang": "en-US"
        }
      ],
      "desc": "If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directoryfor both 32 bit and 64 bit systems:Since the 64 bit version of the \"stime\" system call is not defined in the audit lookup table, the corresponding \"-F arch=b64\" form of this rule is not expected to be defined on 64 bit systems (the aforementioned \"-F arch=b32\" stime rule form itself is sufficient for both 32 bit and 64 bit systems). If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile for both 32 bit and 64 bit systems:Since the 64 bit version of the \"stime\" system call is not defined in the audit lookup table, the corresponding \"-F arch=b64\" form of this rule is not expected to be defined on 64 bit systems (the aforementioned \"-F arch=b32\" stime rule form itself is sufficient for both 32 bit and 64 bit systems). The -k option allows for the specification of a key in string form that can be used for better reporting capability through ausearch and aureport. Multiple system calls can be defined on the same line to save space if desired, but is not required. See an example of multiple combined system calls:",
      "impact": 0.5,
      "descs": {
        "fix": "- name: Gather the package facts package_facts: manager: auto tags: - CJIS-5.4.1.1 - NIST-800-171-3.1.7 - NIST-800-53-AC-6(9) - NIST-800-53-AU-12(c) - NIST-800-53-AU-2(d) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.4.2.b - audit_rules_time_stime - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy - name: Perform remediation of Audit rules for stime syscall for x86 platform block: - name: Declare list of syscalls set_fact: syscalls: - stime syscall_grouping: - adjtimex - settimeofday - stime - name: Check existence of stime in /etc/audit/rules.d/ find: paths: /etc/audit/rules.d contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$ patterns: '*.rules' register: find_command loop: '{{ (syscall_grouping + syscalls) | unique }}' - name: Reset syscalls found per file set_fact: syscalls_per_file: {} found_paths_dict: {} - name: Declare syscalls found per file set_fact: syscalls_per_file=\"{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}\" loop: '{{ find_command.results | selectattr(''matched'') | list }}' - name: Declare files where syscalls were found set_fact: found_paths=\"{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}\" - name: Count occurrences of syscalls in paths set_fact: found_paths_dict=\"{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}\" loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}' - name: Get path with most syscalls set_fact: audit_file=\"{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}\" when: found_paths | length &gt;= 1 - name: No file with syscall found, set path to /etc/audit/rules.d/audit_time_rules.rules set_fact: audit_file=\"/etc/audit/rules.d/audit_time_rules.rules\" when: found_paths | length == 0 - name: Declare found syscalls set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}\" - name: Declare missing syscalls set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\" - name: Replace the audit rule in {{ audit_file }} lineinfile: path: '{{ audit_file }}' regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+) line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4 backrefs: true state: present when: syscalls_found | length &gt; 0 and missing_syscalls | length &gt; 0 - name: Add the audit rule to {{ audit_file }} lineinfile: path: '{{ audit_file }}' line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=audit_time_rules create: true mode: o-rwx state: present when: syscalls_found | length == 0 - name: Declare list of syscalls set_fact: syscalls: - stime syscall_grouping: - adjtimex - settimeofday - stime - name: Check existence of stime in /etc/audit/audit.rules find: paths: /etc/audit contains: -a always,exit -F arch=b32(( -S |,)\\w+)*(( -S |,){{ item }})+(( -S |,)\\w+)* (-k\\s+|-F\\s+key=)\\S+\\s*$ patterns: audit.rules register: find_command loop: '{{ (syscall_grouping + syscalls) | unique }}' - name: Set path to /etc/audit/audit.rules set_fact: audit_file=\"/etc/audit/audit.rules\" - name: Declare found syscalls set_fact: syscalls_found=\"{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}\" - name: Declare missing syscalls set_fact: missing_syscalls=\"{{ syscalls | difference(syscalls_found) }}\" - name: Replace the audit rule in {{ audit_file }} lineinfile: path: '{{ audit_file }}' regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join(\"|\") }}))\\b)((?:( -S |,)\\w+)+)( (?:-k |-F key=)\\w+) line: \\1\\2\\3{{ missing_syscalls | join(\"\\3\") }}\\4 backrefs: true state: present when: syscalls_found | length &gt; 0 and missing_syscalls | length &gt; 0 - name: Add the audit rule to {{ audit_file }} lineinfile: path: '{{ audit_file }}' line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=audit_time_rules create: true mode: o-rwx state: present when: syscalls_found | length == 0 when: '\"audit\" in ansible_facts.packages' tags: - CJIS-5.4.1.1 - NIST-800-171-3.1.7 - NIST-800-53-AC-6(9) - NIST-800-53-AU-12(c) - NIST-800-53-AU-2(d) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.4.2.b - audit_rules_time_stime - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "audit_time_rules",
        "rid": "audit_rules_time_watch_localtime",
        "gtitle": "Records Events that Modify Date and Time Information",
        "fix_id": "audit_rules_time_watch_localtime"
      },
      "id": "audit_time_rules",
      "title": [
        {
          "#text": "Record Attempts to Alter the localtime File",
          "@_lang": "en-US"
        }
      ],
      "desc": "If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:The -k option allows for the specification of a key in string form that can be used for better reporting capability through ausearch and aureport and should always be used.",
      "impact": 0.5,
      "descs": {
        "fix": "- name: Gather the package facts package_facts: manager: auto tags: - CJIS-5.4.1.1 - NIST-800-171-3.1.7 - NIST-800-53-AC-6(9) - NIST-800-53-AU-12(c) - NIST-800-53-AU-2(d) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.4.2.b - audit_rules_time_watch_localtime - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy - name: Check if watch rule for /etc/localtime already exists in /etc/audit/rules.d/ find: paths: /etc/audit/rules.d contains: ^\\s*-w\\s+/etc/localtime\\s+-p\\s+wa(\\s|$)+ patterns: '*.rules' register: find_existing_watch_rules_d when: '\"audit\" in ansible_facts.packages' tags: - CJIS-5.4.1.1 - NIST-800-171-3.1.7 - NIST-800-53-AC-6(9) - NIST-800-53-AU-12(c) - NIST-800-53-AU-2(d) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.4.2.b - audit_rules_time_watch_localtime - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy - name: Search /etc/audit/rules.d for other rules with specified key audit_time_rules find: paths: /etc/audit/rules.d contains: ^.*(?:-F key=|-k\\s+)audit_time_rules$ patterns: '*.rules' register: find_watch_key when: - '\"audit\" in ansible_facts.packages' - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0 tags: - CJIS-5.4.1.1 - NIST-800-171-3.1.7 - NIST-800-53-AC-6(9) - NIST-800-53-AU-12(c) - NIST-800-53-AU-2(d) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.4.2.b - audit_rules_time_watch_localtime - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy - name: Use /etc/audit/rules.d/audit_time_rules.rules as the recipient for the rule set_fact: all_files: - /etc/audit/rules.d/audit_time_rules.rules when: - '\"audit\" in ansible_facts.packages' - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0 tags: - CJIS-5.4.1.1 - NIST-800-171-3.1.7 - NIST-800-53-AC-6(9) - NIST-800-53-AU-12(c) - NIST-800-53-AU-2(d) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.4.2.b - audit_rules_time_watch_localtime - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy - name: Use matched file as the recipient for the rule set_fact: all_files: - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}' when: - '\"audit\" in ansible_facts.packages' - find_watch_key.matched is defined and find_watch_key.matched &gt; 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0 tags: - CJIS-5.4.1.1 - NIST-800-171-3.1.7 - NIST-800-53-AC-6(9) - NIST-800-53-AU-12(c) - NIST-800-53-AU-2(d) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.4.2.b - audit_rules_time_watch_localtime - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy - name: Add watch rule for /etc/localtime in /etc/audit/rules.d/ lineinfile: path: '{{ all_files[0] }}' line: -w /etc/localtime -p wa -k audit_time_rules create: true mode: '0640' when: - '\"audit\" in ansible_facts.packages' - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0 tags: - CJIS-5.4.1.1 - NIST-800-171-3.1.7 - NIST-800-53-AC-6(9) - NIST-800-53-AU-12(c) - NIST-800-53-AU-2(d) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.4.2.b - audit_rules_time_watch_localtime - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy - name: Check if watch rule for /etc/localtime already exists in /etc/audit/audit.rules find: paths: /etc/audit/ contains: ^\\s*-w\\s+/etc/localtime\\s+-p\\s+wa(\\s|$)+ patterns: audit.rules register: find_existing_watch_audit_rules when: '\"audit\" in ansible_facts.packages' tags: - CJIS-5.4.1.1 - NIST-800-171-3.1.7 - NIST-800-53-AC-6(9) - NIST-800-53-AU-12(c) - NIST-800-53-AU-2(d) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.4.2.b - audit_rules_time_watch_localtime - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy - name: Add watch rule for /etc/localtime in /etc/audit/audit.rules lineinfile: line: -w /etc/localtime -p wa -k audit_time_rules state: present dest: /etc/audit/audit.rules create: true mode: '0640' when: - '\"audit\" in ansible_facts.packages' - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched == 0 tags: - CJIS-5.4.1.1 - NIST-800-171-3.1.7 - NIST-800-53-AC-6(9) - NIST-800-53-AU-12(c) - NIST-800-53-AU-2(d) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.4.2.b - audit_rules_time_watch_localtime - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "auditd_configure_rules",
        "rid": "audit_rules_immutable",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing",
        "fix_id": "audit_rules_immutable"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Make the auditd Configuration Immutable",
          "@_lang": "en-US"
        }
      ],
      "desc": "If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directoryin order to make the auditd configuration immutable:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile in order to make the auditd configuration immutable:With this setting, a reboot will be required to change any audit rules.",
      "impact": 0.5,
      "descs": {
        "fix": "- name: Gather the package facts package_facts: manager: auto tags: - CJIS-5.4.1.1 - NIST-800-171-3.3.1 - NIST-800-171-3.4.3 - NIST-800-53-AC-6(9) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.5.2 - audit_rules_immutable - low_complexity - low_disruption - medium_severity - reboot_required - restrict_strategy - name: Collect all files from /etc/audit/rules.d with .rules extension find: paths: /etc/audit/rules.d/ patterns: '*.rules' register: find_rules_d when: '\"audit\" in ansible_facts.packages' tags: - CJIS-5.4.1.1 - NIST-800-171-3.3.1 - NIST-800-171-3.4.3 - NIST-800-53-AC-6(9) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.5.2 - audit_rules_immutable - low_complexity - low_disruption - medium_severity - reboot_required - restrict_strategy - name: Remove the -e option from all Audit config files lineinfile: path: '{{ item }}' regexp: ^\\s*(?:-e)\\s+.*$ state: absent loop: '{{ find_rules_d.files | map(attribute=''path'') | list + [''/etc/audit/audit.rules''] }}' when: '\"audit\" in ansible_facts.packages' tags: - CJIS-5.4.1.1 - NIST-800-171-3.3.1 - NIST-800-171-3.4.3 - NIST-800-53-AC-6(9) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.5.2 - audit_rules_immutable - low_complexity - low_disruption - medium_severity - reboot_required - restrict_strategy - name: Add Audit -e option into /etc/audit/rules.d/immutable.rules and /etc/audit/audit.rules lineinfile: path: '{{ item }}' create: true line: -e 2 mode: o-rwx loop: - /etc/audit/audit.rules - /etc/audit/rules.d/immutable.rules when: '\"audit\" in ansible_facts.packages' tags: - CJIS-5.4.1.1 - NIST-800-171-3.3.1 - NIST-800-171-3.4.3 - NIST-800-53-AC-6(9) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.5.2 - audit_rules_immutable - low_complexity - low_disruption - medium_severity - reboot_required - restrict_strategy"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "auditd_configure_rules",
        "rid": "audit_rules_mac_modification",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Record Events that Modify the System's Mandatory Access Controls",
          "@_lang": "en-US"
        }
      ],
      "desc": "If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "auditd_configure_rules",
        "rid": "audit_rules_media_export",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on Exporting to Media (successful)",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect media exportation events for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory, setting ARCH to either b32 or b64 as appropriate for your system:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile, setting ARCH to either b32 or b64 as appropriate for your system:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "auditd_configure_rules",
        "rid": "audit_rules_networkconfig_modification",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Record Events that Modify the System's Network Environment",
          "@_lang": "en-US"
        }
      ],
      "desc": "If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory, setting ARCH to either b32 or b64 as appropriate for your system:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile, setting ARCH to either b32 or b64 as appropriate for your system:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "auditd_configure_rules",
        "rid": "audit_rules_session_events",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Record Attempts to Alter Process and Session Initiation Information",
          "@_lang": "en-US"
        }
      ],
      "desc": "The audit system already collects process information for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directoryin order to watch for attempted manual edits of files involved in storing such process information:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile in order to watch for attempted manual edits of files involved in storing such process information:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "auditd_configure_rules",
        "rid": "audit_rules_session_events_btmp",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Record Attempts to Alter Process and Session Initiation Information btmp",
          "@_lang": "en-US"
        }
      ],
      "desc": "The audit system already collects process information for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directoryin order to watch for attempted manual edits of files involved in storing such process information:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile in order to watch for attempted manual edits of files involved in storing such process information:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "auditd_configure_rules",
        "rid": "audit_rules_session_events_utmp",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Record Attempts to Alter Process and Session Initiation Information utmp",
          "@_lang": "en-US"
        }
      ],
      "desc": "The audit system already collects process information for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directoryin order to watch for attempted manual edits of files involved in storing such process information:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile in order to watch for attempted manual edits of files involved in storing such process information:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "auditd_configure_rules",
        "rid": "audit_rules_session_events_wtmp",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Record Attempts to Alter Process and Session Initiation Information wtmp",
          "@_lang": "en-US"
        }
      ],
      "desc": "The audit system already collects process information for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directoryin order to watch for attempted manual edits of files involved in storing such process information:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile in order to watch for attempted manual edits of files involved in storing such process information:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "auditd_configure_rules",
        "rid": "audit_rules_suid_privilege_function",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Record Events When Privileged Executables Are Run",
          "@_lang": "en-US"
        }
      ],
      "desc": "Verify the system generates an audit record when privileged functions are executed.If both the \"b32\" and \"b64\" audit rules for \"SUID\" files are not defined, this is a finding. If both the \"b32\" and \"b64\" audit rules for \"SGID\" files are not defined, this is a finding.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "auditd_configure_rules",
        "rid": "audit_rules_sysadmin_actions",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing",
        "fix_id": "audit_rules_sysadmin_actions"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Ensure auditd Collects System Administrator Actions",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect administrator actions for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:",
      "impact": 0.5,
      "descs": {
        "fix": "- name: Gather the package facts package_facts: manager: auto tags: - CJIS-5.4.1.1 - NIST-800-171-3.1.7 - NIST-800-53-AC-2(7)(b) - NIST-800-53-AC-6(9) - NIST-800-53-AU-12(c) - NIST-800-53-AU-2(d) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.2.2 - PCI-DSS-Req-10.2.5.b - audit_rules_sysadmin_actions - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy - name: Search /etc/audit/rules.d for audit rule entries for sysadmin actions find: paths: /etc/audit/rules.d recurse: false contains: ^.*/etc/sudoers.*$ patterns: '*.rules' register: find_audit_sysadmin_actions when: '\"audit\" in ansible_facts.packages' tags: - CJIS-5.4.1.1 - NIST-800-171-3.1.7 - NIST-800-53-AC-2(7)(b) - NIST-800-53-AC-6(9) - NIST-800-53-AU-12(c) - NIST-800-53-AU-2(d) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.2.2 - PCI-DSS-Req-10.2.5.b - audit_rules_sysadmin_actions - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy - name: Use /etc/audit/rules.d/actions.rules as the recipient for the rule set_fact: all_sysadmin_actions_files: - /etc/audit/rules.d/actions.rules when: - '\"audit\" in ansible_facts.packages' - find_audit_sysadmin_actions.matched is defined and find_audit_sysadmin_actions.matched == 0 tags: - CJIS-5.4.1.1 - NIST-800-171-3.1.7 - NIST-800-53-AC-2(7)(b) - NIST-800-53-AC-6(9) - NIST-800-53-AU-12(c) - NIST-800-53-AU-2(d) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.2.2 - PCI-DSS-Req-10.2.5.b - audit_rules_sysadmin_actions - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy - name: Use matched file as the recipient for the rule set_fact: all_sysadmin_actions_files: - '{{ find_audit_sysadmin_actions.files | map(attribute=''path'') | list | first }}' when: - '\"audit\" in ansible_facts.packages' - find_audit_sysadmin_actions.matched is defined and find_audit_sysadmin_actions.matched &gt; 0 tags: - CJIS-5.4.1.1 - NIST-800-171-3.1.7 - NIST-800-53-AC-2(7)(b) - NIST-800-53-AC-6(9) - NIST-800-53-AU-12(c) - NIST-800-53-AU-2(d) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.2.2 - PCI-DSS-Req-10.2.5.b - audit_rules_sysadmin_actions - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy - name: Inserts/replaces audit rule for /etc/sudoers rule in rules.d lineinfile: path: '{{ all_sysadmin_actions_files[0] }}' line: -w /etc/sudoers -p wa -k actions create: true when: '\"audit\" in ansible_facts.packages' tags: - CJIS-5.4.1.1 - NIST-800-171-3.1.7 - NIST-800-53-AC-2(7)(b) - NIST-800-53-AC-6(9) - NIST-800-53-AU-12(c) - NIST-800-53-AU-2(d) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.2.2 - PCI-DSS-Req-10.2.5.b - audit_rules_sysadmin_actions - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy - name: Inserts/replaces audit rule for /etc/sudoers.d rule in rules.d lineinfile: path: '{{ all_sysadmin_actions_files[0] }}' line: -w /etc/sudoers.d/ -p wa -k actions create: true when: '\"audit\" in ansible_facts.packages' tags: - CJIS-5.4.1.1 - NIST-800-171-3.1.7 - NIST-800-53-AC-2(7)(b) - NIST-800-53-AC-6(9) - NIST-800-53-AU-12(c) - NIST-800-53-AU-2(d) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.2.2 - PCI-DSS-Req-10.2.5.b - audit_rules_sysadmin_actions - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy - name: Inserts/replaces audit rule for /etc/sudoers in audit.rules lineinfile: path: /etc/audit/audit.rules line: -w /etc/sudoers -p wa -k actions create: true when: '\"audit\" in ansible_facts.packages' tags: - CJIS-5.4.1.1 - NIST-800-171-3.1.7 - NIST-800-53-AC-2(7)(b) - NIST-800-53-AC-6(9) - NIST-800-53-AU-12(c) - NIST-800-53-AU-2(d) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.2.2 - PCI-DSS-Req-10.2.5.b - audit_rules_sysadmin_actions - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy - name: Inserts/replaces audit rule for /etc/sudoers.d in audit.rules lineinfile: path: /etc/audit/audit.rules line: -w /etc/sudoers.d/ -p wa -k actions create: true when: '\"audit\" in ansible_facts.packages' tags: - CJIS-5.4.1.1 - NIST-800-171-3.1.7 - NIST-800-53-AC-2(7)(b) - NIST-800-53-AC-6(9) - NIST-800-53-AU-12(c) - NIST-800-53-AU-2(d) - NIST-800-53-CM-6(a) - PCI-DSS-Req-10.2.2 - PCI-DSS-Req-10.2.5.b - audit_rules_sysadmin_actions - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "auditd_configure_rules",
        "rid": "audit_rules_usergroup_modification",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Record Events that Modify User/Group Information",
          "@_lang": "en-US"
        }
      ],
      "desc": "If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory, in order to capture events that modify account changes:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile, in order to capture events that modify account changes:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "auditd_configure_rules",
        "rid": "audit_rules_usergroup_modification_group",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Record Events that Modify User/Group Information - /etc/group",
          "@_lang": "en-US"
        }
      ],
      "desc": "If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory, in order to capture events that modify account changes:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile, in order to capture events that modify account changes:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "auditd_configure_rules",
        "rid": "audit_rules_usergroup_modification_gshadow",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Record Events that Modify User/Group Information - /etc/gshadow",
          "@_lang": "en-US"
        }
      ],
      "desc": "If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory, in order to capture events that modify account changes:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile, in order to capture events that modify account changes:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "auditd_configure_rules",
        "rid": "audit_rules_usergroup_modification_opasswd",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Record Events that Modify User/Group Information - /etc/security/opasswd",
          "@_lang": "en-US"
        }
      ],
      "desc": "If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory, in order to capture events that modify account changes:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile, in order to capture events that modify account changes:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "auditd_configure_rules",
        "rid": "audit_rules_usergroup_modification_passwd",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Record Events that Modify User/Group Information - /etc/passwd",
          "@_lang": "en-US"
        }
      ],
      "desc": "If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory, in order to capture events that modify account changes:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile, in order to capture events that modify account changes:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "auditd_configure_rules",
        "rid": "audit_rules_usergroup_modification_shadow",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Record Events that Modify User/Group Information - /etc/shadow",
          "@_lang": "en-US"
        }
      ],
      "desc": "If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory, in order to capture events that modify account changes:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile, in order to capture events that modify account changes:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "auditd_configure_rules",
        "rid": "directory_access_var_log_audit",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing",
        "fix_id": "directory_access_var_log_audit"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Record Access Events to Audit Log Directory",
          "@_lang": "en-US"
        }
      ],
      "desc": "The audit system should collect access events to read audit log directory. The following audit rule will assure that access to audit log directory are collected.If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the rule to a file with suffixin the directory. If thedaemon is configured to use theutility to read audit rules during daemon startup, add the rule tofile.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'audit' 2&gt;/dev/null | grep -q installed &amp;&amp; { [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; }; then ACTION_ARCH_FILTERS=\"-a always,exit\" OTHER_FILTERS=\"-F dir=/var/log/audit/ -F perm=r\" AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"access-audit-trail\" SYSCALL_GROUPING=\"\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules' # Load macro arguments into arrays read -a syscall_a &lt;&lt;&lt; $SYSCALL read -a syscall_grouping &lt;&lt;&lt; $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspected for presence and correctness # of a particular audit rule. The scheme is as follows: # # ----------------------------------------------------------------------------------------- # Tool used to load audit rules | Rule already defined | Audit rules file to inspect | # ----------------------------------------------------------------------------------------- # auditctl | Doesn't matter | /etc/audit/audit.rules | # ----------------------------------------------------------------------------------------- # augenrules | Yes | /etc/audit/rules.d/*.rules | # augenrules | No | /etc/audit/rules.d/$key.rules | # ----------------------------------------------------------------------------------------- # files_to_inspect=() # If audit tool is 'augenrules', then check if the audit rule is defined # If rule is defined, add '/etc/audit/rules.d/*.rules' to the list for inspection # If rule isn't defined yet, add '/etc/audit/rules.d/$key.rules' to the list for inspection default_file=\"/etc/audit/rules.d/$KEY.rules\" # As other_filters may include paths, lets use a different delimiter for it # The \"F\" script expression tells sed to print the filenames where the expressions matched readarray -t files_to_inspect &lt; &lt;(sed -s -n -e \"/$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" -e \"F\" /etc/audit/rules.d/*.rules) # Case when particular rule isn't defined in /etc/audit/rules.d/*.rules yet if [ ${#files_to_inspect[@]} -eq \"0\" ] then file_to_inspect=\"/etc/audit/rules.d/$KEY.rules\" files_to_inspect=(\"$file_to_inspect\") if [ ! -e \"$file_to_inspect\" ] then touch \"$file_to_inspect\" chmod 0640 \"$file_to_inspect\" fi fi # Indicator that we want to append $full_rule into $audit_file or edit a rule in it append_expected_rule=0 # After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead skip=1 for audit_file in \"${files_to_inspect[@]}\" do # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern, # i.e, collect rules that match: # * the action, list and arch, (2-nd argument) # * the other filters, (3-rd argument) # * the auid filters, (4-rd argument) readarray -t similar_rules &lt; &lt;(sed -e \"/$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\") candidate_rules=() # Filter out rules that have more fields then required. This will remove rules more specific than the required scope for s_rule in \"${similar_rules[@]}\" do # Strip all the options and fields we know of, # than check if there was any field left over extra_fields=$(sed -E -e \"s/$ACTION_ARCH_FILTERS//\" -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"&lt;&lt;&lt; \"$s_rule\") grep -q -- \"-F\" &lt;&lt;&lt; \"$extra_fields\" if [ $? -ne 0 ] then candidate_rules+=(\"$s_rule\") fi done if [[ ${#syscall_a[@]} -ge 1 ]] then # Check if the syscall we want is present in any of the similar existing rules for rule in \"${candidate_rules[@]}\" do rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs) all_syscalls_found=0 for syscall in \"${syscall_a[@]}\" do grep -q -- \"\\b${syscall}\\b\" &lt;&lt;&lt; \"$rule_syscalls\" if [ $? -eq 1 ] then # A syscall was not found in the candidate rule all_syscalls_found=1 fi done if [[ $all_syscalls_found -eq 0 ]] then # We found a rule with all the syscall(s) we want; skip rest of macro skip=0 break fi # Check if this rule can be grouped with our target syscall and keep track of it for syscall_g in \"${syscall_grouping[@]}\" do if grep -q -- \"\\b${syscall_g}\\b\" &lt;&lt;&lt; \"$rule_syscalls\" then file_to_edit=${audit_file} rule_to_edit=${rule} rule_syscalls_to_edit=${rule_syscalls} fi done done else # If there is any candidate rule, it is compliant; skip rest of macro if [[ $candidate_rules ]] then skip=0 fi fi if [ \"$skip\" -eq 0 ]; then break fi done if [ \"$skip\" -ne 0 ]; then # We checked all rules that matched the expected resemblance pattern (action, arch &amp; auid) # At this point we know if we need to either append the $full_rule or group # the syscall together with an exsiting rule # Append the full_rule if it cannot be grouped to any other rule if [ -z ${rule_to_edit+x} ] then # Build full_rule while avoid adding double spaces when other_filters is empty if [[ ${syscall_a} ]] then syscall_string=\"\" for syscall in \"${syscall_a[@]}\" do syscall_string+=\" -S $syscall\" done fi other_string=$([[ $OTHER_FILTERS ]] &amp;&amp; echo \" $OTHER_FILTERS\") auid_string=$([[ $AUID_FILTERS ]] &amp;&amp; echo \" $AUID_FILTERS\") full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" echo \"$full_rule\" &gt;&gt; \"$default_file\" chmod o-rwx ${default_file} else # Check if the syscalls are declared as a comma separated list or # as multiple -S parameters if grep -q -- \",\" &lt;&lt;&lt; \"${rule_syscalls_to_edit}\" then delimiter=\",\" else delimiter=\" -S \" fi new_grouped_syscalls=\"${rule_syscalls_to_edit}\" for syscall in \"${syscall_a[@]}\" do grep -q -- \"\\b${syscall}\\b\" &lt;&lt;&lt; \"${rule_syscalls_to_edit}\" if [ $? -eq 1 ] then # A syscall was not found in the candidate rule new_grouped_syscalls+=\"${delimiter}${syscall}\" fi done # Group the syscall in the rule sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\" fi fi # Load macro arguments into arrays read -a syscall_a &lt;&lt;&lt; $SYSCALL read -a syscall_grouping &lt;&lt;&lt; $SYSCALL_GROUPING # Create a list of audit *.rules files that should be inspected for presence and correctness # of a particular audit rule. The scheme is as follows: # # ----------------------------------------------------------------------------------------- # Tool used to load audit rules | Rule already defined | Audit rules file to inspect | # ----------------------------------------------------------------------------------------- # auditctl | Doesn't matter | /etc/audit/audit.rules | # ----------------------------------------------------------------------------------------- # augenrules | Yes | /etc/audit/rules.d/*.rules | # augenrules | No | /etc/audit/rules.d/$key.rules | # ----------------------------------------------------------------------------------------- # files_to_inspect=() # If audit tool is 'auditctl', then add '/etc/audit/audit.rules' # file to the list of files to be inspected default_file=\"/etc/audit/audit.rules\" files_to_inspect+=('/etc/audit/audit.rules' ) # Indicator that we want to append $full_rule into $audit_file or edit a rule in it append_expected_rule=0 # After converting to jinja, we cannot return; therefore we skip the rest of the macro if needed instead skip=1 for audit_file in \"${files_to_inspect[@]}\" do # Filter existing $audit_file rules' definitions to select those that satisfy the rule pattern, # i.e, collect rules that match: # * the action, list and arch, (2-nd argument) # * the other filters, (3-rd argument) # * the auid filters, (4-rd argument) readarray -t similar_rules &lt; &lt;(sed -e \"/$ACTION_ARCH_FILTERS/!d\" -e \"\\#$OTHER_FILTERS#!d\" -e \"/$AUID_FILTERS/!d\" \"$audit_file\") candidate_rules=() # Filter out rules that have more fields then required. This will remove rules more specific than the required scope for s_rule in \"${similar_rules[@]}\" do # Strip all the options and fields we know of, # than check if there was any field left over extra_fields=$(sed -E -e \"s/$ACTION_ARCH_FILTERS//\" -e \"s#$OTHER_FILTERS##\" -e \"s/$AUID_FILTERS//\" -e \"s/((:?-S [[:alnum:],]+)+)//g\" -e \"s/-F key=\\w+|-k \\w+//\"&lt;&lt;&lt; \"$s_rule\") grep -q -- \"-F\" &lt;&lt;&lt; \"$extra_fields\" if [ $? -ne 0 ] then candidate_rules+=(\"$s_rule\") fi done if [[ ${#syscall_a[@]} -ge 1 ]] then # Check if the syscall we want is present in any of the similar existing rules for rule in \"${candidate_rules[@]}\" do rule_syscalls=$(echo \"$rule\" | grep -o -P '(-S [\\w,]+)+' | xargs) all_syscalls_found=0 for syscall in \"${syscall_a[@]}\" do grep -q -- \"\\b${syscall}\\b\" &lt;&lt;&lt; \"$rule_syscalls\" if [ $? -eq 1 ] then # A syscall was not found in the candidate rule all_syscalls_found=1 fi done if [[ $all_syscalls_found -eq 0 ]] then # We found a rule with all the syscall(s) we want; skip rest of macro skip=0 break fi # Check if this rule can be grouped with our target syscall and keep track of it for syscall_g in \"${syscall_grouping[@]}\" do if grep -q -- \"\\b${syscall_g}\\b\" &lt;&lt;&lt; \"$rule_syscalls\" then file_to_edit=${audit_file} rule_to_edit=${rule} rule_syscalls_to_edit=${rule_syscalls} fi done done else # If there is any candidate rule, it is compliant; skip rest of macro if [[ $candidate_rules ]] then skip=0 fi fi if [ \"$skip\" -eq 0 ]; then break fi done if [ \"$skip\" -ne 0 ]; then # We checked all rules that matched the expected resemblance pattern (action, arch &amp; auid) # At this point we know if we need to either append the $full_rule or group # the syscall together with an exsiting rule # Append the full_rule if it cannot be grouped to any other rule if [ -z ${rule_to_edit+x} ] then # Build full_rule while avoid adding double spaces when other_filters is empty if [[ ${syscall_a} ]] then syscall_string=\"\" for syscall in \"${syscall_a[@]}\" do syscall_string+=\" -S $syscall\" done fi other_string=$([[ $OTHER_FILTERS ]] &amp;&amp; echo \" $OTHER_FILTERS\") auid_string=$([[ $AUID_FILTERS ]] &amp;&amp; echo \" $AUID_FILTERS\") full_rule=\"$ACTION_ARCH_FILTERS${syscall_string}${other_string}${auid_string} -F key=$KEY\" echo \"$full_rule\" &gt;&gt; \"$default_file\" chmod o-rwx ${default_file} else # Check if the syscalls are declared as a comma separated list or # as multiple -S parameters if grep -q -- \",\" &lt;&lt;&lt; \"${rule_syscalls_to_edit}\" then delimiter=\",\" else delimiter=\" -S \" fi new_grouped_syscalls=\"${rule_syscalls_to_edit}\" for syscall in \"${syscall_a[@]}\" do grep -q -- \"\\b${syscall}\\b\" &lt;&lt;&lt; \"${rule_syscalls_to_edit}\" if [ $? -eq 1 ] then # A syscall was not found in the candidate rule new_grouped_syscalls+=\"${delimiter}${syscall}\" fi done # Group the syscall in the rule sed -i -e \"\\#${rule_to_edit}#s#${rule_syscalls_to_edit}#${new_grouped_syscalls}#\" \"$file_to_edit\" fi fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "auditd_configure_rules",
        "rid": "directory_permissions_var_log_audit",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "System Audit Logs Must Have Mode 0750 or Less Permissive",
          "@_lang": "en-US"
        }
      ],
      "desc": "Ifinis set to a group other than thegroup account, change the mode of the audit log files with the following command:Otherwise, change the mode of the audit log files with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "auditd_configure_rules",
        "rid": "file_ownership_var_log_audit",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing",
        "fix_id": "file_ownership_var_log_audit"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "System Audit Logs Must Be Owned By Root",
          "@_lang": "en-US"
        }
      ],
      "desc": "All audit logs must be owned by root user and group. By default, the path for audit log is. To properly set the owner of, run the command:To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'audit' 2&gt;/dev/null | grep -q installed; then if LC_ALL=C grep -m 1 -q ^log_group /etc/audit/auditd.conf; then GROUP=$(awk -F \"=\" '/log_group/ {print $2}' /etc/audit/auditd.conf | tr -d ' ') if ! [ \"${GROUP}\" == 'root' ] ; then chown root.${GROUP} /var/log/audit chown root.${GROUP} /var/log/audit/audit.log* else chown root.root /var/log/audit chown root.root /var/log/audit/audit.log* fi else chown root.root /var/log/audit chown root.root /var/log/audit/audit.log* fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "auditing",
        "rid": "package_audit-audispd-plugins_installed",
        "gtitle": "System Accounting with auditd",
        "fix_id": "package_audit-audispd-plugins_installed"
      },
      "id": "auditing",
      "title": [
        {
          "#text": "Ensure the default plugins for the audit dispatcher are Installed",
          "@_lang": "en-US"
        }
      ],
      "desc": "The audit-audispd-plugins package should be installed.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"audit-audispd-plugins\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "auditing",
        "rid": "package_audit_installed",
        "gtitle": "System Accounting with auditd",
        "fix_id": "package_audit_installed"
      },
      "id": "auditing",
      "title": [
        {
          "#text": "Ensure the audit Subsystem is Installed",
          "@_lang": "en-US"
        }
      ],
      "desc": "The audit package should be installed.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"auditd\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "auditing",
        "rid": "service_auditd_enabled",
        "gtitle": "System Accounting with auditd",
        "fix_id": "service_auditd_enabled"
      },
      "id": "auditing",
      "title": [
        {
          "#text": "Enable auditd Service",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice is an essential userspace component of the Linux Auditing System, as it is responsible for writing audit records to disk. Theservice can be enabled with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { dpkg-query --show --showformat='${db:Status-Status} ' 'audit' 2&gt;/dev/null | grep -q installed; }; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" unmask 'auditd.service' \"$SYSTEMCTL_EXEC\" start 'auditd.service' \"$SYSTEMCTL_EXEC\" enable 'auditd.service' else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "auditing",
        "rid": "grub2_audit_argument",
        "gtitle": "System Accounting with auditd",
        "fix_id": "grub2_audit_argument"
      },
      "id": "auditing",
      "title": [
        {
          "#text": "Enable Auditing for Processes Which Start Prior to the Audit Daemon",
          "@_lang": "en-US"
        }
      ],
      "desc": "To ensure all processes can be audited, even those which start prior to the audit daemon, add the argumentto the default GRUB 2 command line for the Linux operating system in, in the manner below:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { dpkg-query --show --showformat='${db:Status-Status} ' 'grub2-common' 2&gt;/dev/null | grep -q installed; }; then # Correct the form of default kernel command line in GRUB if grep -q '^GRUB_CMDLINE_LINUX=.*audit=.*\"' '/etc/default/grub' ; then  # modify the GRUB command-line if an audit= arg already exists  sed -i 's/\\(^GRUB_CMDLINE_LINUX=\".*\\)audit=[^[:space:]]*\\(.*\"\\)/\\1 audit=1 \\2/' '/etc/default/grub' else  # no audit=arg is present, append it  sed -i 's/\\(^GRUB_CMDLINE_LINUX=\".*\\)\"/\\1 audit=1\"/' '/etc/default/grub' fi update-grub else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "auditing",
        "rid": "grub2_audit_backlog_limit_argument",
        "gtitle": "System Accounting with auditd",
        "fix_id": "grub2_audit_backlog_limit_argument"
      },
      "id": "auditing",
      "title": [
        {
          "#text": "Extend Audit Backlog Limit for the Audit Daemon",
          "@_lang": "en-US"
        }
      ],
      "desc": "To improve the kernel capacity to queue all log events, even those which occurred prior to the audit daemon, add the argumentto the default GRUB 2 command line for the Linux operating system in, in the manner below:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { dpkg-query --show --showformat='${db:Status-Status} ' 'grub2-common' 2&gt;/dev/null | grep -q installed; }; then # Correct the form of default kernel command line in GRUB if grep -q '^GRUB_CMDLINE_LINUX=.*audit_backlog_limit=.*\"' '/etc/default/grub' ; then  # modify the GRUB command-line if an audit_backlog_limit= arg already exists  sed -i 's/\\(^GRUB_CMDLINE_LINUX=\".*\\)audit_backlog_limit=[^[:space:]]*\\(.*\"\\)/\\1 audit_backlog_limit=8192 \\2/' '/etc/default/grub' else  # no audit_backlog_limit=arg is present, append it  sed -i 's/\\(^GRUB_CMDLINE_LINUX=\".*\\)\"/\\1 audit_backlog_limit=8192\"/' '/etc/default/grub' fi update-grub else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "avahi_configuration",
        "rid": "avahi_disable_publishing",
        "gtitle": "Configure Avahi if Necessary"
      },
      "id": "avahi_configuration",
      "title": [
        {
          "#text": "Disable Avahi Publishing",
          "@_lang": "en-US"
        }
      ],
      "desc": "To prevent Avahi from publishing its records, editand ensure the following line appears in thesection:",
      "impact": 0.3,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "base",
        "rid": "service_kdump_disabled",
        "gtitle": "Base Services",
        "fix_id": "service_kdump_disabled"
      },
      "id": "base",
      "title": [
        {
          "#text": "Disable KDump Kernel Crash Analyzer (kdump)",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice provides a kernel crash dump analyzer. It uses thesystem call to boot a secondary kernel (\"capture\" kernel) following a system crash, which can load information from the crashed kernel for analysis. Theservice can be disabled with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" stop 'kdump.service' \"$SYSTEMCTL_EXEC\" disable 'kdump.service' \"$SYSTEMCTL_EXEC\" mask 'kdump.service' # Disable socket activation if we have a unit file for it if \"$SYSTEMCTL_EXEC\" list-unit-files | grep -q '^kdump.socket'; then \"$SYSTEMCTL_EXEC\" stop 'kdump.socket' \"$SYSTEMCTL_EXEC\" mask 'kdump.socket' fi # The service may not be running because it has been started and failed, # so let's reset the state so OVAL checks pass. # Service should be 'inactive', not 'failed' after reboot though. \"$SYSTEMCTL_EXEC\" reset-failed 'kdump.service' || true else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "bootloader-grub2",
        "rid": "grub2_enable_iommu_force",
        "gtitle": "GRUB2 bootloader configuration",
        "fix_id": "grub2_enable_iommu_force"
      },
      "id": "bootloader-grub2",
      "title": [
        {
          "#text": "IOMMU configuration directive",
          "@_lang": "en-US"
        }
      ],
      "desc": "On x86 architecture supporting VT-d, the IOMMU manages the access control policy between the hardware devices and some of the system critical units such as the memory.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'grub2-common' 2&gt;/dev/null | grep -q installed &amp;&amp; { [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; }; then # Correct the form of default kernel command line in GRUB if grep -q '^GRUB_CMDLINE_LINUX=.*iommu=.*\"' '/etc/default/grub' ; then  # modify the GRUB command-line if an iommu= arg already exists  sed -i 's/\\(^GRUB_CMDLINE_LINUX=\".*\\)iommu=[^[:space:]]*\\(.*\"\\)/\\1 iommu=force \\2/' '/etc/default/grub' else  # no iommu=arg is present, append it  sed -i 's/\\(^GRUB_CMDLINE_LINUX=\".*\\)\"/\\1 iommu=force\"/' '/etc/default/grub' fi update-grub else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "bootloader-zipl",
        "rid": "zipl_audit_argument",
        "gtitle": "zIPL bootloader configuration"
      },
      "id": "bootloader-zipl",
      "title": [
        {
          "#text": "Enable Auditing to Start Prior to the Audit Daemon in zIPL",
          "@_lang": "en-US"
        }
      ],
      "desc": "To ensure all processes can be audited, even those which start prior to the audit daemon, check that all boot entries inhaveincluded in its options.To ensure that new kernels and boot entries continue to enable audit, addto.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "bootloader-zipl",
        "rid": "zipl_audit_backlog_limit_argument",
        "gtitle": "zIPL bootloader configuration"
      },
      "id": "bootloader-zipl",
      "title": [
        {
          "#text": "Extend Audit Backlog Limit for the Audit Daemon in zIPL",
          "@_lang": "en-US"
        }
      ],
      "desc": "To improve the kernel capacity to queue all log events, even those which start prior to the audit daemon, check that all boot entries inhaveincluded in its options.To ensure that new kernels and boot entries continue to extend the audit log events queue, addto.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gid": "certified-vendor",
        "rid": "installed_OS_is_FIPS_certified",
        "gtitle": "Operating System Vendor Support and Certification"
      },
      "id": "certified-vendor",
      "title": [
        {
          "#text": "The Installed Operating System Is FIPS 140-2 Certified",
          "@_lang": "en-US"
        }
      ],
      "desc": "To enable processing of sensitive information the operating system must provide certified cryptographic modules compliant with FIPS 140-2 standard. Ubuntu Linux is supported by Canonical Ltd. As the Ubuntu Linux Vendor, Canonical Ltd. is responsible for government certifications and standards. Users of Ubuntu Linux either need an Ubuntu Advantage subscription or need to be using Ubuntu Pro from a sponsored vendor in order to have access to FIPS content supported by Canonical.",
      "impact": 0.7,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_audispd_configure_remote_server",
        "gtitle": "Configure auditd Data Retention"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Configure audispd Plugin To Send Logs To Remote Server",
          "@_lang": "en-US"
        }
      ],
      "desc": "Configure the audispd plugin to off-load audit records onto a different system or media from the system being audited. Set theoption inwith an IP address or hostname of the system that the audispd plugin should send audit records to. For example",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_audispd_configure_sufficiently_large_partition",
        "gtitle": "Configure auditd Data Retention"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Configure a Sufficiently Large Partition for Audit Logs",
          "@_lang": "en-US"
        }
      ],
      "desc": "The Ubuntu 20.04 operating system must allocate audit record storage capacity to store at least one weeks worth of audit records when audit records are not immediately sent to a central audit record storage facility. The partition size needed to capture a week's worth of audit records is based on the activity level of the system and the total storage capacity available. In normal circumstances, 10.0 GB of storage space for audit records will be sufficient. Determine which partition the audit records are being written to with the following command:Check the size of the partition that audit records are written to with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_audispd_syslog_plugin_activated",
        "gtitle": "Configure auditd Data Retention",
        "fix_id": "auditd_audispd_syslog_plugin_activated"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Configure auditd to use audispd's syslog plugin",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure theservice to use theplug-in of theaudit event multiplexor, set theline into. Restart theservice:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'audit' 2&gt;/dev/null | grep -q installed; then var_syslog_active=\"yes\" AUDISP_SYSLOGCONFIG=/etc/audisp/plugins.d/syslog.conf # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"$AUDISP_SYSLOGCONFIG\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^active\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_syslog_active\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^active\\\\&gt;\" \"$AUDISP_SYSLOGCONFIG\"; then \"${sed_command[@]}\" \"s/^active\\\\&gt;.*/$formatted_output/gi\" \"$AUDISP_SYSLOGCONFIG\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"$AUDISP_SYSLOGCONFIG\" &gt;&gt; \"$AUDISP_SYSLOGCONFIG\" printf '%s ' \"$formatted_output\" &gt;&gt; \"$AUDISP_SYSLOGCONFIG\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_data_disk_error_action",
        "gtitle": "Configure auditd Data Retention"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Configure auditd Disk Error Action on Disk Error",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice can be configured to take an action when there is a disk error. Edit the file. Add or modify the following line, substitutingappropriately:Set this value toto cause the system to switch to single-user mode for corrective action. Acceptable values also include,,, and. For certain systems, the need for availability outweighs the need to log all actions, and a different setting should be determined. Details regarding all possible values forare described in theman page.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_data_disk_full_action",
        "gtitle": "Configure auditd Data Retention"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Configure auditd Disk Full Action when Disk Space Is Full",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice can be configured to take an action when disk space is running low but prior to running out of space completely. Edit the file. Add or modify the following line, substitutingappropriately:Set this value toto cause the system to switch to single-user mode for corrective action. Acceptable values also include,,, and. For certain systems, the need for availability outweighs the need to log all actions, and a different setting should be determined. Details regarding all possible values forare described in theman page.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_data_retention_action_mail_acct",
        "gtitle": "Configure auditd Data Retention"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Configure auditd mail_acct Action on Low Disk Space",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice can be configured to send email to a designated account in certain situations. Add or correct the following line into ensure that administrators are notified via email for those situations:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_data_retention_admin_space_left_action",
        "gtitle": "Configure auditd Data Retention"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Configure auditd admin_space_left Action on Low Disk Space",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice can be configured to take an action when disk space is running low but prior to running out of space completely. Edit the file. Add or modify the following line, substitutingappropriately:Set this value toto cause the system to switch to single user mode for corrective action. Acceptable values also includeand. For certain systems, the need for availability outweighs the need to log all actions, and a different setting should be determined. Details regarding all possible values forare described in theman page.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_data_retention_max_log_file",
        "gtitle": "Configure auditd Data Retention"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Configure auditd Max Log File Size",
          "@_lang": "en-US"
        }
      ],
      "desc": "Determine the amount of audit data (in megabytes) which should be retained in each log file. Edit the file. Add or modify the following line, substituting the correct value offor:Set the value to(MB) or higher for general-purpose systems. Larger values, of course, support retention of even more audit data.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_data_retention_max_log_file_action",
        "gtitle": "Configure auditd Data Retention"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Configure auditd max_log_file_action Upon Reaching Maximum Log Size",
          "@_lang": "en-US"
        }
      ],
      "desc": "The default action to take when the logs reach their maximum size is to rotate the log files, discarding the oldest one. To configure the action taken by, add or correct the line in:Possible values forare described in theman page. These include:Set thetoto ensure log rotation occurs. This is the default. The setting is case-insensitive.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_data_retention_num_logs",
        "gtitle": "Configure auditd Data Retention",
        "fix_id": "auditd_data_retention_num_logs"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Configure auditd Number of Logs Retained",
          "@_lang": "en-US"
        }
      ],
      "desc": "Determine how many log filesshould retain when it rotates logs. Edit the file. Add or modify the following line, substitutingwith the correct value of:Set the value to 5 for general-purpose systems. Note that values less than 2 result in no log rotation.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'audit' 2&gt;/dev/null | grep -q installed; then var_auditd_num_logs=\"\" AUDITCONFIG=/etc/audit/auditd.conf # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"$AUDITCONFIG\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^num_logs\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_auditd_num_logs\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^num_logs\\\\&gt;\" \"$AUDITCONFIG\"; then \"${sed_command[@]}\" \"s/^num_logs\\\\&gt;.*/$formatted_output/gi\" \"$AUDITCONFIG\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"$AUDITCONFIG\" &gt;&gt; \"$AUDITCONFIG\" printf '%s ' \"$formatted_output\" &gt;&gt; \"$AUDITCONFIG\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_data_retention_space_left",
        "gtitle": "Configure auditd Data Retention"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Configure auditd space_left on Low Disk Space",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice can be configured to take an action when disk space is running low but prior to running out of space completely. Edit the file. Add or modify the following line, substitutingappropriately:Set this value to the appropriate size in Megabytes cause the system to notify the user of an issue.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_data_retention_space_left_action",
        "gtitle": "Configure auditd Data Retention"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Configure auditd space_left Action on Low Disk Space",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice can be configured to take an action when disk spaceto run low. Edit the file. Modify the following line, substitutingappropriately:Possible values forare described in theman page. These include:Set this to(instead of the default, which is) as it is more likely to get prompt attention. Acceptable values also include,, and.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_freq",
        "gtitle": "Configure auditd Data Retention",
        "fix_id": "auditd_freq"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Set number of records to cause an explicit flush to audit logs",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure Audit daemon to issue an explicit flush to disk command after writing 50 records, settoin.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'audit' 2&gt;/dev/null | grep -q installed; then if [ -e \"/etc/audit/auditd.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*freq\\s*=\\s*/Id\" \"/etc/audit/auditd.conf\" else touch \"/etc/audit/auditd.conf\" fi cp \"/etc/audit/auditd.conf\" \"/etc/audit/auditd.conf.bak\" # Insert at the end of the file printf '%s ' \"freq = 50\" &gt;&gt; \"/etc/audit/auditd.conf\" # Clean up after ourselves. rm \"/etc/audit/auditd.conf.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_local_events",
        "gtitle": "Configure auditd Data Retention",
        "fix_id": "auditd_local_events"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Include Local Events in Audit Logs",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure Audit daemon to include local events in Audit logs, settoin. This is the default setting.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'audit' 2&gt;/dev/null | grep -q installed; then if [ -e \"/etc/audit/auditd.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*local_events\\s*=\\s*/Id\" \"/etc/audit/auditd.conf\" else touch \"/etc/audit/auditd.conf\" fi cp \"/etc/audit/auditd.conf\" \"/etc/audit/auditd.conf.bak\" # Insert at the end of the file printf '%s ' \"local_events = yes\" &gt;&gt; \"/etc/audit/auditd.conf\" # Clean up after ourselves. rm \"/etc/audit/auditd.conf.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_log_format",
        "gtitle": "Configure auditd Data Retention",
        "fix_id": "auditd_log_format"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Resolve information before writing to audit logs",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure Audit daemon to resolve all uid, gid, syscall, architecture, and socket address information before writing the events to disk, settoin.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'audit' 2&gt;/dev/null | grep -q installed; then if [ -e \"/etc/audit/auditd.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*log_format\\s*=\\s*/Id\" \"/etc/audit/auditd.conf\" else touch \"/etc/audit/auditd.conf\" fi cp \"/etc/audit/auditd.conf\" \"/etc/audit/auditd.conf.bak\" # Insert at the end of the file printf '%s ' \"log_format = ENRICHED\" &gt;&gt; \"/etc/audit/auditd.conf\" # Clean up after ourselves. rm \"/etc/audit/auditd.conf.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_name_format",
        "gtitle": "Configure auditd Data Retention",
        "fix_id": "auditd_name_format"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Set hostname as computer node name in audit logs",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure Audit daemon to use value returned by gethostname syscall as computer node name in the audit events, settoin.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'audit' 2&gt;/dev/null | grep -q installed; then if [ -e \"/etc/audit/auditd.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*name_format\\s*=\\s*/Id\" \"/etc/audit/auditd.conf\" else touch \"/etc/audit/auditd.conf\" fi cp \"/etc/audit/auditd.conf\" \"/etc/audit/auditd.conf.bak\" # Insert at the end of the file printf '%s ' \"name_format = hostname\" &gt;&gt; \"/etc/audit/auditd.conf\" # Clean up after ourselves. rm \"/etc/audit/auditd.conf.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_overflow_action",
        "gtitle": "Configure auditd Data Retention"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Appropriate Action Must be Setup When the Internal Audit Event Queue is Full",
          "@_lang": "en-US"
        }
      ],
      "desc": "The audit system should have an action setup in the event the internal event queue becomes full. To setup an overflow action edit. Setto one of the following values:,,.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_write_logs",
        "gtitle": "Configure auditd Data Retention",
        "fix_id": "auditd_write_logs"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Write Audit Logs to the Disk",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure Audit daemon to write Audit logs to the disk, settoin. This is the default setting.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'audit' 2&gt;/dev/null | grep -q installed; then if [ -e \"/etc/audit/auditd.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*write_logs\\s*=\\s*/Id\" \"/etc/audit/auditd.conf\" else touch \"/etc/audit/auditd.conf\" fi cp \"/etc/audit/auditd.conf\" \"/etc/audit/auditd.conf.bak\" # Insert at the end of the file printf '%s ' \"write_logs = yes\" &gt;&gt; \"/etc/audit/auditd.conf\" # Clean up after ourselves. rm \"/etc/audit/auditd.conf.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "configuring_ipv6",
        "rid": "sysctl_net_ipv6_conf_all_accept_ra",
        "gtitle": "Configure IPv6 Settings if Necessary",
        "fix_id": "sysctl_net_ipv6_conf_all_accept_ra"
      },
      "id": "configuring_ipv6",
      "title": [
        {
          "#text": "Configure Accepting Router Advertisements on All IPv6 Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv6_conf_all_accept_ra_value=\"\" # # Set runtime for net.ipv6.conf.all.accept_ra # /sbin/sysctl -q -n -w net.ipv6.conf.all.accept_ra=\"$sysctl_net_ipv6_conf_all_accept_ra_value\" # # If net.ipv6.conf.all.accept_ra present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv6.conf.all.accept_ra = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv6.conf.all.accept_ra\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv6_conf_all_accept_ra_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv6.conf.all.accept_ra\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv6.conf.all.accept_ra\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "configuring_ipv6",
        "rid": "sysctl_net_ipv6_conf_all_accept_redirects",
        "gtitle": "Configure IPv6 Settings if Necessary",
        "fix_id": "sysctl_net_ipv6_conf_all_accept_redirects"
      },
      "id": "configuring_ipv6",
      "title": [
        {
          "#text": "Disable Accepting ICMP Redirects for All IPv6 Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv6_conf_all_accept_redirects_value=\"\" # # Set runtime for net.ipv6.conf.all.accept_redirects # /sbin/sysctl -q -n -w net.ipv6.conf.all.accept_redirects=\"$sysctl_net_ipv6_conf_all_accept_redirects_value\" # # If net.ipv6.conf.all.accept_redirects present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv6.conf.all.accept_redirects = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv6.conf.all.accept_redirects\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv6_conf_all_accept_redirects_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv6.conf.all.accept_redirects\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv6.conf.all.accept_redirects\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "configuring_ipv6",
        "rid": "sysctl_net_ipv6_conf_all_accept_source_route",
        "gtitle": "Configure IPv6 Settings if Necessary",
        "fix_id": "sysctl_net_ipv6_conf_all_accept_source_route"
      },
      "id": "configuring_ipv6",
      "title": [
        {
          "#text": "Disable Kernel Parameter for Accepting Source-Routed Packets on all IPv6 Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv6_conf_all_accept_source_route_value=\"\" # # Set runtime for net.ipv6.conf.all.accept_source_route # /sbin/sysctl -q -n -w net.ipv6.conf.all.accept_source_route=\"$sysctl_net_ipv6_conf_all_accept_source_route_value\" # # If net.ipv6.conf.all.accept_source_route present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv6.conf.all.accept_source_route = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv6.conf.all.accept_source_route\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv6_conf_all_accept_source_route_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv6.conf.all.accept_source_route\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv6.conf.all.accept_source_route\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "configuring_ipv6",
        "rid": "sysctl_net_ipv6_conf_all_forwarding",
        "gtitle": "Configure IPv6 Settings if Necessary",
        "fix_id": "sysctl_net_ipv6_conf_all_forwarding"
      },
      "id": "configuring_ipv6",
      "title": [
        {
          "#text": "Disable Kernel Parameter for IPv6 Forwarding",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv6_conf_all_forwarding_value=\"\" # # Set runtime for net.ipv6.conf.all.forwarding # /sbin/sysctl -q -n -w net.ipv6.conf.all.forwarding=\"$sysctl_net_ipv6_conf_all_forwarding_value\" # # If net.ipv6.conf.all.forwarding present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv6.conf.all.forwarding = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv6.conf.all.forwarding\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv6_conf_all_forwarding_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv6.conf.all.forwarding\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv6.conf.all.forwarding\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "configuring_ipv6",
        "rid": "sysctl_net_ipv6_conf_default_accept_ra",
        "gtitle": "Configure IPv6 Settings if Necessary",
        "fix_id": "sysctl_net_ipv6_conf_default_accept_ra"
      },
      "id": "configuring_ipv6",
      "title": [
        {
          "#text": "Disable Accepting Router Advertisements on all IPv6 Interfaces by Default",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv6_conf_default_accept_ra_value=\"\" # # Set runtime for net.ipv6.conf.default.accept_ra # /sbin/sysctl -q -n -w net.ipv6.conf.default.accept_ra=\"$sysctl_net_ipv6_conf_default_accept_ra_value\" # # If net.ipv6.conf.default.accept_ra present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv6.conf.default.accept_ra = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv6.conf.default.accept_ra\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv6_conf_default_accept_ra_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv6.conf.default.accept_ra\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv6.conf.default.accept_ra\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "configuring_ipv6",
        "rid": "sysctl_net_ipv6_conf_default_accept_redirects",
        "gtitle": "Configure IPv6 Settings if Necessary",
        "fix_id": "sysctl_net_ipv6_conf_default_accept_redirects"
      },
      "id": "configuring_ipv6",
      "title": [
        {
          "#text": "Disable Kernel Parameter for Accepting ICMP Redirects by Default on IPv6 Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv6_conf_default_accept_redirects_value=\"\" # # Set runtime for net.ipv6.conf.default.accept_redirects # /sbin/sysctl -q -n -w net.ipv6.conf.default.accept_redirects=\"$sysctl_net_ipv6_conf_default_accept_redirects_value\" # # If net.ipv6.conf.default.accept_redirects present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv6.conf.default.accept_redirects = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv6.conf.default.accept_redirects\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv6_conf_default_accept_redirects_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv6.conf.default.accept_redirects\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv6.conf.default.accept_redirects\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "configuring_ipv6",
        "rid": "sysctl_net_ipv6_conf_default_accept_source_route",
        "gtitle": "Configure IPv6 Settings if Necessary",
        "fix_id": "sysctl_net_ipv6_conf_default_accept_source_route"
      },
      "id": "configuring_ipv6",
      "title": [
        {
          "#text": "Disable Kernel Parameter for Accepting Source-Routed Packets on IPv6 Interfaces by Default",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv6_conf_default_accept_source_route_value=\"\" # # Set runtime for net.ipv6.conf.default.accept_source_route # /sbin/sysctl -q -n -w net.ipv6.conf.default.accept_source_route=\"$sysctl_net_ipv6_conf_default_accept_source_route_value\" # # If net.ipv6.conf.default.accept_source_route present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv6.conf.default.accept_source_route = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv6.conf.default.accept_source_route\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv6_conf_default_accept_source_route_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv6.conf.default.accept_source_route\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv6.conf.default.accept_source_route\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "console_screen_locking",
        "rid": "vlock_installed",
        "gtitle": "Configure Console Screen Locking",
        "fix_id": "vlock_installed"
      },
      "id": "console_screen_locking",
      "title": [
        {
          "#text": "Check that vlock is installed to allow session locking",
          "@_lang": "en-US"
        }
      ],
      "desc": "The Ubuntu 20.04 operating system must have vlock installed to allow for session locking. Thepackage can be installed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "DEBIAN_FRONTEND=noninteractive apt-get install -y \"vlock\""
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "coredumps",
        "rid": "coredump_disable_backtraces",
        "gtitle": "Disable Core Dumps",
        "fix_id": "coredump_disable_backtraces"
      },
      "id": "coredumps",
      "title": [
        {
          "#text": "Disable core dump backtraces",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theoption insection ofspecifies the maximum size in bytes of a core which will be processed. Core dumps exceeding this size may be stored, but the backtrace will not be generated.",
      "impact": 0.5,
      "descs": {
        "fix": "if [ -e \"/etc/systemd/coredump.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*ProcessSizeMax\\s*=\\s*/Id\" \"/etc/systemd/coredump.conf\" else touch \"/etc/systemd/coredump.conf\" fi cp \"/etc/systemd/coredump.conf\" \"/etc/systemd/coredump.conf.bak\" # Insert at the end of the file printf '%s ' \"ProcessSizeMax=0\" &gt;&gt; \"/etc/systemd/coredump.conf\" # Clean up after ourselves. rm \"/etc/systemd/coredump.conf.bak\""
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "coredumps",
        "rid": "coredump_disable_storage",
        "gtitle": "Disable Core Dumps",
        "fix_id": "coredump_disable_storage"
      },
      "id": "coredumps",
      "title": [
        {
          "#text": "Disable storing core dump",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theoption insection ofcan be set toto disable storing core dumps permanently.",
      "impact": 0.5,
      "descs": {
        "fix": "if [ -e \"/etc/systemd/coredump.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*Storage\\s*=\\s*/Id\" \"/etc/systemd/coredump.conf\" else touch \"/etc/systemd/coredump.conf\" fi cp \"/etc/systemd/coredump.conf\" \"/etc/systemd/coredump.conf.bak\" # Insert at the end of the file printf '%s ' \"Storage=none\" &gt;&gt; \"/etc/systemd/coredump.conf\" # Clean up after ourselves. rm \"/etc/systemd/coredump.conf.bak\""
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "coredumps",
        "rid": "disable_users_coredumps",
        "gtitle": "Disable Core Dumps",
        "fix_id": "disable_users_coredumps"
      },
      "id": "coredumps",
      "title": [
        {
          "#text": "Disable Core Dumps for All Users",
          "@_lang": "en-US"
        }
      ],
      "desc": "To disable core dumps for all users, add the following line to, or to a file within thedirectory:",
      "impact": 0.5,
      "descs": {
        "fix": "- name: Gather the package facts package_facts: manager: auto tags: - disable_users_coredumps - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy - name: disable core dumps with limits lineinfile: dest: /etc/security/limits.conf regexp: ^[^#].*core line: '* hard core 0' create: true when: '\"libpam-runtime\" in ansible_facts.packages' tags: - disable_users_coredumps - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "coredumps",
        "rid": "sysctl_fs_suid_dumpable",
        "gtitle": "Disable Core Dumps",
        "fix_id": "sysctl_fs_suid_dumpable"
      },
      "id": "coredumps",
      "title": [
        {
          "#text": "Disable Core Dumps for SUID programs",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # # Set runtime for fs.suid_dumpable # /sbin/sysctl -q -n -w fs.suid_dumpable=\"0\" # # If fs.suid_dumpable present in /etc/sysctl.conf, change value to \"0\" # else, add \"fs.suid_dumpable = 0\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^fs.suid_dumpable\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"0\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^fs.suid_dumpable\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^fs.suid_dumpable\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "cron_and_at",
        "rid": "package_cron_installed",
        "gtitle": "Cron and At Daemons",
        "fix_id": "package_cron_installed"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Install the cron service",
          "@_lang": "en-US"
        }
      ],
      "desc": "The Cron service should be installed.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"cron\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "cron_and_at",
        "rid": "service_cron_enabled",
        "gtitle": "Cron and At Daemons",
        "fix_id": "service_cron_enabled"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Enable cron Service",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice is used to execute commands at preconfigured times. It is required by almost all systems to perform necessary maintenance tasks, such as notifying root of system activity. Theservice can be enabled with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" unmask 'cron.service' \"$SYSTEMCTL_EXEC\" start 'cron.service' \"$SYSTEMCTL_EXEC\" enable 'cron.service' else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "cron_and_at",
        "rid": "file_groupowner_cron_d",
        "gtitle": "Cron and At Daemons",
        "fix_id": "file_groupowner_cron_d"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Group Who Owns cron.d",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chgrp 0 /etc/cron.d/ else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "cron_and_at",
        "rid": "file_groupowner_cron_daily",
        "gtitle": "Cron and At Daemons",
        "fix_id": "file_groupowner_cron_daily"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Group Who Owns cron.daily",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chgrp 0 /etc/cron.daily/ else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "cron_and_at",
        "rid": "file_groupowner_cron_hourly",
        "gtitle": "Cron and At Daemons",
        "fix_id": "file_groupowner_cron_hourly"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Group Who Owns cron.hourly",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chgrp 0 /etc/cron.hourly/ else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "cron_and_at",
        "rid": "file_groupowner_cron_monthly",
        "gtitle": "Cron and At Daemons",
        "fix_id": "file_groupowner_cron_monthly"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Group Who Owns cron.monthly",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chgrp 0 /etc/cron.monthly/ else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "cron_and_at",
        "rid": "file_groupowner_cron_weekly",
        "gtitle": "Cron and At Daemons",
        "fix_id": "file_groupowner_cron_weekly"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Group Who Owns cron.weekly",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chgrp 0 /etc/cron.weekly/ else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "cron_and_at",
        "rid": "file_groupowner_crontab",
        "gtitle": "Cron and At Daemons",
        "fix_id": "file_groupowner_crontab"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Group Who Owns Crontab",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chgrp 0 /etc/crontab else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "cron_and_at",
        "rid": "file_owner_cron_d",
        "gtitle": "Cron and At Daemons",
        "fix_id": "file_owner_cron_d"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Owner on cron.d",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chown 0 /etc/cron.d/ else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "cron_and_at",
        "rid": "file_owner_cron_daily",
        "gtitle": "Cron and At Daemons",
        "fix_id": "file_owner_cron_daily"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Owner on cron.daily",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chown 0 /etc/cron.daily/ else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "cron_and_at",
        "rid": "file_owner_cron_hourly",
        "gtitle": "Cron and At Daemons",
        "fix_id": "file_owner_cron_hourly"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Owner on cron.hourly",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chown 0 /etc/cron.hourly/ else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "cron_and_at",
        "rid": "file_owner_cron_monthly",
        "gtitle": "Cron and At Daemons",
        "fix_id": "file_owner_cron_monthly"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Owner on cron.monthly",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chown 0 /etc/cron.monthly/ else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "cron_and_at",
        "rid": "file_owner_cron_weekly",
        "gtitle": "Cron and At Daemons",
        "fix_id": "file_owner_cron_weekly"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Owner on cron.weekly",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chown 0 /etc/cron.weekly/ else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "cron_and_at",
        "rid": "file_owner_crontab",
        "gtitle": "Cron and At Daemons",
        "fix_id": "file_owner_crontab"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Owner on crontab",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chown 0 /etc/crontab else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "cron_and_at",
        "rid": "file_permissions_cron_d",
        "gtitle": "Cron and At Daemons",
        "fix_id": "file_permissions_cron_d"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Permissions on cron.d",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chmod 0700 /etc/cron.d/ else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "cron_and_at",
        "rid": "file_permissions_cron_daily",
        "gtitle": "Cron and At Daemons",
        "fix_id": "file_permissions_cron_daily"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Permissions on cron.daily",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chmod 0700 /etc/cron.daily/ else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "cron_and_at",
        "rid": "file_permissions_cron_hourly",
        "gtitle": "Cron and At Daemons",
        "fix_id": "file_permissions_cron_hourly"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Permissions on cron.hourly",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chmod 0700 /etc/cron.hourly/ else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "cron_and_at",
        "rid": "file_permissions_cron_monthly",
        "gtitle": "Cron and At Daemons",
        "fix_id": "file_permissions_cron_monthly"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Permissions on cron.monthly",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chmod 0700 /etc/cron.monthly/ else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "cron_and_at",
        "rid": "file_permissions_cron_weekly",
        "gtitle": "Cron and At Daemons",
        "fix_id": "file_permissions_cron_weekly"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Permissions on cron.weekly",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chmod 0700 /etc/cron.weekly/ else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "cron_and_at",
        "rid": "file_permissions_crontab",
        "gtitle": "Cron and At Daemons",
        "fix_id": "file_permissions_crontab"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Permissions on crontab",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chmod 0600 /etc/crontab else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "crypto",
        "rid": "harden_ssh_client_crypto_policy",
        "gtitle": "System Cryptographic Policies",
        "fix_id": "harden_ssh_client_crypto_policy"
      },
      "id": "crypto",
      "title": [
        {
          "#text": "Harden SSH client Crypto Policy",
          "@_lang": "en-US"
        }
      ],
      "desc": "Crypto Policies are means of enforcing certain cryptographic settings for selected applications including OpenSSH client. To override the system wide crypto policy for Openssh client, place a file in theso that it is loaded before the. In this case it is file namedcontaining parameters which need to be changed with respect to the crypto policy. This rule checks if the file exists and if it contains required parameters and values which modify the Crypto Policy. During the parsing process, as soon as Openssh client parses some configuration option and its value, it remembers it and ignores any subsequent overrides. The customization mechanism provided by crypto policies appends eventual customizations at the end of the system wide crypto policy. Therefore, if the crypto policy customization overrides some parameter which is already configured in the system wide crypto policy, the SSH client will not honor that customized parameter.",
      "impact": 0.5,
      "descs": {
        "fix": "#the file starts with 02 so that it is loaded before the 05-redhat.conf which activates configuration provided by system vide crypto policy file=\"/etc/ssh/ssh_config.d/02-ospp.conf\" echo -e \"Match final all \\ RekeyLimit 512M 1h \\ GSSAPIAuthentication no \\ Ciphers aes256-ctr,aes256-cbc,aes128-ctr,aes128-cbc \\ PubkeyAcceptedKeyTypes ssh-rsa,ecdsa-sha2-nistp384,ecdsa-sha2-nistp256 \\ MACs hmac-sha2-512,hmac-sha2-256 \\ KexAlgorithms ecdh-sha2-nistp521,ecdh-sha2-nistp384,ecdh-sha2-nistp256,diffie-hellman-group14-sha1 \" &gt; \"$file\""
      }
    },
    {
      "tags": {
        "severity": "high",
        "gid": "deprecated",
        "rid": "package_inetutils-telnetd_removed",
        "gtitle": "Deprecated services",
        "fix_id": "package_inetutils-telnetd_removed"
      },
      "id": "deprecated",
      "title": [
        {
          "#text": "Uninstall the inet-based telnet server",
          "@_lang": "en-US"
        }
      ],
      "desc": "The inet-based telnet daemon should be uninstalled.",
      "impact": 0.7,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove inetutils-telnetd #  from the system, and may remove any packages #  that depend on inetutils-telnetd. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"inetutils-telnetd\""
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "deprecated",
        "rid": "package_nis_removed",
        "gtitle": "Deprecated services",
        "fix_id": "package_nis_removed"
      },
      "id": "deprecated",
      "title": [
        {
          "#text": "Uninstall the nis package",
          "@_lang": "en-US"
        }
      ],
      "desc": "The support for Yellowpages should not be installed unless it is required.",
      "impact": 0.3,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove nis #  from the system, and may remove any packages #  that depend on nis. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"nis\""
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "deprecated",
        "rid": "package_ntpdate_removed",
        "gtitle": "Deprecated services",
        "fix_id": "package_ntpdate_removed"
      },
      "id": "deprecated",
      "title": [
        {
          "#text": "Uninstall the ntpdate package",
          "@_lang": "en-US"
        }
      ],
      "desc": "ntpdate is a historical ntp synchronization client for unixes. It sould be uninstalled.",
      "impact": 0.3,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove ntpdate #  from the system, and may remove any packages #  that depend on ntpdate. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"ntpdate\""
      }
    },
    {
      "tags": {
        "severity": "high",
        "gid": "deprecated",
        "rid": "package_telnetd-ssl_removed",
        "gtitle": "Deprecated services",
        "fix_id": "package_telnetd-ssl_removed"
      },
      "id": "deprecated",
      "title": [
        {
          "#text": "Uninstall the ssl compliant telnet server",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thedaemon, even with ssl support, should be uninstalled.",
      "impact": 0.7,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove telnetd-ssl #  from the system, and may remove any packages #  that depend on telnetd-ssl. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"telnetd-ssl\""
      }
    },
    {
      "tags": {
        "severity": "high",
        "gid": "deprecated",
        "rid": "package_telnetd_removed",
        "gtitle": "Deprecated services",
        "fix_id": "package_telnetd_removed"
      },
      "id": "deprecated",
      "title": [
        {
          "#text": "Uninstall the telnet server",
          "@_lang": "en-US"
        }
      ],
      "desc": "The telnet daemon should be uninstalled.",
      "impact": 0.7,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove telnetd #  from the system, and may remove any packages #  that depend on telnetd. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"telnetd\""
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "dhcp_client_configuration",
        "rid": "dhcp_client_restrict_options",
        "gtitle": "Configure DHCP Client if Necessary"
      },
      "id": "dhcp_client_configuration",
      "title": [
        {
          "#text": "Minimize the DHCP-Configured Options",
          "@_lang": "en-US"
        }
      ],
      "desc": "Create the file, and add an appropriate setting for each of the ten configuration settings which can be obtained via DHCP. For each setting, do one of the following:If the setting shouldbe configured remotely by the DHCP server, select an appropriate static value, and add the line:If the setting should be configured remotely by the DHCP server, add the lines:For example, suppose the DHCP server should provide only the IP address itself and the subnet mask. Then the entire file should look like:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "dhcp_server_configuration",
        "rid": "dhcp_server_minimize_served_info",
        "gtitle": "Configure DHCP Server"
      },
      "id": "dhcp_server_configuration",
      "title": [
        {
          "#text": "Minimize Served Information",
          "@_lang": "en-US"
        }
      ],
      "desc": "Edit /etc/dhcp/dhcpd.conf. Examine each address range section within the file, and ensure that the following options are not defined unless there is an operational need to provide this information via DHCP:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "disable_avahi_group",
        "rid": "service_avahi-daemon_disabled",
        "gtitle": "Disable Avahi Server if Possible",
        "fix_id": "service_avahi-daemon_disabled"
      },
      "id": "disable_avahi_group",
      "title": [
        {
          "#text": "Disable Avahi Server Software",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice can be disabled with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" stop 'avahi-daemon.service' \"$SYSTEMCTL_EXEC\" disable 'avahi-daemon.service' \"$SYSTEMCTL_EXEC\" mask 'avahi-daemon.service' # Disable socket activation if we have a unit file for it if \"$SYSTEMCTL_EXEC\" list-unit-files | grep -q '^avahi-daemon.socket'; then \"$SYSTEMCTL_EXEC\" stop 'avahi-daemon.socket' \"$SYSTEMCTL_EXEC\" mask 'avahi-daemon.socket' fi # The service may not be running because it has been started and failed, # so let's reset the state so OVAL checks pass. # Service should be 'inactive', not 'failed' after reboot though. \"$SYSTEMCTL_EXEC\" reset-failed 'avahi-daemon.service' || true else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "disabling_dhcp_server",
        "rid": "package_dhcp_removed",
        "gtitle": "Disable DHCP Server",
        "fix_id": "package_dhcp_removed"
      },
      "id": "disabling_dhcp_server",
      "title": [
        {
          "#text": "Uninstall DHCP Server Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "If the system does not need to act as a DHCP server, the dhcp package can be uninstalled. Thepackage can be removed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove isc-dhcp-server #  from the system, and may remove any packages #  that depend on isc-dhcp-server. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"isc-dhcp-server\""
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "disabling_dns_server",
        "rid": "package_bind_removed",
        "gtitle": "Disable DNS Server",
        "fix_id": "package_bind_removed"
      },
      "id": "disabling_dns_server",
      "title": [
        {
          "#text": "Uninstall bind Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice is provided by thepackage. Thepackage can be removed with the following command:",
      "impact": 0.3,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove bind9 #  from the system, and may remove any packages #  that depend on bind9. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"bind9\""
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "disabling_dovecot",
        "rid": "package_dovecot_removed",
        "gtitle": "Disable Dovecot",
        "fix_id": "package_dovecot_removed"
      },
      "id": "disabling_dovecot",
      "title": [
        {
          "#text": "Uninstall dovecot Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be removed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove dovecot-core #  from the system, and may remove any packages #  that depend on dovecot-core. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"dovecot-core\""
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "disabling_httpd",
        "rid": "package_httpd_removed",
        "gtitle": "Disable Apache if Possible",
        "fix_id": "package_httpd_removed"
      },
      "id": "disabling_httpd",
      "title": [
        {
          "#text": "Uninstall httpd Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be removed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove apache2 #  from the system, and may remove any packages #  that depend on apache2. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"apache2\""
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "disabling_ipv6",
        "rid": "kernel_module_ipv6_option_disabled",
        "gtitle": "Disable Support for IPv6 Unless Needed",
        "fix_id": "kernel_module_ipv6_option_disabled"
      },
      "id": "disabling_ipv6",
      "title": [
        {
          "#text": "Disable IPv6 Networking Support Automatic Loading",
          "@_lang": "en-US"
        }
      ],
      "desc": "To prevent the IPv6 kernel module () from binding to the IPv6 networking stack, add the following line to(or another file in):This permits the IPv6 module to be loaded (and thus satisfy other modules that depend on it), while disabling support for the IPv6 protocol.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # Prevent the IPv6 kernel module (ipv6) from loading the IPv6 networking stack echo \"options ipv6 disable=1\" &gt; /etc/modprobe.d/ipv6.conf # Since according to: https://access.redhat.com/solutions/72733 # \"ipv6 disable=1\" options doesn't always disable the IPv6 networking stack from # loading, instruct also sysctl configuration to disable IPv6 according to: # https://access.redhat.com/solutions/8709#rhel6disable declare -a IPV6_SETTINGS=(\"net.ipv6.conf.all.disable_ipv6\" \"net.ipv6.conf.default.disable_ipv6\") for setting in \"${IPV6_SETTINGS[@]}\" do  # Set runtime =1 for setting  /sbin/sysctl -q -n -w \"$setting=1\"  # If setting is present in /etc/sysctl.conf, change value to \"1\"  # else, add \"$setting = 1\" to /etc/sysctl.conf  if grep -q ^\"$setting\" /etc/sysctl.conf ; then   sed -i \"s/^$setting.*/$setting = 1/g\" /etc/sysctl.conf  else   echo \"\" &gt;&gt; /etc/sysctl.conf   echo \"# Set $setting = 1 per security requirements\" &gt;&gt; /etc/sysctl.conf   echo \"$setting = 1\" &gt;&gt; /etc/sysctl.conf  fi done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "disabling_ipv6",
        "rid": "sysctl_net_ipv6_conf_all_disable_ipv6",
        "gtitle": "Disable Support for IPv6 Unless Needed",
        "fix_id": "sysctl_net_ipv6_conf_all_disable_ipv6"
      },
      "id": "disabling_ipv6",
      "title": [
        {
          "#text": "Disable IPv6 Addressing on All IPv6 Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "To disable support for () addressing on all interface add the following line to(or another file in):This disables IPv6 on all network interfaces as other services and system functionality require the IPv6 stack loaded to work.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # # Set runtime for net.ipv6.conf.all.disable_ipv6 # /sbin/sysctl -q -n -w net.ipv6.conf.all.disable_ipv6=\"1\" # # If net.ipv6.conf.all.disable_ipv6 present in /etc/sysctl.conf, change value to \"1\" # else, add \"net.ipv6.conf.all.disable_ipv6 = 1\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv6.conf.all.disable_ipv6\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"1\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv6.conf.all.disable_ipv6\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv6.conf.all.disable_ipv6\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "disabling_ipv6",
        "rid": "sysctl_net_ipv6_conf_default_disable_ipv6",
        "gtitle": "Disable Support for IPv6 Unless Needed",
        "fix_id": "sysctl_net_ipv6_conf_default_disable_ipv6"
      },
      "id": "disabling_ipv6",
      "title": [
        {
          "#text": "Disable IPv6 Addressing on IPv6 Interfaces by Default",
          "@_lang": "en-US"
        }
      ],
      "desc": "To disable support for () addressing on interfaces by default add the following line to(or another file in):This disables IPv6 on network interfaces by default as other services and system functionality require the IPv6 stack loaded to work.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # # Set runtime for net.ipv6.conf.default.disable_ipv6 # /sbin/sysctl -q -n -w net.ipv6.conf.default.disable_ipv6=\"1\" # # If net.ipv6.conf.default.disable_ipv6 present in /etc/sysctl.conf, change value to \"1\" # else, add \"net.ipv6.conf.default.disable_ipv6 = 1\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv6.conf.default.disable_ipv6\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"1\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv6.conf.default.disable_ipv6\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv6.conf.default.disable_ipv6\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "disabling_netfs",
        "rid": "service_netfs_disabled",
        "gtitle": "Disable netfs if Possible",
        "fix_id": "service_netfs_disabled"
      },
      "id": "disabling_netfs",
      "title": [
        {
          "#text": "Disable Network File Systems (netfs)",
          "@_lang": "en-US"
        }
      ],
      "desc": "The netfs script manages the boot-time mounting of several types of networked filesystems, of which NFS and Samba are the most common. If these filesystem types are not in use, the script can be disabled, protecting the system somewhat against accidental or malicious changes toand against flaws in the netfs script itself. Theservice can be disabled with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" stop 'netfs.service' \"$SYSTEMCTL_EXEC\" disable 'netfs.service' \"$SYSTEMCTL_EXEC\" mask 'netfs.service' # Disable socket activation if we have a unit file for it if \"$SYSTEMCTL_EXEC\" list-unit-files | grep -q '^netfs.socket'; then \"$SYSTEMCTL_EXEC\" stop 'netfs.socket' \"$SYSTEMCTL_EXEC\" mask 'netfs.socket' fi # The service may not be running because it has been started and failed, # so let's reset the state so OVAL checks pass. # Service should be 'inactive', not 'failed' after reboot though. \"$SYSTEMCTL_EXEC\" reset-failed 'netfs.service' || true else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "disabling_samba",
        "rid": "package_samba_removed",
        "gtitle": "Disable Samba if Possible",
        "fix_id": "package_samba_removed"
      },
      "id": "disabling_samba",
      "title": [
        {
          "#text": "Uninstall Samba Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be removed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove samba #  from the system, and may remove any packages #  that depend on samba. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"samba\""
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "disabling_snmp_service",
        "rid": "package_net-snmp_removed",
        "gtitle": "Disable SNMP Server if Possible",
        "fix_id": "package_net-snmp_removed"
      },
      "id": "disabling_snmp_service",
      "title": [
        {
          "#text": "Uninstall net-snmp Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage provides the snmpd service. Thepackage can be removed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove snmp #  from the system, and may remove any packages #  that depend on snmp. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"snmp\""
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "disabling_squid",
        "rid": "package_squid_removed",
        "gtitle": "Disable Squid if Possible",
        "fix_id": "package_squid_removed"
      },
      "id": "disabling_squid",
      "title": [
        {
          "#text": "Uninstall squid Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be removed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove squid #  from the system, and may remove any packages #  that depend on squid. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"squid\""
      }
    },
    {
      "tags": {
        "severity": "high",
        "gid": "disabling_vsftpd",
        "rid": "package_vsftpd_removed",
        "gtitle": "Disable vsftpd if Possible",
        "fix_id": "package_vsftpd_removed"
      },
      "id": "disabling_vsftpd",
      "title": [
        {
          "#text": "Uninstall vsftpd Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be removed with the following command:",
      "impact": 0.7,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove vsftpd #  from the system, and may remove any packages #  that depend on vsftpd. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"vsftpd\""
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "disabling_xwindows",
        "rid": "package_xorg-x11-server-common_removed",
        "gtitle": "Disable X Windows",
        "fix_id": "package_xorg-x11-server-common_removed"
      },
      "id": "disabling_xwindows",
      "title": [
        {
          "#text": "Remove the X Windows Package Group",
          "@_lang": "en-US"
        }
      ],
      "desc": "By removing the xorg-x11-server-common package, the system no longer has X Windows installed. If X Windows is not installed then the system cannot boot into graphical user mode. This prevents the system from being accidentally or maliciously booted into amode. To do so, run the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove xserver-xorg #  from the system, and may remove any packages #  that depend on xserver-xorg. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"xserver-xorg\""
      }
    },
    {
      "tags": {
        "severity": "high",
        "gid": "disk_partitioning",
        "rid": "encrypt_partitions",
        "gtitle": "Disk Partitioning"
      },
      "id": "disk_partitioning",
      "title": [
        {
          "#text": "Encrypt Partitions",
          "@_lang": "en-US"
        }
      ],
      "desc": "Ubuntu 20.04 natively supports partition encryption through the Linux Unified Key Setup-on-disk-format (LUKS) technology. The easiest way to encrypt a partition is during installation time.For manual installations, select thecheckbox during partition creation to encrypt the partition. When this option is selected the system will prompt for a passphrase to use in decrypting the partition. The passphrase will subsequently need to be entered manually every time the system boots.For automated/unattended installations, it is possible to use Kickstart by adding theandoptions to the definition of each partition to be encrypted. For example, the following line would encrypt the root partition:Anyis stored in the Kickstart in plaintext, and the Kickstart must then be protected accordingly. Omitting theoption from the partition definition will cause the installer to pause and interactively ask for the passphrase during installation.By default, theinstaller usescipher with a minimumbit key size which should be compatible with FIPS enabled.Detailed information on encrypting partitions using LUKS or LUKS ciphers can be found on the Ubuntu 20.04 Documentation web site:.",
      "impact": 0.7,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "disk_partitioning",
        "rid": "partition_for_home",
        "gtitle": "Disk Partitioning"
      },
      "id": "disk_partitioning",
      "title": [
        {
          "#text": "Ensure /home Located On Separate Partition",
          "@_lang": "en-US"
        }
      ],
      "desc": "If user home directories will be stored locally, create a separate partition forat installation time (or migrate it later using LVM). Ifwill be mounted from another system such as an NFS server, then creating a separate partition is not necessary at installation time, and the mountpoint can instead be configured later.",
      "impact": 0.3,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "disk_partitioning",
        "rid": "partition_for_srv",
        "gtitle": "Disk Partitioning"
      },
      "id": "disk_partitioning",
      "title": [
        {
          "#text": "Ensure /srv Located On Separate Partition",
          "@_lang": "en-US"
        }
      ],
      "desc": "If a file server (FTP, TFTP...) is hosted locally, create a separate partition forat installation time (or migrate it later using LVM). Ifwill be mounted from another system such as an NFS server, then creating a separate partition is not necessary at installation time, and the mountpoint can instead be configured later.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "disk_partitioning",
        "rid": "partition_for_tmp",
        "gtitle": "Disk Partitioning"
      },
      "id": "disk_partitioning",
      "title": [
        {
          "#text": "Ensure /tmp Located On Separate Partition",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thedirectory is a world-writable directory used for temporary file storage. Ensure it has its own partition or logical volume at installation time, or migrate it using LVM.",
      "impact": 0.3,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "disk_partitioning",
        "rid": "partition_for_var",
        "gtitle": "Disk Partitioning"
      },
      "id": "disk_partitioning",
      "title": [
        {
          "#text": "Ensure /var Located On Separate Partition",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thedirectory is used by daemons and other system services to store frequently-changing data. Ensure thathas its own partition or logical volume at installation time, or migrate it using LVM.",
      "impact": 0.3,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "disk_partitioning",
        "rid": "partition_for_var_log",
        "gtitle": "Disk Partitioning"
      },
      "id": "disk_partitioning",
      "title": [
        {
          "#text": "Ensure /var/log Located On Separate Partition",
          "@_lang": "en-US"
        }
      ],
      "desc": "System logs are stored in thedirectory. Ensure thathas its own partition or logical volume at installation time, or migrate it using LVM.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "disk_partitioning",
        "rid": "partition_for_var_log_audit",
        "gtitle": "Disk Partitioning"
      },
      "id": "disk_partitioning",
      "title": [
        {
          "#text": "Ensure /var/log/audit Located On Separate Partition",
          "@_lang": "en-US"
        }
      ],
      "desc": "Audit logs are stored in thedirectory. Ensure thathas its own partition or logical volume at installation time, or migrate it using LVM. Make absolutely certain that it is large enough to store all audit logs that will be created by the auditing daemon.",
      "impact": 0.3,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "disk_partitioning",
        "rid": "partition_for_var_tmp",
        "gtitle": "Disk Partitioning"
      },
      "id": "disk_partitioning",
      "title": [
        {
          "#text": "Ensure /var/tmp Located On Separate Partition",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thedirectory is a world-writable directory used for temporary file storage. Ensure it has its own partition or logical volume at installation time, or migrate it using LVM.",
      "impact": 0.3,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "enable_execshield_settings",
        "rid": "sysctl_kernel_kptr_restrict",
        "gtitle": "Enable ExecShield",
        "fix_id": "sysctl_kernel_kptr_restrict"
      },
      "id": "enable_execshield_settings",
      "title": [
        {
          "#text": "Restrict Exposed Kernel Pointer Addresses Access",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # # Set runtime for kernel.kptr_restrict # /sbin/sysctl -q -n -w kernel.kptr_restrict=\"1\" # # If kernel.kptr_restrict present in /etc/sysctl.conf, change value to \"1\" # else, add \"kernel.kptr_restrict = 1\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^kernel.kptr_restrict\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"1\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^kernel.kptr_restrict\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^kernel.kptr_restrict\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "enable_execshield_settings",
        "rid": "sysctl_kernel_randomize_va_space",
        "gtitle": "Enable ExecShield",
        "fix_id": "sysctl_kernel_randomize_va_space"
      },
      "id": "enable_execshield_settings",
      "title": [
        {
          "#text": "Enable Randomized Layout of Virtual Address Space",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # # Set runtime for kernel.randomize_va_space # /sbin/sysctl -q -n -w kernel.randomize_va_space=\"2\" # # If kernel.randomize_va_space present in /etc/sysctl.conf, change value to \"2\" # else, add \"kernel.randomize_va_space = 2\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^kernel.randomize_va_space\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"2\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^kernel.randomize_va_space\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^kernel.randomize_va_space\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "endpoint_security_software",
        "rid": "configure_user_data_backups",
        "gtitle": "Endpoint Protection Software"
      },
      "id": "endpoint_security_software",
      "title": [
        {
          "#text": "Configure Backups of User Data",
          "@_lang": "en-US"
        }
      ],
      "desc": "The operating system must conduct backups of user data contained in the operating system. The operating system provides utilities for automating backups of user data. Commercial and open-source products are also available.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ensure_rsyslog_log_file_configuration",
        "rid": "rsyslog_encrypt_offload_actionsendstreamdriverauthmode",
        "gtitle": "Ensure Proper Configuration of Log Files"
      },
      "id": "ensure_rsyslog_log_file_configuration",
      "title": [
        {
          "#text": "Ensure Rsyslog Authenticates Off-Loaded Audit Records",
          "@_lang": "en-US"
        }
      ],
      "desc": "Rsyslogd is a system utility providing support for message logging. Support for both internet and UNIX domain sockets enables this utility to support both local and remote logging. Couple this utility with(which is a secure communications library implementing the SSL, TLS and DTLS protocols), and you have a method to securely encrypt and off-load auditing. When usingto off-load logs the remote system must be authenticated.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ensure_rsyslog_log_file_configuration",
        "rid": "rsyslog_encrypt_offload_actionsendstreamdrivermode",
        "gtitle": "Ensure Proper Configuration of Log Files"
      },
      "id": "ensure_rsyslog_log_file_configuration",
      "title": [
        {
          "#text": "Ensure Rsyslog Encrypts Off-Loaded Audit Records",
          "@_lang": "en-US"
        }
      ],
      "desc": "Rsyslogd is a system utility providing support for message logging. Support for both internet and UNIX domain sockets enables this utility to support both local and remote logging. Couple this utility with(which is a secure communications library implementing the SSL, TLS and DTLS protocols), and you have a method to securely encrypt and off-load auditing. When usingto off-load logs off a encrpytion system must be used.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ensure_rsyslog_log_file_configuration",
        "rid": "rsyslog_encrypt_offload_defaultnetstreamdriver",
        "gtitle": "Ensure Proper Configuration of Log Files"
      },
      "id": "ensure_rsyslog_log_file_configuration",
      "title": [
        {
          "#text": "Ensure Rsyslog Encrypts Off-Loaded Audit Records",
          "@_lang": "en-US"
        }
      ],
      "desc": "Rsyslogd is a system utility providing support for message logging. Support for both internet and UNIX domain sockets enables this utility to support both local and remote logging. Couple this utility with(which is a secure communications library implementing the SSL, TLS and DTLS protocols), and you have a method to securely encrypt and off-load auditing. When usingto off-load logs off a encrpytion system must be used.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ensure_rsyslog_log_file_configuration",
        "rid": "rsyslog_files_groupownership",
        "gtitle": "Ensure Proper Configuration of Log Files"
      },
      "id": "ensure_rsyslog_log_file_configuration",
      "title": [
        {
          "#text": "Ensure Log Files Are Owned By Appropriate Group",
          "@_lang": "en-US"
        }
      ],
      "desc": "The group-owner of all log files written byshould be. These log files are determined by the second part of each Rule line inand typically all appear in. For each log filereferenced in, run the following command to inspect the file's group owner:If the owner is not, run the following command to correct this:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ensure_rsyslog_log_file_configuration",
        "rid": "rsyslog_files_ownership",
        "gtitle": "Ensure Proper Configuration of Log Files"
      },
      "id": "ensure_rsyslog_log_file_configuration",
      "title": [
        {
          "#text": "Ensure Log Files Are Owned By Appropriate User",
          "@_lang": "en-US"
        }
      ],
      "desc": "The owner of all log files written byshould be. These log files are determined by the second part of each Rule line inand typically all appear in. For each log filereferenced in, run the following command to inspect the file's owner:If the owner is not, run the following command to correct this:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ensure_rsyslog_log_file_configuration",
        "rid": "rsyslog_files_permissions",
        "gtitle": "Ensure Proper Configuration of Log Files"
      },
      "id": "ensure_rsyslog_log_file_configuration",
      "title": [
        {
          "#text": "Ensure System Log Files Have Correct Permissions",
          "@_lang": "en-US"
        }
      ],
      "desc": "The file permissions for all log files written byshould be set to 600, or more restrictive. These log files are determined by the second part of each Rule line inand typically all appear in. For each log filereferenced in, run the following command to inspect the file's permissions:If the permissions are not 600 or more restrictive, run the following command to correct this:\"",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ensure_rsyslog_log_file_configuration",
        "rid": "rsyslog_remote_access_monitoring",
        "gtitle": "Ensure Proper Configuration of Log Files"
      },
      "id": "ensure_rsyslog_log_file_configuration",
      "title": [
        {
          "#text": "Ensure remote access methods are monitored in Rsyslog",
          "@_lang": "en-US"
        }
      ],
      "desc": "Logging of remote access methods must be implemented to help identify cyber attacks and ensure ongoing compliance with remote access policies are being audited and upheld. An examples of a remote access method is the use of the Remote Desktop Protocol (RDP) from an external, non-organization controlled network. Theorfile should contain a match for the following selectors:,, and. If not, use the following as an example configuration:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "entropy",
        "rid": "kernel_disable_entropy_contribution_for_solid_state_drives",
        "gtitle": "Protect Random-Number Entropy Pool"
      },
      "id": "entropy",
      "title": [
        {
          "#text": "Ensure Solid State Drives Do Not Contribute To Random-Number Entropy Pool",
          "@_lang": "en-US"
        }
      ],
      "desc": "For each solid-state drive on the system, run:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "files",
        "rid": "dir_perms_world_writable_sticky_bits",
        "gtitle": "Verify Permissions on Important Files and Directories"
      },
      "id": "files",
      "title": [
        {
          "#text": "Verify that All World-Writable Directories Have Sticky Bits Set",
          "@_lang": "en-US"
        }
      ],
      "desc": "When the so-called 'sticky bit' is set on a directory, only the owner of a given file may remove that file from the directory. Without the sticky bit, any user with write access to a directory may remove any file in the directory. Setting the sticky bit prevents users from removing each other's files. In cases where there is no reason for a directory to be world-writable, a better solution is to remove that permission rather than to set the sticky bit. However, if a directory is used by a particular application, consult that application's documentation instead of blindly changing modes.To set the sticky bit on a world-writable directory, run the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "files",
        "rid": "file_permissions_systemmap",
        "gtitle": "Verify Permissions on Important Files and Directories"
      },
      "id": "files",
      "title": [
        {
          "#text": "Verify that local System.map file (if exists) is readable only by root",
          "@_lang": "en-US"
        }
      ],
      "desc": "Files containing sensitive informations should be protected by restrictive permissions. Most of the time, there is no need that these files need to be read by any non-root user To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "files",
        "rid": "file_permissions_unauthorized_world_writable",
        "gtitle": "Verify Permissions on Important Files and Directories",
        "fix_id": "file_permissions_unauthorized_world_writable"
      },
      "id": "files",
      "title": [
        {
          "#text": "Ensure No World-Writable Files Exist",
          "@_lang": "en-US"
        }
      ],
      "desc": "It is generally a good idea to remove global (other) write access to a file when it is discovered. However, check with documentation for specific applications before making changes. Also, monitor for recurring world-writable files, as these may be symptoms of a misconfigured application or user account. Finally, this applies to real files and not virtual files that are a part of pseudo file systems such asor.",
      "impact": 0.5,
      "descs": {
        "fix": "find / -xdev -type f -perm -002 -exec chmod o-w {} \\;"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "files",
        "rid": "no_files_unowned_by_user",
        "gtitle": "Verify Permissions on Important Files and Directories"
      },
      "id": "files",
      "title": [
        {
          "#text": "Ensure All Files Are Owned by a User",
          "@_lang": "en-US"
        }
      ],
      "desc": "If any files are not owned by a user, then the cause of their lack of ownership should be investigated. Following this, the files should be deleted or assigned to an appropriate user. The following command will discover and print any files on local partitions which do not belong to a valid user:To search all filesystems on a system including network mounted filesystems the following command can be run manually for each partition:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "files",
        "rid": "permissions_local_var_log",
        "gtitle": "Verify Permissions on Important Files and Directories"
      },
      "id": "files",
      "title": [
        {
          "#text": "Verify permissions of log files",
          "@_lang": "en-US"
        }
      ],
      "desc": "Any operating system providing too much information in error messages risks compromising the data and security of the structure, and content of error messages needs to be carefully considered by the organization. Organizations carefully consider the structure/content of error messages. The extent to which information systems are able to identify and handle error conditions is guided by organizational policy and operational requirements. Information that could be exploited by adversaries includes, for example, erroneous logon attempts with passwords entered by mistake as the username, mission/business information that can be derived from (if not stated explicitly by) information recorded, and personal information, such as account numbers, social security numbers, and credit card numbers.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "files",
        "rid": "sysctl_fs_protected_hardlinks",
        "gtitle": "Verify Permissions on Important Files and Directories",
        "fix_id": "sysctl_fs_protected_hardlinks"
      },
      "id": "files",
      "title": [
        {
          "#text": "Enable Kernel Parameter to Enforce DAC on Hardlinks",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # # Set runtime for fs.protected_hardlinks # /sbin/sysctl -q -n -w fs.protected_hardlinks=\"1\" # # If fs.protected_hardlinks present in /etc/sysctl.conf, change value to \"1\" # else, add \"fs.protected_hardlinks = 1\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^fs.protected_hardlinks\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"1\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^fs.protected_hardlinks\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^fs.protected_hardlinks\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "files",
        "rid": "sysctl_fs_protected_symlinks",
        "gtitle": "Verify Permissions on Important Files and Directories",
        "fix_id": "sysctl_fs_protected_symlinks"
      },
      "id": "files",
      "title": [
        {
          "#text": "Enable Kernel Parameter to Enforce DAC on Symlinks",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # # Set runtime for fs.protected_symlinks # /sbin/sysctl -q -n -w fs.protected_symlinks=\"1\" # # If fs.protected_symlinks present in /etc/sysctl.conf, change value to \"1\" # else, add \"fs.protected_symlinks = 1\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^fs.protected_symlinks\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"1\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^fs.protected_symlinks\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^fs.protected_symlinks\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gid": "fips",
        "rid": "is_fips_mode_enabled",
        "gtitle": "Federal Information Processing Standard (FIPS)"
      },
      "id": "fips",
      "title": [
        {
          "#text": "Verify '/proc/sys/crypto/fips_enabled' exists",
          "@_lang": "en-US"
        }
      ],
      "desc": "On a system where FIPS 140-2 mode is enabled,must exist. To verify FIPS mode, run the following command:",
      "impact": 0.7,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ftp_configure_vsftpd",
        "rid": "ftp_configure_firewall",
        "gtitle": "Configure vsftpd to Provide FTP Service if Necessary"
      },
      "id": "ftp_configure_vsftpd",
      "title": [
        {
          "#text": "Configure Firewalls to Protect the FTP Server",
          "@_lang": "en-US"
        }
      ],
      "desc": "By default,blocks access to the ports used by the web server. To configureto allow port 21 traffic, one must editand(if IPv6 is in use). Add the following line, ensuring that it appears before the final LOG and DROP lines for the INPUT chain:Edit the file. Ensure that the space-separated list of modules contains the FTP connection tracking module:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ftp_restrict_users",
        "rid": "ftp_limit_users",
        "gtitle": "Restrict the Set of Users Allowed to Access FTP"
      },
      "id": "ftp_restrict_users",
      "title": [
        {
          "#text": "Limit Users Allowed FTP Access if Necessary",
          "@_lang": "en-US"
        }
      ],
      "desc": "If there is a mission-critical reason for users to access their accounts via the insecure FTP protocol, limit the set of users who are allowed this access. Edit the vsftpd configuration file. Add or correct the following configuration options:Edit the file. For each user USERNAME who should be allowed to access the system via FTP, add a line containing that user's name:If anonymous access is also required, add the anonymous usernames toas well.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "gnome",
        "rid": "package_gdm_removed",
        "gtitle": "GNOME Desktop Environment",
        "fix_id": "package_gdm_removed"
      },
      "id": "gnome",
      "title": [
        {
          "#text": "Remove the GDM Package Group",
          "@_lang": "en-US"
        }
      ],
      "desc": "By removing thepackage, the system no longer has GNOME installed installed. If X Windows is not installed then the system cannot boot into graphical user mode. This prevents the system from being accidentally or maliciously booted into amode. To do so, run the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'gdm3' 2&gt;/dev/null | grep -q installed; then # CAUTION: This remediation script will remove gdm3 #  from the system, and may remove any packages #  that depend on gdm3. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"gdm3\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gid": "gnome",
        "rid": "enable_dconf_user_profile",
        "gtitle": "GNOME Desktop Environment"
      },
      "id": "gnome",
      "title": [
        {
          "#text": "Configure GNOME3 DConf User Profile",
          "@_lang": "en-US"
        }
      ],
      "desc": "By default, DConf provides a standard user profile. This profile contains a list of DConf configuration databases. The user profile and database always take the highest priority. As such the DConf User profile should always exist and be configured correctly.To make sure that the user profile is configured correctly, theshould be set as follows:",
      "impact": 0.7,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "gnome_login_screen",
        "rid": "dconf_gnome_disable_user_list",
        "gtitle": "Configure GNOME Login Screen",
        "fix_id": "dconf_gnome_disable_user_list"
      },
      "id": "gnome_login_screen",
      "title": [
        {
          "#text": "Disable the GNOME3 Login User List",
          "@_lang": "en-US"
        }
      ],
      "desc": "In the default graphical environment, users logging directly into the system are greeted with a login screen that displays all known users. This functionality should be disabled by settingto.To disable, add or editto. For example:Once the setting has been added, add a lock toto prevent user modification. For example:After the settings have been set, run.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'gdm3' 2&gt;/dev/null | grep -q installed &amp;&amp; { [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; }; then # Check for setting in any of the DConf db directories # If files contain ibus or distro, ignore them. # The assignment assumes that individual filenames don't contain : readarray -t SETTINGSFILES &lt; &lt;(grep -r \"\\\\[org/gnome/login-screen\\\\]\" \"/etc/dconf/db/\" | grep -v 'distro\\|ibus' | cut -d\":\" -f1) DCONFFILE=\"/etc/dconf/db/gdm.d/00-security-settings\" DBDIR=\"/etc/dconf/db/gdm.d\" mkdir -p \"${DBDIR}\" if [ \"${#SETTINGSFILES[@]}\" -eq 0 ] then [ ! -z ${DCONFFILE} ] || echo \"\" &gt;&gt; ${DCONFFILE} printf '%s ' \"[org/gnome/login-screen]\" &gt;&gt; ${DCONFFILE} printf '%s=%s ' \"disable-user-list\" \"true\" &gt;&gt; ${DCONFFILE} else escaped_value=\"$(sed -e 's/\\\\/\\\\\\\\/g' &lt;&lt;&lt; \"true\")\" if grep -q \"^\\\\s*disable-user-list\\\\s*=\" \"${SETTINGSFILES[@]}\" then sed -i \"s/\\\\s*disable-user-list\\\\s*=\\\\s*.*/disable-user-list=${escaped_value}/g\" \"${SETTINGSFILES[@]}\" else sed -i \"\\\\|\\\\[org/gnome/login-screen\\\\]|a\\\\disable-user-list=${escaped_value}\" \"${SETTINGSFILES[@]}\" fi fi dconf update # Check for setting in any of the DConf db directories LOCKFILES=$(grep -r \"^/org/gnome/login-screen/disable-user-list$\" \"/etc/dconf/db/\" | grep -v 'distro\\|ibus' | cut -d\":\" -f1) LOCKSFOLDER=\"/etc/dconf/db/gdm.d/locks\" mkdir -p \"${LOCKSFOLDER}\" if [[ -z \"${LOCKFILES}\" ]] then echo \"/org/gnome/login-screen/disable-user-list\" &gt;&gt; \"/etc/dconf/db/gdm.d/locks/00-security-settings-lock\" fi dconf update else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gid": "gnome_login_screen",
        "rid": "gnome_gdm_disable_xdmcp",
        "gtitle": "Configure GNOME Login Screen",
        "fix_id": "gnome_gdm_disable_xdmcp"
      },
      "id": "gnome_login_screen",
      "title": [
        {
          "#text": "Disable XDMCP in GDM",
          "@_lang": "en-US"
        }
      ],
      "desc": "XDMCP is an unencrypted protocol, and therefore, presents a security risk, see e.g.. To disable XDMCP support in Gnome, settounder theconfiguration section in. For example:",
      "impact": 0.7,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'gdm3' 2&gt;/dev/null | grep -q installed; then # Try find '[xdmcp]' and 'Enable' in '/etc/gdm/custom.conf', if it exists, set # to 'false', if it isn't here, add it, if '[xdmcp]' doesn't exist, add it there if grep -qzosP '[[:space:]]*\\[xdmcp]([^ \\[]* +)+?[[:space:]]*Enable' '/etc/gdm/custom.conf'; then sed -i 's/Enable[^( )]*/Enable=false/' '/etc/gdm/custom.conf' elif grep -qs '[[:space:]]*\\[xdmcp]' '/etc/gdm/custom.conf'; then sed -i '/[[:space:]]*\\[xdmcp]/a Enable=false' '/etc/gdm/custom.conf' else if test -d \"/etc/gdm\"; then printf '%s ' '[xdmcp]' 'Enable=false' &gt;&gt; '/etc/gdm/custom.conf' else echo \"Config file directory '/etc/gdm' doesnt exist, not remediating, assuming non-applicability.\" &gt;&amp;2 fi fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "gnome_screen_locking",
        "rid": "dconf_gnome_screensaver_lock_enabled",
        "gtitle": "Configure GNOME Screen Locking"
      },
      "id": "gnome_screen_locking",
      "title": [
        {
          "#text": "Enable GNOME3 Screensaver Lock After Idle Period",
          "@_lang": "en-US"
        }
      ],
      "desc": "To activate locking of the screensaver in the GNOME3 desktop when it is activated, add or settoin. For example:Once the settings have been added, add a lock toto prevent user modification. For example:After the settings have been set, run.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gid": "gnome_system_settings",
        "rid": "dconf_gnome_disable_ctrlaltdel_reboot",
        "gtitle": "GNOME System Settings",
        "fix_id": "dconf_gnome_disable_ctrlaltdel_reboot"
      },
      "id": "gnome_system_settings",
      "title": [
        {
          "#text": "Disable Ctrl-Alt-Del Reboot Key Sequence in GNOME3",
          "@_lang": "en-US"
        }
      ],
      "desc": "By default,will reboot the system if thekey sequence is pressed.To configure the system to ignore thekey sequence from the Graphical User Interface (GUI) instead of rebooting the system, add or settoin. For example:Once the settings have been added, add a lock toto prevent user modification. For example:After the settings have been set, run.",
      "impact": 0.7,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'gdm3' 2&gt;/dev/null | grep -q installed &amp;&amp; { [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; }; then # Check for setting in any of the DConf db directories # If files contain ibus or distro, ignore them. # The assignment assumes that individual filenames don't contain : readarray -t SETTINGSFILES &lt; &lt;(grep -r \"\\\\[org/gnome/settings-daemon/plugins/media-keys\\\\]\" \"/etc/dconf/db/\" | grep -v 'distro\\|ibus' | cut -d\":\" -f1) DCONFFILE=\"/etc/dconf/db/local.d/00-security-settings\" DBDIR=\"/etc/dconf/db/local.d\" mkdir -p \"${DBDIR}\" if [ \"${#SETTINGSFILES[@]}\" -eq 0 ] then [ ! -z ${DCONFFILE} ] || echo \"\" &gt;&gt; ${DCONFFILE} printf '%s ' \"[org/gnome/settings-daemon/plugins/media-keys]\" &gt;&gt; ${DCONFFILE} printf '%s=%s ' \"logout\" \"''\" &gt;&gt; ${DCONFFILE} else escaped_value=\"$(sed -e 's/\\\\/\\\\\\\\/g' &lt;&lt;&lt; \"''\")\" if grep -q \"^\\\\s*logout\\\\s*=\" \"${SETTINGSFILES[@]}\" then sed -i \"s/\\\\s*logout\\\\s*=\\\\s*.*/logout=${escaped_value}/g\" \"${SETTINGSFILES[@]}\" else sed -i \"\\\\|\\\\[org/gnome/settings-daemon/plugins/media-keys\\\\]|a\\\\logout=${escaped_value}\" \"${SETTINGSFILES[@]}\" fi fi dconf update # Check for setting in any of the DConf db directories LOCKFILES=$(grep -r \"^/org/gnome/settings-daemon/plugins/media-keys/logout$\" \"/etc/dconf/db/\" | grep -v 'distro\\|ibus' | cut -d\":\" -f1) LOCKSFOLDER=\"/etc/dconf/db/local.d/locks\" mkdir -p \"${LOCKSFOLDER}\" if [[ -z \"${LOCKFILES}\" ]] then echo \"/org/gnome/settings-daemon/plugins/media-keys/logout\" &gt;&gt; \"/etc/dconf/db/local.d/locks/00-security-settings-lock\" fi dconf update else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "gui_login_banner",
        "rid": "dconf_gnome_banner_enabled",
        "gtitle": "Implement a GUI Warning Banner",
        "fix_id": "dconf_gnome_banner_enabled"
      },
      "id": "gui_login_banner",
      "title": [
        {
          "#text": "Enable GNOME3 Login Warning Banner",
          "@_lang": "en-US"
        }
      ],
      "desc": "In the default graphical environment, displaying a login warning banner in the GNOME Display Manager's login screen can be enabled on the login screen by settingto.To enable, add or editto. For example:Once the setting has been added, add a lock toto prevent user modification. For example:After the settings have been set, run. The banner text must also be set.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'gdm3' 2&gt;/dev/null | grep -q installed; then # Check for setting in any of the DConf db directories # If files contain ibus or distro, ignore them. # The assignment assumes that individual filenames don't contain : readarray -t SETTINGSFILES &lt; &lt;(grep -r \"\\\\[org/gnome/login-screen\\\\]\" \"/etc/dconf/db/\" | grep -v 'distro\\|ibus' | cut -d\":\" -f1) DCONFFILE=\"/etc/dconf/db/gdm.d/00-security-settings\" DBDIR=\"/etc/dconf/db/gdm.d\" mkdir -p \"${DBDIR}\" if [ \"${#SETTINGSFILES[@]}\" -eq 0 ] then [ ! -z ${DCONFFILE} ] || echo \"\" &gt;&gt; ${DCONFFILE} printf '%s ' \"[org/gnome/login-screen]\" &gt;&gt; ${DCONFFILE} printf '%s=%s ' \"banner-message-enable\" \"true\" &gt;&gt; ${DCONFFILE} else escaped_value=\"$(sed -e 's/\\\\/\\\\\\\\/g' &lt;&lt;&lt; \"true\")\" if grep -q \"^\\\\s*banner-message-enable\\\\s*=\" \"${SETTINGSFILES[@]}\" then sed -i \"s/\\\\s*banner-message-enable\\\\s*=\\\\s*.*/banner-message-enable=${escaped_value}/g\" \"${SETTINGSFILES[@]}\" else sed -i \"\\\\|\\\\[org/gnome/login-screen\\\\]|a\\\\banner-message-enable=${escaped_value}\" \"${SETTINGSFILES[@]}\" fi fi dconf update # Check for setting in any of the DConf db directories LOCKFILES=$(grep -r \"^/org/gnome/login-screen/banner-message-enable$\" \"/etc/dconf/db/\" | grep -v 'distro\\|ibus' | cut -d\":\" -f1) LOCKSFOLDER=\"/etc/dconf/db/gdm.d/locks\" mkdir -p \"${LOCKSFOLDER}\" if [[ -z \"${LOCKFILES}\" ]] then echo \"/org/gnome/login-screen/banner-message-enable\" &gt;&gt; \"/etc/dconf/db/gdm.d/locks/00-security-settings-lock\" fi dconf update else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "gui_login_banner",
        "rid": "dconf_gnome_login_banner_text",
        "gtitle": "Implement a GUI Warning Banner"
      },
      "id": "gui_login_banner",
      "title": [
        {
          "#text": "Set the GNOME3 Login Warning Banner Text",
          "@_lang": "en-US"
        }
      ],
      "desc": "In the default graphical environment, configuring the login warning banner text in the GNOME Display Manager's login screen can be configured on the login screen by settingtowhereis the approved banner for your environment.To enable, add or editto. For example:Once the setting has been added, add a lock toto prevent user modification. For example:After the settings have been set, run. When entering a warning banner that spans several lines, remember to begin and end the string withand usefor new lines.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "inetd_and_xinetd",
        "rid": "package_xinetd_removed",
        "gtitle": "Xinetd",
        "fix_id": "package_xinetd_removed"
      },
      "id": "inetd_and_xinetd",
      "title": [
        {
          "#text": "Uninstall xinetd Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be removed with the following command:",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # CAUTION: This remediation script will remove xinetd #  from the system, and may remove any packages #  that depend on xinetd. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"xinetd\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "integrity",
        "rid": "disable_prelink",
        "gtitle": "System and Software Integrity",
        "fix_id": "disable_prelink"
      },
      "id": "integrity",
      "title": [
        {
          "#text": "Disable Prelinking",
          "@_lang": "en-US"
        }
      ],
      "desc": "The prelinking feature changes binaries in an attempt to decrease their startup time. In order to disable it, change or add the following line inside the file:Next, run the following command to return binaries to a normal, non-prelinked state:",
      "impact": 0.5,
      "descs": {
        "fix": "# prelink not installed if test -e /etc/sysconfig/prelink -o -e /usr/sbin/prelink; then if grep -q ^PRELINKING /etc/sysconfig/prelink then sed -i 's/^PRELINKING[:blank:]*=[:blank:]*[:alpha:]*/PRELINKING=no/' /etc/sysconfig/prelink else printf ' ' &gt;&gt; /etc/sysconfig/prelink printf '%s ' '# Set PRELINKING=no per security requirements' 'PRELINKING=no' &gt;&gt; /etc/sysconfig/prelink fi # Undo previous prelink changes to binaries if prelink is available. if test -x /usr/sbin/prelink; then /usr/sbin/prelink -ua fi fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "iptables_activation",
        "rid": "service_ip6tables_enabled",
        "gtitle": "Inspect and Activate Default Rules",
        "fix_id": "service_ip6tables_enabled"
      },
      "id": "iptables_activation",
      "title": [
        {
          "#text": "Verify ip6tables Enabled if Using IPv6",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice can be enabled with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" unmask 'ip6tables.service' \"$SYSTEMCTL_EXEC\" start 'ip6tables.service' \"$SYSTEMCTL_EXEC\" enable 'ip6tables.service' else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "iptables_activation",
        "rid": "service_iptables_enabled",
        "gtitle": "Inspect and Activate Default Rules",
        "fix_id": "service_iptables_enabled"
      },
      "id": "iptables_activation",
      "title": [
        {
          "#text": "Verify iptables Enabled",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice can be enabled with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" unmask 'iptables.service' \"$SYSTEMCTL_EXEC\" start 'iptables.service' \"$SYSTEMCTL_EXEC\" enable 'iptables.service' else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "iptables_activation",
        "rid": "set_ip6tables_default_rule",
        "gtitle": "Inspect and Activate Default Rules",
        "fix_id": "set_ip6tables_default_rule"
      },
      "id": "iptables_activation",
      "title": [
        {
          "#text": "Set Default ip6tables Policy for Incoming Packets",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the default policy to DROP (instead of ACCEPT) for the built-in INPUT chain which processes incoming packets, add or correct the following line in:If changes were required, reload the ip6tables rules:",
      "impact": 0.5,
      "descs": {
        "fix": "sed -i 's/^:INPUT ACCEPT.*/:INPUT DROP [0:0]/g' /etc/sysconfig/ip6tables"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "iptables_ruleset_modifications",
        "rid": "set_iptables_default_rule",
        "gtitle": "Strengthen the Default Ruleset",
        "fix_id": "set_iptables_default_rule"
      },
      "id": "iptables_ruleset_modifications",
      "title": [
        {
          "#text": "Set Default iptables Policy for Incoming Packets",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the default policy to DROP (instead of ACCEPT) for the built-in INPUT chain which processes incoming packets, add or correct the following line in:",
      "impact": 0.5,
      "descs": {
        "fix": "sed -i 's/^:INPUT ACCEPT.*/:INPUT DROP [0:0]/g' /etc/sysconfig/iptables"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "iptables_ruleset_modifications",
        "rid": "set_iptables_default_rule_forward",
        "gtitle": "Strengthen the Default Ruleset",
        "fix_id": "set_iptables_default_rule_forward"
      },
      "id": "iptables_ruleset_modifications",
      "title": [
        {
          "#text": "Set Default iptables Policy for Forwarded Packets",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the default policy to DROP (instead of ACCEPT) for the built-in FORWARD chain which processes packets that will be forwarded from one interface to another, add or correct the following line in:",
      "impact": 0.5,
      "descs": {
        "fix": "sed -i 's/^:FORWARD ACCEPT.*/:FORWARD DROP [0:0]/g' /etc/sysconfig/iptables"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "kerberos",
        "rid": "kerberos_disable_no_keytab",
        "gtitle": "Kerberos",
        "fix_id": "kerberos_disable_no_keytab"
      },
      "id": "kerberos",
      "title": [
        {
          "#text": "Disable Kerberos by removing host keytab",
          "@_lang": "en-US"
        }
      ],
      "desc": "Kerberos is not an approved key distribution method for Common Criteria. To prevent using Kerberos by system daemons, remove the Kerberos keytab files, especially.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then rm -f /etc/*.keytab else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "locking_out_password_attempts",
        "rid": "accounts_password_pam_pwhistory_remember",
        "gtitle": "Set Lockouts for Failed Password Attempts"
      },
      "id": "locking_out_password_attempts",
      "title": [
        {
          "#text": "Limit Password Reuse",
          "@_lang": "en-US"
        }
      ],
      "desc": "Do not allow users to reuse recent passwords. This can be accomplished by using theoption for thePAM modules.In the file, make sure the parametersandare present, and that the value for theparameter isor greater. For example:The DoD STIG requirement is 5 passwords.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "locking_out_password_attempts",
        "rid": "accounts_password_pam_unix_remember",
        "gtitle": "Set Lockouts for Failed Password Attempts",
        "fix_id": "accounts_password_pam_unix_remember"
      },
      "id": "locking_out_password_attempts",
      "title": [
        {
          "#text": "Limit Password Reuse",
          "@_lang": "en-US"
        }
      ],
      "desc": "Do not allow users to reuse recent passwords. This can be accomplished by using theoption for theorPAM modules.In the file, appendto the line which refers to theormodule, as shown below:The DoD STIG requirement is 5 passwords.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'libpam-runtime' 2&gt;/dev/null | grep -q installed; then var_password_pam_unix_remember=\"\" if [ -e \"/etc/pam.d/common-password\" ] ; then valueRegex=\"$var_password_pam_unix_remember\" defaultValue=\"$var_password_pam_unix_remember\" # non-empty values need to be preceded by an equals sign [ -n \"${valueRegex}\" ] &amp;&amp; valueRegex=\"=${valueRegex}\" # add an equals sign to non-empty values [ -n \"${defaultValue}\" ] &amp;&amp; defaultValue=\"=${defaultValue}\" # fix 'type' if it's wrong if grep -q -P \"^\\\\s*(?\"'!'\"password\\\\s)[[:alnum:]]+\\\\s+[[:alnum:]]+\\\\s+pam_unix.so\" &lt; \"/etc/pam.d/common-password\" ; then sed --follow-symlinks -i -E -e \"s/^(\\\\s*)[[:alnum:]]+(\\\\s+[[:alnum:]]+\\\\s+pam_unix.so)/\\\\1password\\\\2/\" \"/etc/pam.d/common-password\" fi # fix 'control' if it's wrong if grep -q -P \"^\\\\s*password\\\\s+(?\"'!'\"[success=1 default=ignore])[[:alnum:]]+\\\\s+pam_unix.so\" &lt; \"/etc/pam.d/common-password\" ; then sed --follow-symlinks -i -E -e \"s/^(\\\\s*password\\\\s+)[[:alnum:]]+(\\\\s+pam_unix.so)/\\\\1[success=1 default=ignore]\\\\2/\" \"/etc/pam.d/common-password\" fi # fix the value for 'option' if one exists but does not match 'valueRegex' if grep -q -P \"^\\\\s*password\\\\s+[success=1 default=ignore]\\\\s+pam_unix.so(\\\\s.+)?\\\\s+obsecure sha512 shadow remember(?\"'!'\"${valueRegex}(\\\\s|\\$))\" &lt; \"/etc/pam.d/common-password\" ; then sed --follow-symlinks -i -E -e \"s/^(\\\\s*password\\\\s+[success=1 default=ignore]\\\\s+pam_unix.so(\\\\s.+)?\\\\s)obsecure sha512 shadow remember=[^[:space:]]*/\\\\1obsecure sha512 shadow remember${defaultValue}/\" \"/etc/pam.d/common-password\" # add 'option=default' if option is not set elif grep -q -E \"^\\\\s*password\\\\s+[success=1 default=ignore]\\\\s+pam_unix.so\" &lt; \"/etc/pam.d/common-password\" &amp;&amp; grep -E \"^\\\\s*password\\\\s+[success=1 default=ignore]\\\\s+pam_unix.so\" &lt; \"/etc/pam.d/common-password\" | grep -q -E -v \"\\\\sobsecure sha512 shadow remember(=|\\\\s|\\$)\" ; then sed --follow-symlinks -i -E -e \"s/^(\\\\s*password\\\\s+[success=1 default=ignore]\\\\s+pam_unix.so[^\\ ]*)/\\\\1 obsecure sha512 shadow remember${defaultValue}/\" \"/etc/pam.d/common-password\" # add a new entry if none exists elif ! grep -q -P \"^\\\\s*password\\\\s+[success=1 default=ignore]\\\\s+pam_unix.so(\\\\s.+)?\\\\s+obsecure sha512 shadow remember${valueRegex}(\\\\s|\\$)\" &lt; \"/etc/pam.d/common-password\" ; then echo \"password [success=1 default=ignore] pam_unix.so obsecure sha512 shadow remember${defaultValue}\" &gt;&gt; \"/etc/pam.d/common-password\" fi else echo \"/etc/pam.d/common-password doesn't exist\" &gt;&amp;2 fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "locking_out_password_attempts",
        "rid": "accounts_passwords_pam_faildelay_delay",
        "gtitle": "Set Lockouts for Failed Password Attempts",
        "fix_id": "accounts_passwords_pam_faildelay_delay"
      },
      "id": "locking_out_password_attempts",
      "title": [
        {
          "#text": "Enforce Delay After Failed Logon Attempts",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure the system to introduce a delay after failed logon attempts, add or correct thesettings into make sure itsparameter is at leastor greater. For example:",
      "impact": 0.5,
      "descs": {
        "fix": "var_password_pam_delay=\"\" if [ -e \"/etc/pam.d/common-auth\" ] ; then valueRegex=\"$var_password_pam_delay\" defaultValue=\"$var_password_pam_delay\" # non-empty values need to be preceded by an equals sign [ -n \"${valueRegex}\" ] &amp;&amp; valueRegex=\"=${valueRegex}\" # add an equals sign to non-empty values [ -n \"${defaultValue}\" ] &amp;&amp; defaultValue=\"=${defaultValue}\" # fix 'type' if it's wrong if grep -q -P \"^\\\\s*(?\"'!'\"auth\\\\s)[[:alnum:]]+\\\\s+[[:alnum:]]+\\\\s+pam_faildelay.so\" &lt; \"/etc/pam.d/common-auth\" ; then sed --follow-symlinks -i -E -e \"s/^(\\\\s*)[[:alnum:]]+(\\\\s+[[:alnum:]]+\\\\s+pam_faildelay.so)/\\\\1auth\\\\2/\" \"/etc/pam.d/common-auth\" fi # fix 'control' if it's wrong if grep -q -P \"^\\\\s*auth\\\\s+(?\"'!'\"required)[[:alnum:]]+\\\\s+pam_faildelay.so\" &lt; \"/etc/pam.d/common-auth\" ; then sed --follow-symlinks -i -E -e \"s/^(\\\\s*auth\\\\s+)[[:alnum:]]+(\\\\s+pam_faildelay.so)/\\\\1required\\\\2/\" \"/etc/pam.d/common-auth\" fi # fix the value for 'option' if one exists but does not match 'valueRegex' if grep -q -P \"^\\\\s*auth\\\\s+required\\\\s+pam_faildelay.so(\\\\s.+)?\\\\s+delay(?\"'!'\"${valueRegex}(\\\\s|\\$))\" &lt; \"/etc/pam.d/common-auth\" ; then sed --follow-symlinks -i -E -e \"s/^(\\\\s*auth\\\\s+required\\\\s+pam_faildelay.so(\\\\s.+)?\\\\s)delay=[^[:space:]]*/\\\\1delay${defaultValue}/\" \"/etc/pam.d/common-auth\" # add 'option=default' if option is not set elif grep -q -E \"^\\\\s*auth\\\\s+required\\\\s+pam_faildelay.so\" &lt; \"/etc/pam.d/common-auth\" &amp;&amp; grep -E \"^\\\\s*auth\\\\s+required\\\\s+pam_faildelay.so\" &lt; \"/etc/pam.d/common-auth\" | grep -q -E -v \"\\\\sdelay(=|\\\\s|\\$)\" ; then sed --follow-symlinks -i -E -e \"s/^(\\\\s*auth\\\\s+required\\\\s+pam_faildelay.so[^\\ ]*)/\\\\1 delay${defaultValue}/\" \"/etc/pam.d/common-auth\" # add a new entry if none exists elif ! grep -q -P \"^\\\\s*auth\\\\s+required\\\\s+pam_faildelay.so(\\\\s.+)?\\\\s+delay${valueRegex}(\\\\s|\\$)\" &lt; \"/etc/pam.d/common-auth\" ; then echo \"auth required pam_faildelay.so delay${defaultValue}\" &gt;&gt; \"/etc/pam.d/common-auth\" fi else echo \"/etc/pam.d/common-auth doesn't exist\" &gt;&amp;2 fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "locking_out_password_attempts",
        "rid": "accounts_passwords_pam_tally2",
        "gtitle": "Set Lockouts for Failed Password Attempts",
        "fix_id": "accounts_passwords_pam_tally2"
      },
      "id": "locking_out_password_attempts",
      "title": [
        {
          "#text": "Set Deny For Failed Password Attempts",
          "@_lang": "en-US"
        }
      ],
      "desc": "The Ubuntu 20.04 operating system must lock an account after - at most -consecutive invalid access attempts.",
      "impact": 0.5,
      "descs": {
        "fix": "var_password_pam_tally2=\"\" # Use a non-number regexp to force update of the value of the deny option if [ -e \"/etc/pam.d/common-auth\" ] ; then valueRegex=\"X\" defaultValue=\"${var_password_pam_tally2}\" # non-empty values need to be preceded by an equals sign [ -n \"${valueRegex}\" ] &amp;&amp; valueRegex=\"=${valueRegex}\" # add an equals sign to non-empty values [ -n \"${defaultValue}\" ] &amp;&amp; defaultValue=\"=${defaultValue}\" # fix 'type' if it's wrong if grep -q -P \"^\\\\s*(?\"'!'\"auth\\\\s)[[:alnum:]]+\\\\s+[[:alnum:]]+\\\\s+pam_tally2.so\" &lt; \"/etc/pam.d/common-auth\" ; then sed --follow-symlinks -i -E -e \"s/^(\\\\s*)[[:alnum:]]+(\\\\s+[[:alnum:]]+\\\\s+pam_tally2.so)/\\\\1auth\\\\2/\" \"/etc/pam.d/common-auth\" fi # fix 'control' if it's wrong if grep -q -P \"^\\\\s*auth\\\\s+(?\"'!'\"required)[[:alnum:]]+\\\\s+pam_tally2.so\" &lt; \"/etc/pam.d/common-auth\" ; then sed --follow-symlinks -i -E -e \"s/^(\\\\s*auth\\\\s+)[[:alnum:]]+(\\\\s+pam_tally2.so)/\\\\1required\\\\2/\" \"/etc/pam.d/common-auth\" fi # fix the value for 'option' if one exists but does not match 'valueRegex' if grep -q -P \"^\\\\s*auth\\\\s+required\\\\s+pam_tally2.so(\\\\s.+)?\\\\s+deny(?\"'!'\"${valueRegex}(\\\\s|\\$))\" &lt; \"/etc/pam.d/common-auth\" ; then sed --follow-symlinks -i -E -e \"s/^(\\\\s*auth\\\\s+required\\\\s+pam_tally2.so(\\\\s.+)?\\\\s)deny=[^[:space:]]*/\\\\1deny${defaultValue}/\" \"/etc/pam.d/common-auth\" # add 'option=default' if option is not set elif grep -q -E \"^\\\\s*auth\\\\s+required\\\\s+pam_tally2.so\" &lt; \"/etc/pam.d/common-auth\" &amp;&amp; grep -E \"^\\\\s*auth\\\\s+required\\\\s+pam_tally2.so\" &lt; \"/etc/pam.d/common-auth\" | grep -q -E -v \"\\\\sdeny(=|\\\\s|\\$)\" ; then sed --follow-symlinks -i -E -e \"s/^(\\\\s*auth\\\\s+required\\\\s+pam_tally2.so[^\\ ]*)/\\\\1 deny${defaultValue}/\" \"/etc/pam.d/common-auth\" # add a new entry if none exists elif ! grep -q -P \"^\\\\s*auth\\\\s+required\\\\s+pam_tally2.so(\\\\s.+)?\\\\s+deny${valueRegex}(\\\\s|\\$)\" &lt; \"/etc/pam.d/common-auth\" ; then echo \"auth required pam_tally2.so deny${defaultValue}\" &gt;&gt; \"/etc/pam.d/common-auth\" fi else echo \"/etc/pam.d/common-auth doesn't exist\" &gt;&amp;2 fi if [ -e \"/etc/pam.d/common-auth\" ] ; then valueRegex=\"(fail)\" defaultValue=\"fail\" # non-empty values need to be preceded by an equals sign [ -n \"${valueRegex}\" ] &amp;&amp; valueRegex=\"=${valueRegex}\" # add an equals sign to non-empty values [ -n \"${defaultValue}\" ] &amp;&amp; defaultValue=\"=${defaultValue}\" # fix 'type' if it's wrong if grep -q -P \"^\\\\s*(?\"'!'\"auth\\\\s)[[:alnum:]]+\\\\s+[[:alnum:]]+\\\\s+pam_tally2.so\" &lt; \"/etc/pam.d/common-auth\" ; then sed --follow-symlinks -i -E -e \"s/^(\\\\s*)[[:alnum:]]+(\\\\s+[[:alnum:]]+\\\\s+pam_tally2.so)/\\\\1auth\\\\2/\" \"/etc/pam.d/common-auth\" fi # fix 'control' if it's wrong if grep -q -P \"^\\\\s*auth\\\\s+(?\"'!'\"required)[[:alnum:]]+\\\\s+pam_tally2.so\" &lt; \"/etc/pam.d/common-auth\" ; then sed --follow-symlinks -i -E -e \"s/^(\\\\s*auth\\\\s+)[[:alnum:]]+(\\\\s+pam_tally2.so)/\\\\1required\\\\2/\" \"/etc/pam.d/common-auth\" fi # fix the value for 'option' if one exists but does not match 'valueRegex' if grep -q -P \"^\\\\s*auth\\\\s+required\\\\s+pam_tally2.so(\\\\s.+)?\\\\s+onerr(?\"'!'\"${valueRegex}(\\\\s|\\$))\" &lt; \"/etc/pam.d/common-auth\" ; then sed --follow-symlinks -i -E -e \"s/^(\\\\s*auth\\\\s+required\\\\s+pam_tally2.so(\\\\s.+)?\\\\s)onerr=[^[:space:]]*/\\\\1onerr${defaultValue}/\" \"/etc/pam.d/common-auth\" # add 'option=default' if option is not set elif grep -q -E \"^\\\\s*auth\\\\s+required\\\\s+pam_tally2.so\" &lt; \"/etc/pam.d/common-auth\" &amp;&amp; grep -E \"^\\\\s*auth\\\\s+required\\\\s+pam_tally2.so\" &lt; \"/etc/pam.d/common-auth\" | grep -q -E -v \"\\\\sonerr(=|\\\\s|\\$)\" ; then sed --follow-symlinks -i -E -e \"s/^(\\\\s*auth\\\\s+required\\\\s+pam_tally2.so[^\\ ]*)/\\\\1 onerr${defaultValue}/\" \"/etc/pam.d/common-auth\" # add a new entry if none exists elif ! grep -q -P \"^\\\\s*auth\\\\s+required\\\\s+pam_tally2.so(\\\\s.+)?\\\\s+onerr${valueRegex}(\\\\s|\\$)\" &lt; \"/etc/pam.d/common-auth\" ; then echo \"auth required pam_tally2.so onerr${defaultValue}\" &gt;&gt; \"/etc/pam.d/common-auth\" fi else echo \"/etc/pam.d/common-auth doesn't exist\" &gt;&amp;2 fi if [ -e \"/etc/pam.d/common-account\" ] ; then valueRegex=\"\" defaultValue=\"\" # non-empty values need to be preceded by an equals sign [ -n \"${valueRegex}\" ] &amp;&amp; valueRegex=\"=${valueRegex}\" # add an equals sign to non-empty values [ -n \"${defaultValue}\" ] &amp;&amp; defaultValue=\"=${defaultValue}\" # fix 'type' if it's wrong if grep -q -P \"^\\\\s*(?\"'!'\"account\\\\s)[[:alnum:]]+\\\\s+[[:alnum:]]+\\\\s+pam_tally2.so\" &lt; \"/etc/pam.d/common-account\" ; then sed --follow-symlinks -i -E -e \"s/^(\\\\s*)[[:alnum:]]+(\\\\s+[[:alnum:]]+\\\\s+pam_tally2.so)/\\\\1account\\\\2/\" \"/etc/pam.d/common-account\" fi # fix 'control' if it's wrong if grep -q -P \"^\\\\s*account\\\\s+(?\"'!'\"required)[[:alnum:]]+\\\\s+pam_tally2.so\" &lt; \"/etc/pam.d/common-account\" ; then sed --follow-symlinks -i -E -e \"s/^(\\\\s*account\\\\s+)[[:alnum:]]+(\\\\s+pam_tally2.so)/\\\\1required\\\\2/\" \"/etc/pam.d/common-account\" fi # fix the value for 'option' if one exists but does not match 'valueRegex' if grep -q -P \"^\\\\s*account\\\\s+required\\\\s+pam_tally2.so(\\\\s.+)?\\\\s+(?\"'!'\"${valueRegex}(\\\\s|\\$))\" &lt; \"/etc/pam.d/common-account\" ; then sed --follow-symlinks -i -E -e \"s/^(\\\\s*account\\\\s+required\\\\s+pam_tally2.so(\\\\s.+)?\\\\s)=[^[:space:]]*/\\\\1${defaultValue}/\" \"/etc/pam.d/common-account\" # add 'option=default' if option is not set elif grep -q -E \"^\\\\s*account\\\\s+required\\\\s+pam_tally2.so\" &lt; \"/etc/pam.d/common-account\" &amp;&amp; grep -E \"^\\\\s*account\\\\s+required\\\\s+pam_tally2.so\" &lt; \"/etc/pam.d/common-account\" | grep -q -E -v \"\\\\s(=|\\\\s|\\$)\" ; then sed --follow-symlinks -i -E -e \"s/^(\\\\s*account\\\\s+required\\\\s+pam_tally2.so[^\\ ]*)/\\\\1 ${defaultValue}/\" \"/etc/pam.d/common-account\" # add a new entry if none exists elif ! grep -q -P \"^\\\\s*account\\\\s+required\\\\s+pam_tally2.so(\\\\s.+)?\\\\s+${valueRegex}(\\\\s|\\$)\" &lt; \"/etc/pam.d/common-account\" ; then echo \"account required pam_tally2.so ${defaultValue}\" &gt;&gt; \"/etc/pam.d/common-account\" fi else echo \"/etc/pam.d/common-account doesn't exist\" &gt;&amp;2 fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "log_rotation",
        "rid": "ensure_logrotate_activated",
        "gtitle": "Ensure All Logs are Rotated by logrotate",
        "fix_id": "ensure_logrotate_activated"
      },
      "id": "log_rotation",
      "title": [
        {
          "#text": "Ensure Logrotate Runs Periodically",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theutility allows for the automatic rotation of log files. The frequency of rotation is specified in, which triggers a cron task. To configure logrotate to run daily, add or correct the following line in:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then LOGROTATE_CONF_FILE=\"/etc/logrotate.conf\" CRON_DAILY_LOGROTATE_FILE=\"/etc/cron.daily/logrotate\" # daily rotation is configured grep -q \"^daily$\" $LOGROTATE_CONF_FILE|| echo \"daily\" &gt;&gt; $LOGROTATE_CONF_FILE # remove any line configuring weekly, monthly or yearly rotation sed -i '/^\\s*\\(weekly\\|monthly\\|yearly\\).*$/d' $LOGROTATE_CONF_FILE # configure cron.daily if not already if ! grep -q \"^[[:space:]]*/usr/sbin/logrotate[[:alnum:][:blank:][:punct:]]*$LOGROTATE_CONF_FILE$\" $CRON_DAILY_LOGROTATE_FILE; then  echo \"#!/bin/sh\" &gt; $CRON_DAILY_LOGROTATE_FILE  echo \"/usr/sbin/logrotate $LOGROTATE_CONF_FILE\" &gt;&gt; $CRON_DAILY_LOGROTATE_FILE fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "logging",
        "rid": "package_rsyslog_installed",
        "gtitle": "Configure Syslog",
        "fix_id": "package_rsyslog_installed"
      },
      "id": "logging",
      "title": [
        {
          "#text": "Ensure rsyslog is Installed",
          "@_lang": "en-US"
        }
      ],
      "desc": "Rsyslog is installed by default. Thepackage can be installed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"rsyslog\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "logging",
        "rid": "service_rsyslog_enabled",
        "gtitle": "Configure Syslog",
        "fix_id": "service_rsyslog_enabled"
      },
      "id": "logging",
      "title": [
        {
          "#text": "Enable rsyslog Service",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice provides syslog-style logging by default on Ubuntu 20.04. Theservice can be enabled with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" unmask 'rsyslog.service' \"$SYSTEMCTL_EXEC\" start 'rsyslog.service' \"$SYSTEMCTL_EXEC\" enable 'rsyslog.service' else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gid": "logging",
        "rid": "ensure_rtc_utc_configuration",
        "gtitle": "Configure Syslog",
        "fix_id": "ensure_rtc_utc_configuration"
      },
      "id": "logging",
      "title": [
        {
          "#text": "Ensure real-time clock is set to UTC",
          "@_lang": "en-US"
        }
      ],
      "desc": "Ensure that the system real-time clock (RTC) is set to Coordinated Universal Time (UTC).",
      "impact": 0.7,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if timedatectl status | grep -i \"time zone\" | grep -iv 'UTC\\|GMT'; then timedatectl set-timezone UTC fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "mcafee_hbss_software",
        "rid": "package_MFEhiplsm_installed",
        "gtitle": "McAfee Host-Based Intrusion Detection Software (HBSS)",
        "fix_id": "package_MFEhiplsm_installed"
      },
      "id": "mcafee_hbss_software",
      "title": [
        {
          "#text": "Install the Host Intrusion Prevention System (HIPS) Module",
          "@_lang": "en-US"
        }
      ],
      "desc": "Install the McAfee Host Intrusion Prevention System (HIPS) Module if it is absolutely necessary. If SELinux is enabled, do not install or enable this module.",
      "impact": 0.5,
      "descs": {
        "fix": "[[packages]] name = \"MFEhiplsm\" version = \"*\""
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "mounting",
        "rid": "service_autofs_disabled",
        "gtitle": "Restrict Dynamic Mounting and Unmounting of Filesystems",
        "fix_id": "service_autofs_disabled"
      },
      "id": "mounting",
      "title": [
        {
          "#text": "Disable the Automounter",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thedaemon mounts and unmounts filesystems, such as user home directories shared via NFS, on demand. In addition, autofs can be used to handle removable media, and the default configuration provides the cdrom device as. However, this method of providing access to removable media is not common, so autofs can almost always be disabled if NFS is not in use. Even if NFS is required, it may be possible to configure filesystem mounts statically by editingrather than relying on the automounter.Theservice can be disabled with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" stop 'autofs.service' \"$SYSTEMCTL_EXEC\" disable 'autofs.service' \"$SYSTEMCTL_EXEC\" mask 'autofs.service' # Disable socket activation if we have a unit file for it if \"$SYSTEMCTL_EXEC\" list-unit-files | grep -q '^autofs.socket'; then \"$SYSTEMCTL_EXEC\" stop 'autofs.socket' \"$SYSTEMCTL_EXEC\" mask 'autofs.socket' fi # The service may not be running because it has been started and failed, # so let's reset the state so OVAL checks pass. # Service should be 'inactive', not 'failed' after reboot though. \"$SYSTEMCTL_EXEC\" reset-failed 'autofs.service' || true else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "mounting",
        "rid": "kernel_module_cramfs_disabled",
        "gtitle": "Restrict Dynamic Mounting and Unmounting of Filesystems",
        "fix_id": "kernel_module_cramfs_disabled"
      },
      "id": "mounting",
      "title": [
        {
          "#text": "Disable Mounting of cramfs",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure the system to prevent thekernel module from being loaded, add the following line to a file in the directory:This effectively prevents usage of this uncommon filesystem. Thefilesystem type is a compressed read-only Linux filesystem embedded in small footprint systems. Aimage can be used without having to first decompress the image.",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if LC_ALL=C grep -q -m 1 \"^install cramfs\" /etc/modprobe.d/cramfs.conf ; then    sed -i 's#^install cramfs.*#install cramfs /bin/true#g' /etc/modprobe.d/cramfs.conf else  echo -e \" # Disable per security requirements\" &gt;&gt; /etc/modprobe.d/cramfs.conf  echo \"install cramfs /bin/true\" &gt;&gt; /etc/modprobe.d/cramfs.conf fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "mounting",
        "rid": "kernel_module_freevxfs_disabled",
        "gtitle": "Restrict Dynamic Mounting and Unmounting of Filesystems",
        "fix_id": "kernel_module_freevxfs_disabled"
      },
      "id": "mounting",
      "title": [
        {
          "#text": "Disable Mounting of freevxfs",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure the system to prevent thekernel module from being loaded, add the following line to a file in the directory:This effectively prevents usage of this uncommon filesystem.",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if LC_ALL=C grep -q -m 1 \"^install freevxfs\" /etc/modprobe.d/freevxfs.conf ; then    sed -i 's#^install freevxfs.*#install freevxfs /bin/true#g' /etc/modprobe.d/freevxfs.conf else  echo -e \" # Disable per security requirements\" &gt;&gt; /etc/modprobe.d/freevxfs.conf  echo \"install freevxfs /bin/true\" &gt;&gt; /etc/modprobe.d/freevxfs.conf fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "mounting",
        "rid": "kernel_module_hfs_disabled",
        "gtitle": "Restrict Dynamic Mounting and Unmounting of Filesystems",
        "fix_id": "kernel_module_hfs_disabled"
      },
      "id": "mounting",
      "title": [
        {
          "#text": "Disable Mounting of hfs",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure the system to prevent thekernel module from being loaded, add the following line to a file in the directory:This effectively prevents usage of this uncommon filesystem.",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if LC_ALL=C grep -q -m 1 \"^install hfs\" /etc/modprobe.d/hfs.conf ; then    sed -i 's#^install hfs.*#install hfs /bin/true#g' /etc/modprobe.d/hfs.conf else  echo -e \" # Disable per security requirements\" &gt;&gt; /etc/modprobe.d/hfs.conf  echo \"install hfs /bin/true\" &gt;&gt; /etc/modprobe.d/hfs.conf fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "mounting",
        "rid": "kernel_module_hfsplus_disabled",
        "gtitle": "Restrict Dynamic Mounting and Unmounting of Filesystems",
        "fix_id": "kernel_module_hfsplus_disabled"
      },
      "id": "mounting",
      "title": [
        {
          "#text": "Disable Mounting of hfsplus",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure the system to prevent thekernel module from being loaded, add the following line to a file in the directory:This effectively prevents usage of this uncommon filesystem.",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if LC_ALL=C grep -q -m 1 \"^install hfsplus\" /etc/modprobe.d/hfsplus.conf ; then    sed -i 's#^install hfsplus.*#install hfsplus /bin/true#g' /etc/modprobe.d/hfsplus.conf else  echo -e \" # Disable per security requirements\" &gt;&gt; /etc/modprobe.d/hfsplus.conf  echo \"install hfsplus /bin/true\" &gt;&gt; /etc/modprobe.d/hfsplus.conf fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "mounting",
        "rid": "kernel_module_jffs2_disabled",
        "gtitle": "Restrict Dynamic Mounting and Unmounting of Filesystems",
        "fix_id": "kernel_module_jffs2_disabled"
      },
      "id": "mounting",
      "title": [
        {
          "#text": "Disable Mounting of jffs2",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure the system to prevent thekernel module from being loaded, add the following line to a file in the directory:This effectively prevents usage of this uncommon filesystem.",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if LC_ALL=C grep -q -m 1 \"^install jffs2\" /etc/modprobe.d/jffs2.conf ; then    sed -i 's#^install jffs2.*#install jffs2 /bin/true#g' /etc/modprobe.d/jffs2.conf else  echo -e \" # Disable per security requirements\" &gt;&gt; /etc/modprobe.d/jffs2.conf  echo \"install jffs2 /bin/true\" &gt;&gt; /etc/modprobe.d/jffs2.conf fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "mounting",
        "rid": "kernel_module_udf_disabled",
        "gtitle": "Restrict Dynamic Mounting and Unmounting of Filesystems",
        "fix_id": "kernel_module_udf_disabled"
      },
      "id": "mounting",
      "title": [
        {
          "#text": "Disable Mounting of udf",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure the system to prevent thekernel module from being loaded, add the following line to a file in the directory:This effectively prevents usage of this uncommon filesystem. Thefilesystem type is the universal disk format used to implement the ISO/IEC 13346 and ECMA-167 specifications. This is an open vendor filesystem type for data storage on a broad range of media. This filesystem type is neccessary to support writing DVDs and newer optical disc formats.",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if LC_ALL=C grep -q -m 1 \"^install udf\" /etc/modprobe.d/udf.conf ; then    sed -i 's#^install udf.*#install udf /bin/true#g' /etc/modprobe.d/udf.conf else  echo -e \" # Disable per security requirements\" &gt;&gt; /etc/modprobe.d/udf.conf  echo \"install udf /bin/true\" &gt;&gt; /etc/modprobe.d/udf.conf fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "mounting",
        "rid": "kernel_module_usb-storage_disabled",
        "gtitle": "Restrict Dynamic Mounting and Unmounting of Filesystems",
        "fix_id": "kernel_module_usb-storage_disabled"
      },
      "id": "mounting",
      "title": [
        {
          "#text": "Disable Modprobe Loading of USB Storage Driver",
          "@_lang": "en-US"
        }
      ],
      "desc": "To prevent USB storage devices from being used, configure the kernel module loading system to prevent automatic loading of the USB storage driver. To configure the system to prevent thekernel module from being loaded, add the following line to a file in the directory:This will prevent theprogram from loading themodule, but will not prevent an administrator (or another program) from using theprogram to load the module manually.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if LC_ALL=C grep -q -m 1 \"^install usb-storage\" /etc/modprobe.d/usb-storage.conf ; then    sed -i 's#^install usb-storage.*#install usb-storage /bin/true#g' /etc/modprobe.d/usb-storage.conf else  echo -e \" # Disable per security requirements\" &gt;&gt; /etc/modprobe.d/usb-storage.conf  echo \"install usb-storage /bin/true\" &gt;&gt; /etc/modprobe.d/usb-storage.conf fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "network-iptables",
        "rid": "package_iptables_installed",
        "gtitle": "iptables and ip6tables",
        "fix_id": "package_iptables_installed"
      },
      "id": "network-iptables",
      "title": [
        {
          "#text": "Install iptables Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be installed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "DEBIAN_FRONTEND=noninteractive apt-get install -y \"iptables\""
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "network-uncommon",
        "rid": "kernel_module_dccp_disabled",
        "gtitle": "Uncommon Network Protocols",
        "fix_id": "kernel_module_dccp_disabled"
      },
      "id": "network-uncommon",
      "title": [
        {
          "#text": "Disable DCCP Support",
          "@_lang": "en-US"
        }
      ],
      "desc": "The Datagram Congestion Control Protocol (DCCP) is a relatively new transport layer protocol, designed to support streaming media and telephony. To configure the system to prevent thekernel module from being loaded, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if LC_ALL=C grep -q -m 1 \"^install dccp\" /etc/modprobe.d/dccp.conf ; then    sed -i 's#^install dccp.*#install dccp /bin/true#g' /etc/modprobe.d/dccp.conf else  echo -e \" # Disable per security requirements\" &gt;&gt; /etc/modprobe.d/dccp.conf  echo \"install dccp /bin/true\" &gt;&gt; /etc/modprobe.d/dccp.conf fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "network-uncommon",
        "rid": "kernel_module_rds_disabled",
        "gtitle": "Uncommon Network Protocols",
        "fix_id": "kernel_module_rds_disabled"
      },
      "id": "network-uncommon",
      "title": [
        {
          "#text": "Disable RDS Support",
          "@_lang": "en-US"
        }
      ],
      "desc": "The Reliable Datagram Sockets (RDS) protocol is a transport layer protocol designed to provide reliable high-bandwidth, low-latency communications between nodes in a cluster. To configure the system to prevent thekernel module from being loaded, add the following line to a file in the directory:",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if LC_ALL=C grep -q -m 1 \"^install rds\" /etc/modprobe.d/rds.conf ; then    sed -i 's#^install rds.*#install rds /bin/true#g' /etc/modprobe.d/rds.conf else  echo -e \" # Disable per security requirements\" &gt;&gt; /etc/modprobe.d/rds.conf  echo \"install rds /bin/true\" &gt;&gt; /etc/modprobe.d/rds.conf fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "network-uncommon",
        "rid": "kernel_module_sctp_disabled",
        "gtitle": "Uncommon Network Protocols",
        "fix_id": "kernel_module_sctp_disabled"
      },
      "id": "network-uncommon",
      "title": [
        {
          "#text": "Disable SCTP Support",
          "@_lang": "en-US"
        }
      ],
      "desc": "The Stream Control Transmission Protocol (SCTP) is a transport layer protocol, designed to support the idea of message-oriented communication, with several streams of messages within one connection. To configure the system to prevent thekernel module from being loaded, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if LC_ALL=C grep -q -m 1 \"^install sctp\" /etc/modprobe.d/sctp.conf ; then    sed -i 's#^install sctp.*#install sctp /bin/true#g' /etc/modprobe.d/sctp.conf else  echo -e \" # Disable per security requirements\" &gt;&gt; /etc/modprobe.d/sctp.conf  echo \"install sctp /bin/true\" &gt;&gt; /etc/modprobe.d/sctp.conf fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "network-uncommon",
        "rid": "kernel_module_tipc_disabled",
        "gtitle": "Uncommon Network Protocols",
        "fix_id": "kernel_module_tipc_disabled"
      },
      "id": "network-uncommon",
      "title": [
        {
          "#text": "Disable TIPC Support",
          "@_lang": "en-US"
        }
      ],
      "desc": "The Transparent Inter-Process Communication (TIPC) protocol is designed to provide communications between nodes in a cluster. To configure the system to prevent thekernel module from being loaded, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if LC_ALL=C grep -q -m 1 \"^install tipc\" /etc/modprobe.d/tipc.conf ; then    sed -i 's#^install tipc.*#install tipc /bin/true#g' /etc/modprobe.d/tipc.conf else  echo -e \" # Disable per security requirements\" &gt;&gt; /etc/modprobe.d/tipc.conf  echo \"install tipc /bin/true\" &gt;&gt; /etc/modprobe.d/tipc.conf fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "network_host_and_router_parameters",
        "rid": "sysctl_net_ipv4_conf_all_accept_redirects",
        "gtitle": "Network Related Kernel Runtime Parameters for Hosts and Routers",
        "fix_id": "sysctl_net_ipv4_conf_all_accept_redirects"
      },
      "id": "network_host_and_router_parameters",
      "title": [
        {
          "#text": "Disable Accepting ICMP Redirects for All IPv4 Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv4_conf_all_accept_redirects_value=\"\" # # Set runtime for net.ipv4.conf.all.accept_redirects # /sbin/sysctl -q -n -w net.ipv4.conf.all.accept_redirects=\"$sysctl_net_ipv4_conf_all_accept_redirects_value\" # # If net.ipv4.conf.all.accept_redirects present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv4.conf.all.accept_redirects = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv4.conf.all.accept_redirects\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv4_conf_all_accept_redirects_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.conf.all.accept_redirects\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv4.conf.all.accept_redirects\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "network_host_and_router_parameters",
        "rid": "sysctl_net_ipv4_conf_all_accept_source_route",
        "gtitle": "Network Related Kernel Runtime Parameters for Hosts and Routers",
        "fix_id": "sysctl_net_ipv4_conf_all_accept_source_route"
      },
      "id": "network_host_and_router_parameters",
      "title": [
        {
          "#text": "Disable Kernel Parameter for Accepting Source-Routed Packets on all IPv4 Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv4_conf_all_accept_source_route_value=\"\" # # Set runtime for net.ipv4.conf.all.accept_source_route # /sbin/sysctl -q -n -w net.ipv4.conf.all.accept_source_route=\"$sysctl_net_ipv4_conf_all_accept_source_route_value\" # # If net.ipv4.conf.all.accept_source_route present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv4.conf.all.accept_source_route = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv4.conf.all.accept_source_route\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv4_conf_all_accept_source_route_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.conf.all.accept_source_route\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv4.conf.all.accept_source_route\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "network_host_and_router_parameters",
        "rid": "sysctl_net_ipv4_conf_all_log_martians",
        "gtitle": "Network Related Kernel Runtime Parameters for Hosts and Routers",
        "fix_id": "sysctl_net_ipv4_conf_all_log_martians"
      },
      "id": "network_host_and_router_parameters",
      "title": [
        {
          "#text": "Enable Kernel Parameter to Log Martian Packets on all IPv4 Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv4_conf_all_log_martians_value=\"\" # # Set runtime for net.ipv4.conf.all.log_martians # /sbin/sysctl -q -n -w net.ipv4.conf.all.log_martians=\"$sysctl_net_ipv4_conf_all_log_martians_value\" # # If net.ipv4.conf.all.log_martians present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv4.conf.all.log_martians = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv4.conf.all.log_martians\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv4_conf_all_log_martians_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.conf.all.log_martians\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv4.conf.all.log_martians\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "network_host_and_router_parameters",
        "rid": "sysctl_net_ipv4_conf_all_rp_filter",
        "gtitle": "Network Related Kernel Runtime Parameters for Hosts and Routers",
        "fix_id": "sysctl_net_ipv4_conf_all_rp_filter"
      },
      "id": "network_host_and_router_parameters",
      "title": [
        {
          "#text": "Enable Kernel Parameter to Use Reverse Path Filtering on all IPv4 Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv4_conf_all_rp_filter_value=\"\" # # Set runtime for net.ipv4.conf.all.rp_filter # /sbin/sysctl -q -n -w net.ipv4.conf.all.rp_filter=\"$sysctl_net_ipv4_conf_all_rp_filter_value\" # # If net.ipv4.conf.all.rp_filter present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv4.conf.all.rp_filter = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv4.conf.all.rp_filter\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv4_conf_all_rp_filter_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.conf.all.rp_filter\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv4.conf.all.rp_filter\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "network_host_and_router_parameters",
        "rid": "sysctl_net_ipv4_conf_all_secure_redirects",
        "gtitle": "Network Related Kernel Runtime Parameters for Hosts and Routers",
        "fix_id": "sysctl_net_ipv4_conf_all_secure_redirects"
      },
      "id": "network_host_and_router_parameters",
      "title": [
        {
          "#text": "Disable Kernel Parameter for Accepting Secure ICMP Redirects on all IPv4 Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv4_conf_all_secure_redirects_value=\"\" # # Set runtime for net.ipv4.conf.all.secure_redirects # /sbin/sysctl -q -n -w net.ipv4.conf.all.secure_redirects=\"$sysctl_net_ipv4_conf_all_secure_redirects_value\" # # If net.ipv4.conf.all.secure_redirects present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv4.conf.all.secure_redirects = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv4.conf.all.secure_redirects\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv4_conf_all_secure_redirects_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.conf.all.secure_redirects\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv4.conf.all.secure_redirects\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "network_host_and_router_parameters",
        "rid": "sysctl_net_ipv4_conf_default_accept_redirects",
        "gtitle": "Network Related Kernel Runtime Parameters for Hosts and Routers",
        "fix_id": "sysctl_net_ipv4_conf_default_accept_redirects"
      },
      "id": "network_host_and_router_parameters",
      "title": [
        {
          "#text": "Disable Kernel Parameter for Accepting ICMP Redirects by Default on IPv4 Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv4_conf_default_accept_redirects_value=\"\" # # Set runtime for net.ipv4.conf.default.accept_redirects # /sbin/sysctl -q -n -w net.ipv4.conf.default.accept_redirects=\"$sysctl_net_ipv4_conf_default_accept_redirects_value\" # # If net.ipv4.conf.default.accept_redirects present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv4.conf.default.accept_redirects = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv4.conf.default.accept_redirects\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv4_conf_default_accept_redirects_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.conf.default.accept_redirects\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv4.conf.default.accept_redirects\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "network_host_and_router_parameters",
        "rid": "sysctl_net_ipv4_conf_default_accept_source_route",
        "gtitle": "Network Related Kernel Runtime Parameters for Hosts and Routers",
        "fix_id": "sysctl_net_ipv4_conf_default_accept_source_route"
      },
      "id": "network_host_and_router_parameters",
      "title": [
        {
          "#text": "Disable Kernel Parameter for Accepting Source-Routed Packets on IPv4 Interfaces by Default",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv4_conf_default_accept_source_route_value=\"\" # # Set runtime for net.ipv4.conf.default.accept_source_route # /sbin/sysctl -q -n -w net.ipv4.conf.default.accept_source_route=\"$sysctl_net_ipv4_conf_default_accept_source_route_value\" # # If net.ipv4.conf.default.accept_source_route present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv4.conf.default.accept_source_route = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv4.conf.default.accept_source_route\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv4_conf_default_accept_source_route_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.conf.default.accept_source_route\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv4.conf.default.accept_source_route\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "network_host_and_router_parameters",
        "rid": "sysctl_net_ipv4_conf_default_log_martians",
        "gtitle": "Network Related Kernel Runtime Parameters for Hosts and Routers",
        "fix_id": "sysctl_net_ipv4_conf_default_log_martians"
      },
      "id": "network_host_and_router_parameters",
      "title": [
        {
          "#text": "Enable Kernel Paremeter to Log Martian Packets on all IPv4 Interfaces by Default",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv4_conf_default_log_martians_value=\"\" # # Set runtime for net.ipv4.conf.default.log_martians # /sbin/sysctl -q -n -w net.ipv4.conf.default.log_martians=\"$sysctl_net_ipv4_conf_default_log_martians_value\" # # If net.ipv4.conf.default.log_martians present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv4.conf.default.log_martians = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv4.conf.default.log_martians\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv4_conf_default_log_martians_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.conf.default.log_martians\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv4.conf.default.log_martians\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "network_host_and_router_parameters",
        "rid": "sysctl_net_ipv4_conf_default_rp_filter",
        "gtitle": "Network Related Kernel Runtime Parameters for Hosts and Routers",
        "fix_id": "sysctl_net_ipv4_conf_default_rp_filter"
      },
      "id": "network_host_and_router_parameters",
      "title": [
        {
          "#text": "Enable Kernel Parameter to Use Reverse Path Filtering on all IPv4 Interfaces by Default",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv4_conf_default_rp_filter_value=\"\" # # Set runtime for net.ipv4.conf.default.rp_filter # /sbin/sysctl -q -n -w net.ipv4.conf.default.rp_filter=\"$sysctl_net_ipv4_conf_default_rp_filter_value\" # # If net.ipv4.conf.default.rp_filter present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv4.conf.default.rp_filter = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv4.conf.default.rp_filter\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv4_conf_default_rp_filter_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.conf.default.rp_filter\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv4.conf.default.rp_filter\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "network_host_and_router_parameters",
        "rid": "sysctl_net_ipv4_conf_default_secure_redirects",
        "gtitle": "Network Related Kernel Runtime Parameters for Hosts and Routers",
        "fix_id": "sysctl_net_ipv4_conf_default_secure_redirects"
      },
      "id": "network_host_and_router_parameters",
      "title": [
        {
          "#text": "Configure Kernel Parameter for Accepting Secure Redirects By Default",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv4_conf_default_secure_redirects_value=\"\" # # Set runtime for net.ipv4.conf.default.secure_redirects # /sbin/sysctl -q -n -w net.ipv4.conf.default.secure_redirects=\"$sysctl_net_ipv4_conf_default_secure_redirects_value\" # # If net.ipv4.conf.default.secure_redirects present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv4.conf.default.secure_redirects = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv4.conf.default.secure_redirects\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv4_conf_default_secure_redirects_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.conf.default.secure_redirects\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv4.conf.default.secure_redirects\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "network_host_and_router_parameters",
        "rid": "sysctl_net_ipv4_icmp_echo_ignore_broadcasts",
        "gtitle": "Network Related Kernel Runtime Parameters for Hosts and Routers",
        "fix_id": "sysctl_net_ipv4_icmp_echo_ignore_broadcasts"
      },
      "id": "network_host_and_router_parameters",
      "title": [
        {
          "#text": "Enable Kernel Parameter to Ignore ICMP Broadcast Echo Requests on IPv4 Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv4_icmp_echo_ignore_broadcasts_value=\"\" # # Set runtime for net.ipv4.icmp_echo_ignore_broadcasts # /sbin/sysctl -q -n -w net.ipv4.icmp_echo_ignore_broadcasts=\"$sysctl_net_ipv4_icmp_echo_ignore_broadcasts_value\" # # If net.ipv4.icmp_echo_ignore_broadcasts present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv4.icmp_echo_ignore_broadcasts = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv4.icmp_echo_ignore_broadcasts\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv4_icmp_echo_ignore_broadcasts_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.icmp_echo_ignore_broadcasts\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv4.icmp_echo_ignore_broadcasts\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "network_host_and_router_parameters",
        "rid": "sysctl_net_ipv4_icmp_ignore_bogus_error_responses",
        "gtitle": "Network Related Kernel Runtime Parameters for Hosts and Routers",
        "fix_id": "sysctl_net_ipv4_icmp_ignore_bogus_error_responses"
      },
      "id": "network_host_and_router_parameters",
      "title": [
        {
          "#text": "Enable Kernel Parameter to Ignore Bogus ICMP Error Responses on IPv4 Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv4_icmp_ignore_bogus_error_responses_value=\"\" # # Set runtime for net.ipv4.icmp_ignore_bogus_error_responses # /sbin/sysctl -q -n -w net.ipv4.icmp_ignore_bogus_error_responses=\"$sysctl_net_ipv4_icmp_ignore_bogus_error_responses_value\" # # If net.ipv4.icmp_ignore_bogus_error_responses present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv4.icmp_ignore_bogus_error_responses = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv4.icmp_ignore_bogus_error_responses\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv4_icmp_ignore_bogus_error_responses_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.icmp_ignore_bogus_error_responses\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv4.icmp_ignore_bogus_error_responses\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "network_host_and_router_parameters",
        "rid": "sysctl_net_ipv4_tcp_syncookies",
        "gtitle": "Network Related Kernel Runtime Parameters for Hosts and Routers",
        "fix_id": "sysctl_net_ipv4_tcp_syncookies"
      },
      "id": "network_host_and_router_parameters",
      "title": [
        {
          "#text": "Enable Kernel Parameter to Use TCP Syncookies on IPv4 Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv4_tcp_syncookies_value=\"\" # # Set runtime for net.ipv4.tcp_syncookies # /sbin/sysctl -q -n -w net.ipv4.tcp_syncookies=\"$sysctl_net_ipv4_tcp_syncookies_value\" # # If net.ipv4.tcp_syncookies present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv4.tcp_syncookies = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv4.tcp_syncookies\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv4_tcp_syncookies_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.tcp_syncookies\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv4.tcp_syncookies\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "network_host_parameters",
        "rid": "sysctl_net_ipv4_conf_all_send_redirects",
        "gtitle": "Network Parameters for Hosts Only",
        "fix_id": "sysctl_net_ipv4_conf_all_send_redirects"
      },
      "id": "network_host_parameters",
      "title": [
        {
          "#text": "Disable Kernel Parameter for Sending ICMP Redirects on all IPv4 Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # # Set runtime for net.ipv4.conf.all.send_redirects # /sbin/sysctl -q -n -w net.ipv4.conf.all.send_redirects=\"0\" # # If net.ipv4.conf.all.send_redirects present in /etc/sysctl.conf, change value to \"0\" # else, add \"net.ipv4.conf.all.send_redirects = 0\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv4.conf.all.send_redirects\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"0\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.conf.all.send_redirects\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv4.conf.all.send_redirects\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "network_host_parameters",
        "rid": "sysctl_net_ipv4_conf_default_send_redirects",
        "gtitle": "Network Parameters for Hosts Only",
        "fix_id": "sysctl_net_ipv4_conf_default_send_redirects"
      },
      "id": "network_host_parameters",
      "title": [
        {
          "#text": "Disable Kernel Parameter for Sending ICMP Redirects on all IPv4 Interfaces by Default",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # # Set runtime for net.ipv4.conf.default.send_redirects # /sbin/sysctl -q -n -w net.ipv4.conf.default.send_redirects=\"0\" # # If net.ipv4.conf.default.send_redirects present in /etc/sysctl.conf, change value to \"0\" # else, add \"net.ipv4.conf.default.send_redirects = 0\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv4.conf.default.send_redirects\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"0\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.conf.default.send_redirects\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv4.conf.default.send_redirects\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "network_host_parameters",
        "rid": "sysctl_net_ipv4_ip_forward",
        "gtitle": "Network Parameters for Hosts Only",
        "fix_id": "sysctl_net_ipv4_ip_forward"
      },
      "id": "network_host_parameters",
      "title": [
        {
          "#text": "Disable Kernel Parameter for IP Forwarding on IPv4 Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # # Set runtime for net.ipv4.ip_forward # /sbin/sysctl -q -n -w net.ipv4.ip_forward=\"0\" # # If net.ipv4.ip_forward present in /etc/sysctl.conf, change value to \"0\" # else, add \"net.ipv4.ip_forward = 0\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv4.ip_forward\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"0\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.ip_forward\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv4.ip_forward\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "nfs_configuring_servers",
        "rid": "no_all_squash_exports",
        "gtitle": "Configure NFS Servers"
      },
      "id": "nfs_configuring_servers",
      "title": [
        {
          "#text": "Ensure All-Squashing Disabled On All Exports",
          "@_lang": "en-US"
        }
      ],
      "desc": "Themaps all uids and gids to an anonymous user. This should be disabled by removing any instances of theoption from the file.",
      "impact": 0.3,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "non-uefi",
        "rid": "file_owner_grub2_cfg",
        "gtitle": "Non-UEFI GRUB2 bootloader configuration",
        "fix_id": "file_owner_grub2_cfg"
      },
      "id": "non-uefi",
      "title": [
        {
          "#text": "Verify /boot/grub/grub.cfg User Ownership",
          "@_lang": "en-US"
        }
      ],
      "desc": "The fileshould be owned by theuser to prevent destruction or modification of the file. To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chown 0 /boot/grub/grub.cfg else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "non-uefi",
        "rid": "file_permissions_grub2_cfg",
        "gtitle": "Non-UEFI GRUB2 bootloader configuration",
        "fix_id": "file_permissions_grub2_cfg"
      },
      "id": "non-uefi",
      "title": [
        {
          "#text": "Verify /boot/grub/grub.cfg Permissions",
          "@_lang": "en-US"
        }
      ],
      "desc": "File permissions forshould be set to 600. To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chmod 0600 /boot/grub/grub.cfg else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gid": "non-uefi",
        "rid": "grub2_password",
        "gtitle": "Non-UEFI GRUB2 bootloader configuration"
      },
      "id": "non-uefi",
      "title": [
        {
          "#text": "Set Boot Loader Password in grub2",
          "@_lang": "en-US"
        }
      ],
      "desc": "The grub2 boot loader should have a superuser account and password protection enabled to protect boot-time settings.Since plaintext passwords are a security risk, generate a hash for the password by running the following command:When prompted, enter the password that was selected.Using the hash from the output, modify thefile with the following content:NOTE: the bootloader superuser account and password MUST differ from the root account and password.Once the superuser password has been added, update thefile by running:",
      "impact": 0.7,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ntp",
        "rid": "package_chrony_installed",
        "gtitle": "Network Time Protocol",
        "fix_id": "package_chrony_installed"
      },
      "id": "ntp",
      "title": [
        {
          "#text": "The Chrony package is installed",
          "@_lang": "en-US"
        }
      ],
      "desc": "System time should be synchronized between all systems in an environment. This is typically done by establishing an authoritative time server or set of servers and having all systems synchronize their clocks to them. Thepackage can be installed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"chrony\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gid": "ntp",
        "rid": "package_ntp_installed",
        "gtitle": "Network Time Protocol",
        "fix_id": "package_ntp_installed"
      },
      "id": "ntp",
      "title": [
        {
          "#text": "Install the ntp service",
          "@_lang": "en-US"
        }
      ],
      "desc": "The ntpd service should be installed.",
      "impact": 0.7,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"ntp\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gid": "ntp",
        "rid": "package_timesyncd_installed",
        "gtitle": "Network Time Protocol",
        "fix_id": "package_timesyncd_installed"
      },
      "id": "ntp",
      "title": [
        {
          "#text": "Install the systemd_timesyncd Service",
          "@_lang": "en-US"
        }
      ],
      "desc": "The systemd_timesyncd service should be installed.",
      "impact": 0.7,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"systemd-timesyncd\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ntp",
        "rid": "service_chronyd_enabled",
        "gtitle": "Network Time Protocol",
        "fix_id": "service_chronyd_enabled"
      },
      "id": "ntp",
      "title": [
        {
          "#text": "The Chronyd service is enabled",
          "@_lang": "en-US"
        }
      ],
      "desc": "chrony is a daemon which implements the Network Time Protocol (NTP) is designed to synchronize system clocks across a variety of systems and use a source that is highly accurate. More information on chrony can be found at. Chrony can be configured to be a client and/or a server. To enable Chronyd service, you can run:This recommendation only applies if chrony is in use on the system.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" unmask 'chronyd.service' \"$SYSTEMCTL_EXEC\" start 'chronyd.service' \"$SYSTEMCTL_EXEC\" enable 'chronyd.service' else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ntp",
        "rid": "service_chronyd_or_ntpd_enabled",
        "gtitle": "Network Time Protocol"
      },
      "id": "ntp",
      "title": [
        {
          "#text": "Enable the NTP Daemon",
          "@_lang": "en-US"
        }
      ],
      "desc": "Run the following command to determine the current status of theservice:If the service is running, it should return the following:Note: Thedaemon is enabled by default.Run the following command to determine the current status of theservice:If the service is running, it should return the following:Note: Thedaemon is not enabled by default. Though as mentioned in the previous sections in certain environments thedaemon might be preferred to be used rather than theone. Refer to:for guidance which NTP daemon to choose depending on the environment used.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gid": "ntp",
        "rid": "service_ntp_enabled",
        "gtitle": "Network Time Protocol",
        "fix_id": "service_ntp_enabled"
      },
      "id": "ntp",
      "title": [
        {
          "#text": "Enable the NTP Daemon",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice can be enabled with the following command:",
      "impact": 0.7,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" unmask 'ntp.service' \"$SYSTEMCTL_EXEC\" start 'ntp.service' \"$SYSTEMCTL_EXEC\" enable 'ntp.service' else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ntp",
        "rid": "service_ntpd_enabled",
        "gtitle": "Network Time Protocol",
        "fix_id": "service_ntpd_enabled"
      },
      "id": "ntp",
      "title": [
        {
          "#text": "Enable the NTP Daemon",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice can be enabled with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { dpkg-query --show --showformat='${db:Status-Status} ' 'ntp' 2&gt;/dev/null | grep -q installed; }; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" unmask 'ntpd.service' \"$SYSTEMCTL_EXEC\" start 'ntpd.service' \"$SYSTEMCTL_EXEC\" enable 'ntpd.service' else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gid": "ntp",
        "rid": "service_timesyncd_enabled",
        "gtitle": "Network Time Protocol",
        "fix_id": "service_timesyncd_enabled"
      },
      "id": "ntp",
      "title": [
        {
          "#text": "Enable systemd_timesyncd Service",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice can be enabled with the following command:",
      "impact": 0.7,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" unmask 'systemd-timesyncd.service' \"$SYSTEMCTL_EXEC\" start 'systemd-timesyncd.service' \"$SYSTEMCTL_EXEC\" enable 'systemd-timesyncd.service' else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ntp",
        "rid": "chronyd_or_ntpd_set_maxpoll",
        "gtitle": "Network Time Protocol"
      },
      "id": "ntp",
      "title": [
        {
          "#text": "Configure Time Service Maxpoll Interval",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theshould be configured toinorto continuously poll time servers. To configureinoradd the following:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ntp",
        "rid": "chronyd_run_as_chrony_user",
        "gtitle": "Network Time Protocol",
        "fix_id": "chronyd_run_as_chrony_user"
      },
      "id": "ntp",
      "title": [
        {
          "#text": "Ensure that chronyd is running under chrony user account",
          "@_lang": "en-US"
        }
      ],
      "desc": "chrony is a daemon which implements the Network Time Protocol (NTP). It is designed to synchronize system clocks across a variety of systems and use a source that is highly accurate. More information on chrony can be found at. Chrony can be configured to be a client and/or a server. To ensure that chronyd is running under chrony user account, Add or edit thevariable into include:This recommendation only applies if chrony is in use on the system.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { dpkg-query --show --showformat='${db:Status-Status} ' 'chrony' 2&gt;/dev/null | grep -q installed; }; then if grep -q 'OPTIONS=.*' /etc/sysconfig/chronyd; then  # trying to solve cases where the parameter after OPTIONS  #may or may not be enclosed in quotes  sed -i -E -e 's/\\s*-u\\s+\\w+\\s*/ /' -e 's/^([\\s]*OPTIONS=[\"]?[^\"]*)(\"?)/\\1 -u chrony\\2/' /etc/sysconfig/chronyd else  echo 'OPTIONS=\"-u chrony\"' &gt;&gt; /etc/sysconfig/chronyd fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ntp",
        "rid": "chronyd_specify_remote_server",
        "gtitle": "Network Time Protocol",
        "fix_id": "chronyd_specify_remote_server"
      },
      "id": "ntp",
      "title": [
        {
          "#text": "A remote time server for Chrony is configured",
          "@_lang": "en-US"
        }
      ],
      "desc": "is a daemon which implements the Network Time Protocol (NTP). It is designed to synchronize system clocks across a variety of systems and use a source that is highly accurate. More information oncan be found at.can be configured to be a client and/or a server. Add or edit server or pool lines toas appropriate:Multiple servers may be configured.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { dpkg-query --show --showformat='${db:Status-Status} ' 'chrony' 2&gt;/dev/null | grep -q installed; }; then var_multiple_time_servers=\"\" config_file=\"/etc/chrony.conf\" if ! grep -q '^[\\s]*(?:server|pool)[\\s]+[\\w]+' \"$config_file\" ; then if ! grep -q '#[[:space:]]*server' \"$config_file\" ; then for server in $(echo \"$var_multiple_time_servers\" | tr ',' ' ') ; do printf ' server %s' \"$server\" &gt;&gt; \"$config_file\" done else sed -i 's/#[ \\t]*server/server/g' \"$config_file\" fi fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ntp",
        "rid": "ntpd_specify_multiple_servers",
        "gtitle": "Network Time Protocol"
      },
      "id": "ntp",
      "title": [
        {
          "#text": "Specify Additional Remote NTP Servers",
          "@_lang": "en-US"
        }
      ],
      "desc": "Additional NTP servers can be specified for time synchronization in the file. To do so, add additional lines of the following form, substituting the IP address or hostname of a remote NTP server for:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ntp",
        "rid": "ntpd_specify_remote_server",
        "gtitle": "Network Time Protocol"
      },
      "id": "ntp",
      "title": [
        {
          "#text": "Specify a Remote NTP Server",
          "@_lang": "en-US"
        }
      ],
      "desc": "To specify a remote NTP server for time synchronization, edit the file. Add or correct the following lines, substituting the IP or hostname of a remote NTP server for:This instructs the NTP software to contact that remote server to obtain time data.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "openldap_client",
        "rid": "package_openldap-clients_removed",
        "gtitle": "Configure OpenLDAP Clients",
        "fix_id": "package_openldap-clients_removed"
      },
      "id": "openldap_client",
      "title": [
        {
          "#text": "Ensure LDAP client is not installed",
          "@_lang": "en-US"
        }
      ],
      "desc": "The Lightweight Directory Access Protocol (LDAP) is a service that provides a method for looking up information from a central database. Thepackage can be removed with the following command:",
      "impact": 0.3,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove ldap-utils #  from the system, and may remove any packages #  that depend on ldap-utils. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"ldap-utils\""
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "openldap_server",
        "rid": "package_openldap-servers_removed",
        "gtitle": "Configure OpenLDAP Server",
        "fix_id": "package_openldap-servers_removed"
      },
      "id": "openldap_server",
      "title": [
        {
          "#text": "Uninstall openldap-servers Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "The slapd package is not installed by default on a Ubuntu 20.04 system. It is needed only by the OpenLDAP server, not by the clients which use LDAP for authentication. If the system is not intended for use as an LDAP Server it should be removed.",
      "impact": 0.3,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove slapd #  from the system, and may remove any packages #  that depend on slapd. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"slapd\""
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "partitions",
        "rid": "mount_option_dev_shm_nodev",
        "gtitle": "Restrict Partition Mount Options",
        "fix_id": "mount_option_dev_shm_nodev"
      },
      "id": "partitions",
      "title": [
        {
          "#text": "Add nodev Option to /dev/shm",
          "@_lang": "en-US"
        }
      ],
      "desc": "Themount option can be used to prevent creation of device files in. Legitimate character and block devices should not exist within temporary directories like. Add theoption to the fourth column offor the line which controls mounting of.",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then function perform_remediation { mount_point_match_regexp=\"$(printf \"[[:space:]]%s[[:space:]]\" /dev/shm)\" # If the mount point is not in /etc/fstab, get previous mount options from /etc/mtab if [ \"$(grep -c \"$mount_point_match_regexp\" /etc/fstab)\" -eq 0 ]; then # runtime opts without some automatic kernel/userspace-added defaults previous_mount_opts=$(grep \"$mount_point_match_regexp\" /etc/mtab | head -1 | awk '{print $4}' \\ | sed -E \"s/(rw|defaults|seclabel|nodev)(,|$)//g;s/,$//\") [ \"$previous_mount_opts\" ] &amp;&amp; previous_mount_opts+=\",\" echo \"tmpfs /dev/shm tmpfs defaults,${previous_mount_opts}nodev 0 0\" &gt;&gt; /etc/fstab # If the mount_opt option is not already in the mount point's /etc/fstab entry, add it elif [ \"$(grep \"$mount_point_match_regexp\" /etc/fstab | grep -c \"nodev\")\" -eq 0 ]; then previous_mount_opts=$(grep \"$mount_point_match_regexp\" /etc/fstab | awk '{print $4}') sed -i \"s|\\(${mount_point_match_regexp}.*${previous_mount_opts}\\)|\\1,nodev|\" /etc/fstab fi if mkdir -p \"/dev/shm\"; then if mountpoint -q \"/dev/shm\"; then mount -o remount --target \"/dev/shm\" else mount --target \"/dev/shm\" fi fi } perform_remediation else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "partitions",
        "rid": "mount_option_dev_shm_noexec",
        "gtitle": "Restrict Partition Mount Options",
        "fix_id": "mount_option_dev_shm_noexec"
      },
      "id": "partitions",
      "title": [
        {
          "#text": "Add noexec Option to /dev/shm",
          "@_lang": "en-US"
        }
      ],
      "desc": "Themount option can be used to prevent binaries from being executed out of. It can be dangerous to allow the execution of binaries from world-writable temporary storage directories such as. Add theoption to the fourth column offor the line which controls mounting of.",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then function perform_remediation { mount_point_match_regexp=\"$(printf \"[[:space:]]%s[[:space:]]\" /dev/shm)\" # If the mount point is not in /etc/fstab, get previous mount options from /etc/mtab if [ \"$(grep -c \"$mount_point_match_regexp\" /etc/fstab)\" -eq 0 ]; then # runtime opts without some automatic kernel/userspace-added defaults previous_mount_opts=$(grep \"$mount_point_match_regexp\" /etc/mtab | head -1 | awk '{print $4}' \\ | sed -E \"s/(rw|defaults|seclabel|noexec)(,|$)//g;s/,$//\") [ \"$previous_mount_opts\" ] &amp;&amp; previous_mount_opts+=\",\" echo \"tmpfs /dev/shm tmpfs defaults,${previous_mount_opts}noexec 0 0\" &gt;&gt; /etc/fstab # If the mount_opt option is not already in the mount point's /etc/fstab entry, add it elif [ \"$(grep \"$mount_point_match_regexp\" /etc/fstab | grep -c \"noexec\")\" -eq 0 ]; then previous_mount_opts=$(grep \"$mount_point_match_regexp\" /etc/fstab | awk '{print $4}') sed -i \"s|\\(${mount_point_match_regexp}.*${previous_mount_opts}\\)|\\1,noexec|\" /etc/fstab fi if mkdir -p \"/dev/shm\"; then if mountpoint -q \"/dev/shm\"; then mount -o remount --target \"/dev/shm\" else mount --target \"/dev/shm\" fi fi } perform_remediation else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "partitions",
        "rid": "mount_option_dev_shm_nosuid",
        "gtitle": "Restrict Partition Mount Options",
        "fix_id": "mount_option_dev_shm_nosuid"
      },
      "id": "partitions",
      "title": [
        {
          "#text": "Add nosuid Option to /dev/shm",
          "@_lang": "en-US"
        }
      ],
      "desc": "Themount option can be used to prevent execution of setuid programs in. The SUID and SGID permissions should not be required in these world-writable directories. Add theoption to the fourth column offor the line which controls mounting of.",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then function perform_remediation { mount_point_match_regexp=\"$(printf \"[[:space:]]%s[[:space:]]\" /dev/shm)\" # If the mount point is not in /etc/fstab, get previous mount options from /etc/mtab if [ \"$(grep -c \"$mount_point_match_regexp\" /etc/fstab)\" -eq 0 ]; then # runtime opts without some automatic kernel/userspace-added defaults previous_mount_opts=$(grep \"$mount_point_match_regexp\" /etc/mtab | head -1 | awk '{print $4}' \\ | sed -E \"s/(rw|defaults|seclabel|nosuid)(,|$)//g;s/,$//\") [ \"$previous_mount_opts\" ] &amp;&amp; previous_mount_opts+=\",\" echo \"tmpfs /dev/shm tmpfs defaults,${previous_mount_opts}nosuid 0 0\" &gt;&gt; /etc/fstab # If the mount_opt option is not already in the mount point's /etc/fstab entry, add it elif [ \"$(grep \"$mount_point_match_regexp\" /etc/fstab | grep -c \"nosuid\")\" -eq 0 ]; then previous_mount_opts=$(grep \"$mount_point_match_regexp\" /etc/fstab | awk '{print $4}') sed -i \"s|\\(${mount_point_match_regexp}.*${previous_mount_opts}\\)|\\1,nosuid|\" /etc/fstab fi if mkdir -p \"/dev/shm\"; then if mountpoint -q \"/dev/shm\"; then mount -o remount --target \"/dev/shm\" else mount --target \"/dev/shm\" fi fi } perform_remediation else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "password_expiration",
        "rid": "accounts_maximum_age_login_defs",
        "gtitle": "Set Password Expiration Parameters"
      },
      "id": "password_expiration",
      "title": [
        {
          "#text": "Set Password Maximum Age",
          "@_lang": "en-US"
        }
      ],
      "desc": "To specify password maximum age for new accounts, edit the fileand add or correct the following line:A value of 180 days is sufficient for many environments. The DoD requirement is 60. The profile requirement is.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "password_expiration",
        "rid": "accounts_minimum_age_login_defs",
        "gtitle": "Set Password Expiration Parameters",
        "fix_id": "accounts_minimum_age_login_defs"
      },
      "id": "password_expiration",
      "title": [
        {
          "#text": "Set Password Minimum Age",
          "@_lang": "en-US"
        }
      ],
      "desc": "To specify password minimum age for new accounts, edit the fileand add or correct the following line:A value of 1 day is considered sufficient for many environments. The DoD requirement is 1. The profile requirement is.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'login' 2&gt;/dev/null | grep -q installed; then var_accounts_minimum_age_login_defs=\"\" grep -q ^PASS_MIN_DAYS /etc/login.defs &amp;&amp; \\ sed -i \"s/PASS_MIN_DAYS.*/PASS_MIN_DAYS $var_accounts_minimum_age_login_defs/g\" /etc/login.defs if ! [ $? -eq 0 ]; then echo \"PASS_MIN_DAYS $var_accounts_minimum_age_login_defs\" &gt;&gt; /etc/login.defs fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "password_expiration",
        "rid": "accounts_password_minlen_login_defs",
        "gtitle": "Set Password Expiration Parameters"
      },
      "id": "password_expiration",
      "title": [
        {
          "#text": "Set Password Minimum Length in login.defs",
          "@_lang": "en-US"
        }
      ],
      "desc": "To specify password length requirements for new accounts, edit the fileand add or correct the following line:The DoD requirement is. The FISMA requirement is. The profile requirement is. If a program consultsand also another PAM module (such as) during a password change operation, then the most restrictive must be satisfied. See PAM section for more information about enforcing password quality requirements.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "password_expiration",
        "rid": "accounts_password_set_max_life_existing",
        "gtitle": "Set Password Expiration Parameters"
      },
      "id": "password_expiration",
      "title": [
        {
          "#text": "Set Existing Passwords Maximum Age",
          "@_lang": "en-US"
        }
      ],
      "desc": "Configure non-compliant accounts to enforce a 60-day maximum password lifetime restriction by running the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "password_expiration",
        "rid": "accounts_password_set_min_life_existing",
        "gtitle": "Set Password Expiration Parameters"
      },
      "id": "password_expiration",
      "title": [
        {
          "#text": "Set Existing Passwords Minimum Age",
          "@_lang": "en-US"
        }
      ],
      "desc": "Configure non-compliant accounts to enforce a 24 hours/1 day minimum password lifetime by running the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "password_expiration",
        "rid": "accounts_password_warn_age_login_defs",
        "gtitle": "Set Password Expiration Parameters",
        "fix_id": "accounts_password_warn_age_login_defs"
      },
      "id": "password_expiration",
      "title": [
        {
          "#text": "Set Password Warning Age",
          "@_lang": "en-US"
        }
      ],
      "desc": "To specify how many days prior to password expiration that a warning will be issued to users, edit the fileand add or correct the following line:The DoD requirement is 7. The profile requirement is.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'login' 2&gt;/dev/null | grep -q installed; then var_accounts_password_warn_age_login_defs=\"\" grep -q ^PASS_WARN_AGE /etc/login.defs &amp;&amp; \\ sed -i \"s/PASS_WARN_AGE.*/PASS_WARN_AGE\\t$var_accounts_password_warn_age_login_defs/g\" /etc/login.defs if ! [ $? -eq 0 ] then echo -e \"PASS_WARN_AGE\\t$var_accounts_password_warn_age_login_defs\" &gt;&gt; /etc/login.defs fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "password_quality_pwquality",
        "rid": "accounts_password_pam_dcredit",
        "gtitle": "Set Password Quality Requirements with pam_pwquality",
        "fix_id": "accounts_password_pam_dcredit"
      },
      "id": "password_quality_pwquality",
      "title": [
        {
          "#text": "Ensure PAM Enforces Password Requirements - Minimum Digit Characters",
          "@_lang": "en-US"
        }
      ],
      "desc": "The pam_pwquality module'sparameter controls requirements for usage of digits in a password. When set to a negative number, any password will be required to contain that many digits. When set to a positive number, pam_pwquality will grant +1 additional length credit for each digit. Modify thesetting into require the use of a digit in passwords.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'libpam-runtime' 2&gt;/dev/null | grep -q installed; then var_password_pam_dcredit=\"\" # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/security/pwquality.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^dcredit\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_dcredit\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^dcredit\\\\&gt;\" \"/etc/security/pwquality.conf\"; then \"${sed_command[@]}\" \"s/^dcredit\\\\&gt;.*/$formatted_output/gi\" \"/etc/security/pwquality.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/security/pwquality.conf\" &gt;&gt; \"/etc/security/pwquality.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/security/pwquality.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "password_quality_pwquality",
        "rid": "accounts_password_pam_dictcheck",
        "gtitle": "Set Password Quality Requirements with pam_pwquality",
        "fix_id": "accounts_password_pam_dictcheck"
      },
      "id": "password_quality_pwquality",
      "title": [
        {
          "#text": "Ensure PAM Enforces Password Requirements - Prevent the Use of Dictionary Words",
          "@_lang": "en-US"
        }
      ],
      "desc": "The pam_pwquality module'scheck if passwords contains dictionary words. Whenis set topasswords will be checked for dictionary words.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'libpam-runtime' 2&gt;/dev/null | grep -q installed; then var_password_pam_dictcheck=\"\" # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/security/pwquality.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^dictcheck\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_dictcheck\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^dictcheck\\\\&gt;\" \"/etc/security/pwquality.conf\"; then \"${sed_command[@]}\" \"s/^dictcheck\\\\&gt;.*/$formatted_output/gi\" \"/etc/security/pwquality.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/security/pwquality.conf\" &gt;&gt; \"/etc/security/pwquality.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/security/pwquality.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "password_quality_pwquality",
        "rid": "accounts_password_pam_difok",
        "gtitle": "Set Password Quality Requirements with pam_pwquality",
        "fix_id": "accounts_password_pam_difok"
      },
      "id": "password_quality_pwquality",
      "title": [
        {
          "#text": "Ensure PAM Enforces Password Requirements - Minimum Different Characters",
          "@_lang": "en-US"
        }
      ],
      "desc": "The pam_pwquality module'sparameter sets the number of characters in a password that must not be present in and old password during a password change.Modify thesetting into equalto require differing characters when changing passwords.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'libpam-runtime' 2&gt;/dev/null | grep -q installed; then var_password_pam_difok=\"\" # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/security/pwquality.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^difok\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_difok\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^difok\\\\&gt;\" \"/etc/security/pwquality.conf\"; then \"${sed_command[@]}\" \"s/^difok\\\\&gt;.*/$formatted_output/gi\" \"/etc/security/pwquality.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/security/pwquality.conf\" &gt;&gt; \"/etc/security/pwquality.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/security/pwquality.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "password_quality_pwquality",
        "rid": "accounts_password_pam_enforcing",
        "gtitle": "Set Password Quality Requirements with pam_pwquality",
        "fix_id": "accounts_password_pam_enforcing"
      },
      "id": "password_quality_pwquality",
      "title": [
        {
          "#text": "Ensure PAM Enforces Password Requirements - Enforcing",
          "@_lang": "en-US"
        }
      ],
      "desc": "Verify that the operating system uses \"pwquality\" to enforce the password complexity rules. Verify the pwquality module is being enforced by operating system by running the following command:If the value of \"enforcing\" is not \"1\" or the line is commented out, this is a finding.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'libpam-runtime' 2&gt;/dev/null | grep -q installed; then if [ -e \"/etc/security/pwquality.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*enforcing = 1/Id\" \"/etc/security/pwquality.conf\" else touch \"/etc/security/pwquality.conf\" fi cp \"/etc/security/pwquality.conf\" \"/etc/security/pwquality.conf.bak\" # Insert at the end of the file printf '%s ' \"enforcing = 1\" &gt;&gt; \"/etc/security/pwquality.conf\" # Clean up after ourselves. rm \"/etc/security/pwquality.conf.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "password_quality_pwquality",
        "rid": "accounts_password_pam_lcredit",
        "gtitle": "Set Password Quality Requirements with pam_pwquality",
        "fix_id": "accounts_password_pam_lcredit"
      },
      "id": "password_quality_pwquality",
      "title": [
        {
          "#text": "Ensure PAM Enforces Password Requirements - Minimum Lowercase Characters",
          "@_lang": "en-US"
        }
      ],
      "desc": "The pam_pwquality module'sparameter controls requirements for usage of lowercase letters in a password. When set to a negative number, any password will be required to contain that many lowercase characters. When set to a positive number, pam_pwquality will grant +1 additional length credit for each lowercase character. Modify thesetting into require the use of a lowercase character in passwords.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'libpam-runtime' 2&gt;/dev/null | grep -q installed; then var_password_pam_lcredit=\"\" # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/security/pwquality.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^lcredit\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_lcredit\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^lcredit\\\\&gt;\" \"/etc/security/pwquality.conf\"; then \"${sed_command[@]}\" \"s/^lcredit\\\\&gt;.*/$formatted_output/gi\" \"/etc/security/pwquality.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/security/pwquality.conf\" &gt;&gt; \"/etc/security/pwquality.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/security/pwquality.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "password_quality_pwquality",
        "rid": "accounts_password_pam_minclass",
        "gtitle": "Set Password Quality Requirements with pam_pwquality",
        "fix_id": "accounts_password_pam_minclass"
      },
      "id": "password_quality_pwquality",
      "title": [
        {
          "#text": "Ensure PAM Enforces Password Requirements - Minimum Different Categories",
          "@_lang": "en-US"
        }
      ],
      "desc": "The pam_pwquality module'sparameter controls requirements for usage of different character classes, or types, of character that must exist in a password before it is considered valid. For example, setting this value to three (3) requires that any password must have characters from at least three different categories in order to be approved. The default value is zero (0), meaning there are no required classes. There are four categories available:Modify thesetting inentry to requirediffering categories of characters when changing passwords.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'libpam-runtime' 2&gt;/dev/null | grep -q installed; then var_password_pam_minclass=\"\" # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/security/pwquality.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^minclass\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_minclass\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^minclass\\\\&gt;\" \"/etc/security/pwquality.conf\"; then \"${sed_command[@]}\" \"s/^minclass\\\\&gt;.*/$formatted_output/gi\" \"/etc/security/pwquality.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/security/pwquality.conf\" &gt;&gt; \"/etc/security/pwquality.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/security/pwquality.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "password_quality_pwquality",
        "rid": "accounts_password_pam_minlen",
        "gtitle": "Set Password Quality Requirements with pam_pwquality",
        "fix_id": "accounts_password_pam_minlen"
      },
      "id": "password_quality_pwquality",
      "title": [
        {
          "#text": "Ensure PAM Enforces Password Requirements - Minimum Length",
          "@_lang": "en-US"
        }
      ],
      "desc": "The pam_pwquality module'sparameter controls requirements for minimum characters required in a password. Addafter pam_pwquality to set minimum password length requirements.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'libpam-runtime' 2&gt;/dev/null | grep -q installed; then var_password_pam_minlen=\"\" # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/security/pwquality.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^minlen\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_minlen\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^minlen\\\\&gt;\" \"/etc/security/pwquality.conf\"; then \"${sed_command[@]}\" \"s/^minlen\\\\&gt;.*/$formatted_output/gi\" \"/etc/security/pwquality.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/security/pwquality.conf\" &gt;&gt; \"/etc/security/pwquality.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/security/pwquality.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "password_quality_pwquality",
        "rid": "accounts_password_pam_ocredit",
        "gtitle": "Set Password Quality Requirements with pam_pwquality",
        "fix_id": "accounts_password_pam_ocredit"
      },
      "id": "password_quality_pwquality",
      "title": [
        {
          "#text": "Ensure PAM Enforces Password Requirements - Minimum Special Characters",
          "@_lang": "en-US"
        }
      ],
      "desc": "The pam_pwquality module'sparameter controls requirements for usage of special (or \"other\") characters in a password. When set to a negative number, any password will be required to contain that many special characters. When set to a positive number, pam_pwquality will grant +1 additional length credit for each special character. Modify thesetting into equalto require use of a special character in passwords.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'libpam-runtime' 2&gt;/dev/null | grep -q installed; then var_password_pam_ocredit=\"\" # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/security/pwquality.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^ocredit\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_ocredit\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^ocredit\\\\&gt;\" \"/etc/security/pwquality.conf\"; then \"${sed_command[@]}\" \"s/^ocredit\\\\&gt;.*/$formatted_output/gi\" \"/etc/security/pwquality.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/security/pwquality.conf\" &gt;&gt; \"/etc/security/pwquality.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/security/pwquality.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "password_quality_pwquality",
        "rid": "accounts_password_pam_retry",
        "gtitle": "Set Password Quality Requirements with pam_pwquality",
        "fix_id": "accounts_password_pam_retry"
      },
      "id": "password_quality_pwquality",
      "title": [
        {
          "#text": "Ensure PAM Enforces Password Requirements - Authentication Retry Prompts Permitted Per-Session",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure the number of retry prompts that are permitted per-session: Edit thestatement into show, or a lower value if site policy is more restrictive. The DoD requirement is a maximum of 3 prompts per session.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'libpam-runtime' 2&gt;/dev/null | grep -q installed; then var_password_pam_retry=\"\" if [ -e \"/etc/pam.d/common-password\" ] ; then valueRegex=\"$var_password_pam_retry\" defaultValue=\"$var_password_pam_retry\" # non-empty values need to be preceded by an equals sign [ -n \"${valueRegex}\" ] &amp;&amp; valueRegex=\"=${valueRegex}\" # add an equals sign to non-empty values [ -n \"${defaultValue}\" ] &amp;&amp; defaultValue=\"=${defaultValue}\" # fix 'type' if it's wrong if grep -q -P \"^\\\\s*(?\"'!'\"password\\\\s)[[:alnum:]]+\\\\s+[[:alnum:]]+\\\\s+pam_pwquality.so\" &lt; \"/etc/pam.d/common-password\" ; then sed --follow-symlinks -i -E -e \"s/^(\\\\s*)[[:alnum:]]+(\\\\s+[[:alnum:]]+\\\\s+pam_pwquality.so)/\\\\1password\\\\2/\" \"/etc/pam.d/common-password\" fi # fix 'control' if it's wrong if grep -q -P \"^\\\\s*password\\\\s+(?\"'!'\"requisite)[[:alnum:]]+\\\\s+pam_pwquality.so\" &lt; \"/etc/pam.d/common-password\" ; then sed --follow-symlinks -i -E -e \"s/^(\\\\s*password\\\\s+)[[:alnum:]]+(\\\\s+pam_pwquality.so)/\\\\1requisite\\\\2/\" \"/etc/pam.d/common-password\" fi # fix the value for 'option' if one exists but does not match 'valueRegex' if grep -q -P \"^\\\\s*password\\\\s+requisite\\\\s+pam_pwquality.so(\\\\s.+)?\\\\s+retry(?\"'!'\"${valueRegex}(\\\\s|\\$))\" &lt; \"/etc/pam.d/common-password\" ; then sed --follow-symlinks -i -E -e \"s/^(\\\\s*password\\\\s+requisite\\\\s+pam_pwquality.so(\\\\s.+)?\\\\s)retry=[^[:space:]]*/\\\\1retry${defaultValue}/\" \"/etc/pam.d/common-password\" # add 'option=default' if option is not set elif grep -q -E \"^\\\\s*password\\\\s+requisite\\\\s+pam_pwquality.so\" &lt; \"/etc/pam.d/common-password\" &amp;&amp; grep -E \"^\\\\s*password\\\\s+requisite\\\\s+pam_pwquality.so\" &lt; \"/etc/pam.d/common-password\" | grep -q -E -v \"\\\\sretry(=|\\\\s|\\$)\" ; then sed --follow-symlinks -i -E -e \"s/^(\\\\s*password\\\\s+requisite\\\\s+pam_pwquality.so[^\\ ]*)/\\\\1 retry${defaultValue}/\" \"/etc/pam.d/common-password\" # add a new entry if none exists elif ! grep -q -P \"^\\\\s*password\\\\s+requisite\\\\s+pam_pwquality.so(\\\\s.+)?\\\\s+retry${valueRegex}(\\\\s|\\$)\" &lt; \"/etc/pam.d/common-password\" ; then echo \"password requisite pam_pwquality.so retry${defaultValue}\" &gt;&gt; \"/etc/pam.d/common-password\" fi else echo \"/etc/pam.d/common-password doesn't exist\" &gt;&amp;2 fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "password_quality_pwquality",
        "rid": "accounts_password_pam_ucredit",
        "gtitle": "Set Password Quality Requirements with pam_pwquality",
        "fix_id": "accounts_password_pam_ucredit"
      },
      "id": "password_quality_pwquality",
      "title": [
        {
          "#text": "Ensure PAM Enforces Password Requirements - Minimum Uppercase Characters",
          "@_lang": "en-US"
        }
      ],
      "desc": "The pam_pwquality module'sparameter controls requirements for usage of uppercase letters in a password. When set to a negative number, any password will be required to contain that many uppercase characters. When set to a positive number, pam_pwquality will grant +1 additional length credit for each uppercase character. Modify thesetting into require the use of an uppercase character in passwords.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'libpam-runtime' 2&gt;/dev/null | grep -q installed; then var_password_pam_ucredit=\"\" # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/security/pwquality.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^ucredit\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_ucredit\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^ucredit\\\\&gt;\" \"/etc/security/pwquality.conf\"; then \"${sed_command[@]}\" \"s/^ucredit\\\\&gt;.*/$formatted_output/gi\" \"/etc/security/pwquality.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/security/pwquality.conf\" &gt;&gt; \"/etc/security/pwquality.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/security/pwquality.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "password_storage",
        "rid": "accounts_password_all_shadowed",
        "gtitle": "Verify Proper Storage and Existence of Password Hashes"
      },
      "id": "password_storage",
      "title": [
        {
          "#text": "Verify All Account Password Hashes are Shadowed",
          "@_lang": "en-US"
        }
      ],
      "desc": "If any password hashes are stored in(in the second field, instead of anor), the cause of this misconfiguration should be investigated. The account should have its password reset and the hash should be properly stored, or the account should be deleted entirely.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "password_storage",
        "rid": "accounts_password_all_shadowed_sha512",
        "gtitle": "Verify Proper Storage and Existence of Password Hashes"
      },
      "id": "password_storage",
      "title": [
        {
          "#text": "Verify All Account Password Hashes are Shadowed with SHA512",
          "@_lang": "en-US"
        }
      ],
      "desc": "Verify the operating system requires the shadow password suite configuration be set to encrypt interactive user passwords using a strong cryptographic hash. Check that the interactive user account passwords are using a strong password hash with the following command:Password hashesorindicate inactive accounts not available for logon and are not evaluated. If any interactive user password hash does not begin with, this is a finding.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "password_storage",
        "rid": "gid_passwd_group_same",
        "gtitle": "Verify Proper Storage and Existence of Password Hashes"
      },
      "id": "password_storage",
      "title": [
        {
          "#text": "All GIDs referenced in /etc/passwd must be defined in /etc/group",
          "@_lang": "en-US"
        }
      ],
      "desc": "Add a group to the system for each GID referenced without a corresponding group.",
      "impact": 0.3,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gid": "password_storage",
        "rid": "no_empty_passwords",
        "gtitle": "Verify Proper Storage and Existence of Password Hashes"
      },
      "id": "password_storage",
      "title": [
        {
          "#text": "Prevent Login to Accounts With Empty Password",
          "@_lang": "en-US"
        }
      ],
      "desc": "If an account is configured for password authentication but does not have an assigned password, it may be possible to log into the account without authentication. Remove any instances of theinto prevent logins with empty passwords. Note that this rule is not applicable for systems running within a container. Having user with empty password within a container is not considered a risk, because it should not be possible to directly login into a container anyway.",
      "impact": 0.7,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "password_storage",
        "rid": "no_netrc_files",
        "gtitle": "Verify Proper Storage and Existence of Password Hashes"
      },
      "id": "password_storage",
      "title": [
        {
          "#text": "Verify No netrc Files Exist",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thefiles contain login information used to auto-login into FTP servers and reside in the user's home directory. These files may contain unencrypted passwords to remote FTP servers making them susceptible to access by unauthorized users and should not be used. Anyfiles should be removed.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_important_account_files",
        "rid": "file_groupowner_backup_etc_group",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "fix_id": "file_groupowner_backup_etc_group"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify Group Who Owns Backup group File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chgrp 0 /etc/group-"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_important_account_files",
        "rid": "file_groupowner_backup_etc_gshadow",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "fix_id": "file_groupowner_backup_etc_gshadow"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify Group Who Owns Backup gshadow File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chgrp 42 /etc/gshadow-"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_important_account_files",
        "rid": "file_groupowner_backup_etc_passwd",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "fix_id": "file_groupowner_backup_etc_passwd"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify Group Who Owns Backup passwd File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chgrp 0 /etc/passwd-"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_important_account_files",
        "rid": "file_groupowner_backup_etc_shadow",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "fix_id": "file_groupowner_backup_etc_shadow"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify User Who Owns Backup shadow File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chgrp 42 /etc/shadow-"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_important_account_files",
        "rid": "file_groupowner_etc_group",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "fix_id": "file_groupowner_etc_group"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify Group Who Owns group File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chgrp 0 /etc/group"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_important_account_files",
        "rid": "file_groupowner_etc_gshadow",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "fix_id": "file_groupowner_etc_gshadow"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify Group Who Owns gshadow File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chgrp 42 /etc/gshadow"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_important_account_files",
        "rid": "file_groupowner_etc_passwd",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "fix_id": "file_groupowner_etc_passwd"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify Group Who Owns passwd File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chgrp 0 /etc/passwd"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_important_account_files",
        "rid": "file_groupowner_etc_shadow",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "fix_id": "file_groupowner_etc_shadow"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify Group Who Owns shadow File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chgrp 42 /etc/shadow"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_important_account_files",
        "rid": "file_owner_backup_etc_group",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "fix_id": "file_owner_backup_etc_group"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify User Who Owns Backup group File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chown 0 /etc/group-"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_important_account_files",
        "rid": "file_owner_backup_etc_gshadow",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "fix_id": "file_owner_backup_etc_gshadow"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify User Who Owns Backup gshadow File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chown 0 /etc/gshadow-"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_important_account_files",
        "rid": "file_owner_backup_etc_passwd",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "fix_id": "file_owner_backup_etc_passwd"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify User Who Owns Backup passwd File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chown 0 /etc/passwd-"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_important_account_files",
        "rid": "file_owner_backup_etc_shadow",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "fix_id": "file_owner_backup_etc_shadow"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify Group Who Owns Backup shadow File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chown 0 /etc/shadow-"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_important_account_files",
        "rid": "file_owner_etc_group",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "fix_id": "file_owner_etc_group"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify User Who Owns group File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chown 0 /etc/group"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_important_account_files",
        "rid": "file_owner_etc_gshadow",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "fix_id": "file_owner_etc_gshadow"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify User Who Owns gshadow File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chown 0 /etc/gshadow"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_important_account_files",
        "rid": "file_owner_etc_passwd",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "fix_id": "file_owner_etc_passwd"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify User Who Owns passwd File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chown 0 /etc/passwd"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_important_account_files",
        "rid": "file_owner_etc_shadow",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "fix_id": "file_owner_etc_shadow"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify User Who Owns shadow File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chown 0 /etc/shadow"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_important_account_files",
        "rid": "file_permissions_backup_etc_group",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "fix_id": "file_permissions_backup_etc_group"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify Permissions on Backup group File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chmod 0644 /etc/group-"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_important_account_files",
        "rid": "file_permissions_backup_etc_gshadow",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "fix_id": "file_permissions_backup_etc_gshadow"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify Permissions on Backup gshadow File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chmod 0640 /etc/gshadow-"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_important_account_files",
        "rid": "file_permissions_backup_etc_passwd",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "fix_id": "file_permissions_backup_etc_passwd"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify Permissions on Backup passwd File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chmod 0644 /etc/passwd-"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_important_account_files",
        "rid": "file_permissions_backup_etc_shadow",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "fix_id": "file_permissions_backup_etc_shadow"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify Permissions on Backup shadow File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chmod 0640 /etc/shadow-"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_important_account_files",
        "rid": "file_permissions_etc_group",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "fix_id": "file_permissions_etc_group"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify Permissions on group File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chmod 0644 /etc/group"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_important_account_files",
        "rid": "file_permissions_etc_gshadow",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "fix_id": "file_permissions_etc_gshadow"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify Permissions on gshadow File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chmod 0640 /etc/gshadow"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_important_account_files",
        "rid": "file_permissions_etc_passwd",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "fix_id": "file_permissions_etc_passwd"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify Permissions on passwd File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chmod 0644 /etc/passwd"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_important_account_files",
        "rid": "file_permissions_etc_shadow",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "fix_id": "file_permissions_etc_shadow"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify Permissions on shadow File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chmod 0640 /etc/shadow"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_var_log_dir",
        "rid": "file_groupowner_var_log",
        "gtitle": "Verify Permissions on Files within /var/log Directory",
        "fix_id": "file_groupowner_var_log"
      },
      "id": "permissions_var_log_dir",
      "title": [
        {
          "#text": "Verify Group Who Owns /var/log Directory",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chgrp 0 /var/log/"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_var_log_dir",
        "rid": "file_groupowner_var_log_messages",
        "gtitle": "Verify Permissions on Files within /var/log Directory",
        "fix_id": "file_groupowner_var_log_messages"
      },
      "id": "permissions_var_log_dir",
      "title": [
        {
          "#text": "Verify Group Who Owns /var/log/messages File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chgrp 0 /var/log/messages"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_var_log_dir",
        "rid": "file_owner_var_log",
        "gtitle": "Verify Permissions on Files within /var/log Directory",
        "fix_id": "file_owner_var_log"
      },
      "id": "permissions_var_log_dir",
      "title": [
        {
          "#text": "Verify User Who Owns /var/log Directory",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chown 0 /var/log/"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_var_log_dir",
        "rid": "file_owner_var_log_messages",
        "gtitle": "Verify Permissions on Files within /var/log Directory",
        "fix_id": "file_owner_var_log_messages"
      },
      "id": "permissions_var_log_dir",
      "title": [
        {
          "#text": "Verify User Who Owns /var/log/messages File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chown 0 /var/log/messages"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_var_log_dir",
        "rid": "file_permissions_var_log",
        "gtitle": "Verify Permissions on Files within /var/log Directory",
        "fix_id": "file_permissions_var_log"
      },
      "id": "permissions_var_log_dir",
      "title": [
        {
          "#text": "Verify Permissions on /var/log Directory",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chmod 0755 /var/log/"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_var_log_dir",
        "rid": "file_permissions_var_log_messages",
        "gtitle": "Verify Permissions on Files within /var/log Directory",
        "fix_id": "file_permissions_var_log_messages"
      },
      "id": "permissions_var_log_dir",
      "title": [
        {
          "#text": "Verify Permissions on /var/log/messages File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chmod 0640 /var/log/messages"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_within_important_dirs",
        "rid": "dir_ownership_library_dirs",
        "gtitle": "Verify File Permissions Within Some Important Directories"
      },
      "id": "permissions_within_important_dirs",
      "title": [
        {
          "#text": "Verify that Shared Library Directories Have Root Ownership",
          "@_lang": "en-US"
        }
      ],
      "desc": "System-wide shared library files, which are linked to executables during process load time or run time, are stored in the following directories by default:Kernel modules, which can be added to the kernel during runtime, are also stored in. All files in these directories should be owned by theuser. If the directories, is found to be owned by a user other than root correct its ownership with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_within_important_dirs",
        "rid": "dir_permissions_library_dirs",
        "gtitle": "Verify File Permissions Within Some Important Directories",
        "fix_id": "dir_permissions_library_dirs"
      },
      "id": "permissions_within_important_dirs",
      "title": [
        {
          "#text": "Verify that Shared Library Directories Have Restrictive Permissions",
          "@_lang": "en-US"
        }
      ],
      "desc": "System-wide shared library directories, which contain are linked to executables during process load time or run time, are stored in the following directories by default:Kernel modules, which can be added to the kernel during runtime, are stored in. All sub-directories in these directories should not be group-writable or world-writable. If any file in these directories is found to be group-writable or world-writable, correct its permission with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "DIRS=\"/lib /lib64 /usr/lib /usr/lib64\" for dirPath in $DIRS; do  find \"$dirPath\" -perm /022 -type d -exec chmod go-w '{}' \\; done"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_within_important_dirs",
        "rid": "file_groupownership_system_commands_dirs",
        "gtitle": "Verify File Permissions Within Some Important Directories"
      },
      "id": "permissions_within_important_dirs",
      "title": [
        {
          "#text": "Verify that system commands files are group owned by root",
          "@_lang": "en-US"
        }
      ],
      "desc": "System commands files are stored in the following directories by default:All files in these directories should be owned by thegroup. If the directory, or any file in these directories, is found to be owned by a group other than root correct its ownership with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_within_important_dirs",
        "rid": "file_ownership_binary_dirs",
        "gtitle": "Verify File Permissions Within Some Important Directories"
      },
      "id": "permissions_within_important_dirs",
      "title": [
        {
          "#text": "Verify that System Executables Have Root Ownership",
          "@_lang": "en-US"
        }
      ],
      "desc": "System executables are stored in the following directories by default:All files in these directories should be owned by theuser. If any filein these directories is found to be owned by a user other than root, correct its ownership with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_within_important_dirs",
        "rid": "file_ownership_library_dirs",
        "gtitle": "Verify File Permissions Within Some Important Directories"
      },
      "id": "permissions_within_important_dirs",
      "title": [
        {
          "#text": "Verify that Shared Library Files Have Root Ownership",
          "@_lang": "en-US"
        }
      ],
      "desc": "System-wide shared library files, which are linked to executables during process load time or run time, are stored in the following directories by default:Kernel modules, which can be added to the kernel during runtime, are also stored in. All files in these directories should be owned by theuser. If the directory, or any file in these directories, is found to be owned by a user other than root correct its ownership with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_within_important_dirs",
        "rid": "file_permissions_binary_dirs",
        "gtitle": "Verify File Permissions Within Some Important Directories"
      },
      "id": "permissions_within_important_dirs",
      "title": [
        {
          "#text": "Verify that System Executables Have Restrictive Permissions",
          "@_lang": "en-US"
        }
      ],
      "desc": "System executables are stored in the following directories by default:All files in these directories should not be group-writable or world-writable. If any filein these directories is found to be group-writable or world-writable, correct its permission with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "permissions_within_important_dirs",
        "rid": "file_permissions_library_dirs",
        "gtitle": "Verify File Permissions Within Some Important Directories",
        "fix_id": "file_permissions_library_dirs"
      },
      "id": "permissions_within_important_dirs",
      "title": [
        {
          "#text": "Verify that Shared Library Files Have Restrictive Permissions",
          "@_lang": "en-US"
        }
      ],
      "desc": "System-wide shared library files, which are linked to executables during process load time or run time, are stored in the following directories by default:Kernel modules, which can be added to the kernel during runtime, are stored in. All files in these directories should not be group-writable or world-writable. If any file in these directories is found to be group-writable or world-writable, correct its permission with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "DIRS=\"/lib /lib64 /usr/lib /usr/lib64\" for dirPath in $DIRS; do  find \"$dirPath\" -perm /022 -type f -exec chmod go-w '{}' \\; done"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "postfix_client",
        "rid": "postfix_client_configure_mail_alias",
        "gtitle": "Configure SMTP For Mail Clients",
        "fix_id": "postfix_client_configure_mail_alias"
      },
      "id": "postfix_client",
      "title": [
        {
          "#text": "Configure System to Forward All Mail For The Root Account",
          "@_lang": "en-US"
        }
      ],
      "desc": "Make sure that mails delivered to root user are forwarded to a monitored email address. Make sure that the addressis a valid email address reachable from the system in question. Use the following command to configure the alias:",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then var_postfix_root_mail_alias=\"\" # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/aliases\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^root\") # shellcheck disable=SC2059 printf -v formatted_output \"%s: %s\" \"$stripped_key\" \"$var_postfix_root_mail_alias\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^root\\\\&gt;\" \"/etc/aliases\"; then \"${sed_command[@]}\" \"s/^root\\\\&gt;.*/$formatted_output/gi\" \"/etc/aliases\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/aliases\" &gt;&gt; \"/etc/aliases\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/aliases\" fi newaliases else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "postfix_client",
        "rid": "postfix_client_configure_relayhost",
        "gtitle": "Configure SMTP For Mail Clients"
      },
      "id": "postfix_client",
      "title": [
        {
          "#text": "Configure System to Forward All Mail through a specific host",
          "@_lang": "en-US"
        }
      ],
      "desc": "Set up a relay host that will act as a gateway for all outbound email. Edit the fileto ensure that only the followingline appears:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "printing",
        "rid": "service_cups_disabled",
        "gtitle": "Print Support",
        "fix_id": "service_cups_disabled"
      },
      "id": "printing",
      "title": [
        {
          "#text": "Disable the CUPS Service",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice can be disabled with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" stop 'cups.service' \"$SYSTEMCTL_EXEC\" disable 'cups.service' \"$SYSTEMCTL_EXEC\" mask 'cups.service' # Disable socket activation if we have a unit file for it if \"$SYSTEMCTL_EXEC\" list-unit-files | grep -q '^cups.socket'; then \"$SYSTEMCTL_EXEC\" stop 'cups.socket' \"$SYSTEMCTL_EXEC\" mask 'cups.socket' fi # The service may not be running because it has been started and failed, # so let's reset the state so OVAL checks pass. # Service should be 'inactive', not 'failed' after reboot though. \"$SYSTEMCTL_EXEC\" reset-failed 'cups.service' || true else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gid": "r_services",
        "rid": "package_rsh-server_removed",
        "gtitle": "Rlogin, Rsh, and Rexec",
        "fix_id": "package_rsh-server_removed"
      },
      "id": "r_services",
      "title": [
        {
          "#text": "Uninstall rsh-server Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be removed with the following command:",
      "impact": 0.7,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove rsh-server #  from the system, and may remove any packages #  that depend on rsh-server. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"rsh-server\""
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "r_services",
        "rid": "package_rsh_removed",
        "gtitle": "Rlogin, Rsh, and Rexec",
        "fix_id": "package_rsh_removed"
      },
      "id": "r_services",
      "title": [
        {
          "#text": "Uninstall rsh Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage contains the client commands for the rsh services",
      "impact": 0.5,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove rsh-client #  from the system, and may remove any packages #  that depend on rsh-client. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"rsh-client\""
      }
    },
    {
      "tags": {
        "severity": "high",
        "gid": "r_services",
        "rid": "no_rsh_trust_files",
        "gtitle": "Rlogin, Rsh, and Rexec"
      },
      "id": "r_services",
      "title": [
        {
          "#text": "Remove Rsh Trust Files",
          "@_lang": "en-US"
        }
      ],
      "desc": "The filesand(in each user's home directory) list remote hosts and users that are trusted by the local system when using the rshd daemon. To remove these files, run the following command to delete them from any location:",
      "impact": 0.7,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "restrict_at_cron_users",
        "rid": "file_groupowner_at_allow",
        "gtitle": "Restrict at and cron to Authorized Users if Necessary",
        "fix_id": "file_groupowner_at_allow"
      },
      "id": "restrict_at_cron_users",
      "title": [
        {
          "#text": "Verify Group Who Owns /etc/at.allow file",
          "@_lang": "en-US"
        }
      ],
      "desc": "Ifexists, it must be group-owned by. To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chgrp 0 /etc/at.allow else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "restrict_at_cron_users",
        "rid": "file_groupowner_cron_allow",
        "gtitle": "Restrict at and cron to Authorized Users if Necessary",
        "fix_id": "file_groupowner_cron_allow"
      },
      "id": "restrict_at_cron_users",
      "title": [
        {
          "#text": "Verify Group Who Owns /etc/cron.allow file",
          "@_lang": "en-US"
        }
      ],
      "desc": "Ifexists, it must be group-owned by. To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chgrp 0 /etc/cron.allow else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "restrict_at_cron_users",
        "rid": "file_owner_at_allow",
        "gtitle": "Restrict at and cron to Authorized Users if Necessary",
        "fix_id": "file_owner_at_allow"
      },
      "id": "restrict_at_cron_users",
      "title": [
        {
          "#text": "Verify User Who Owns /etc/at.allow file",
          "@_lang": "en-US"
        }
      ],
      "desc": "Ifexists, it must be owned by. To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chown 0 /etc/at.allow else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "restrict_at_cron_users",
        "rid": "file_owner_cron_allow",
        "gtitle": "Restrict at and cron to Authorized Users if Necessary",
        "fix_id": "file_owner_cron_allow"
      },
      "id": "restrict_at_cron_users",
      "title": [
        {
          "#text": "Verify User Who Owns /etc/cron.allow file",
          "@_lang": "en-US"
        }
      ],
      "desc": "Ifexists, it must be owned by. To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chown 0 /etc/cron.allow else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "restrict_at_cron_users",
        "rid": "file_permissions_at_allow",
        "gtitle": "Restrict at and cron to Authorized Users if Necessary",
        "fix_id": "file_permissions_at_allow"
      },
      "id": "restrict_at_cron_users",
      "title": [
        {
          "#text": "Verify Permissions on /etc/at.allow file",
          "@_lang": "en-US"
        }
      ],
      "desc": "Ifexists, it must have permissionsor more restrictive. To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chmod 0640 /etc/at.allow else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "restrict_at_cron_users",
        "rid": "file_permissions_cron_allow",
        "gtitle": "Restrict at and cron to Authorized Users if Necessary",
        "fix_id": "file_permissions_cron_allow"
      },
      "id": "restrict_at_cron_users",
      "title": [
        {
          "#text": "Verify Permissions on /etc/cron.allow file",
          "@_lang": "en-US"
        }
      ],
      "desc": "Ifexists, it must have permissionsor more restrictive. To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chmod 0640 /etc/cron.allow else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gid": "root_logins",
        "rid": "accounts_no_uid_except_zero",
        "gtitle": "Restrict Root Logins",
        "fix_id": "accounts_no_uid_except_zero"
      },
      "id": "root_logins",
      "title": [
        {
          "#text": "Verify Only Root Has UID 0",
          "@_lang": "en-US"
        }
      ],
      "desc": "If any account other than root has a UID of 0, this misconfiguration should be investigated and the accounts other than root should be removed or have their UID changed.If the account is associated with system commands or applications the UID should be changed to one greater than \"0\" but less than \"1000.\" Otherwise assign a UID greater than \"1000\" that has not already been assigned.",
      "impact": 0.7,
      "descs": {
        "fix": "awk -F: '$3 == 0 &amp;&amp; $1 != \"root\" { print $1 }' /etc/passwd | xargs --max-lines=1 passwd -l"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "root_logins",
        "rid": "no_direct_root_logins",
        "gtitle": "Restrict Root Logins",
        "fix_id": "no_direct_root_logins"
      },
      "id": "root_logins",
      "title": [
        {
          "#text": "Direct root Logins Not Allowed",
          "@_lang": "en-US"
        }
      ],
      "desc": "To further limit access to theaccount, administrators can disable root logins at the console by editing thefile. This file lists all devices the root user is allowed to login to. If the file does not exist at all, the root user can login through any communication device on the system, whether via the console or via a raw network interface. This is dangerous as user can login to the system as root via Telnet, which sends the password in plain text over the network. By default, Ubuntu 20.04'sfile only allows the root user to login at the console physically attached to the system. To prevent root from logging in, remove the contents of this file. To prevent direct root logins, remove the contents of this file by typing the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then echo &gt; /etc/securetty else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "root_logins",
        "rid": "no_password_auth_for_systemaccounts",
        "gtitle": "Restrict Root Logins"
      },
      "id": "root_logins",
      "title": [
        {
          "#text": "Ensure that System Accounts Are Locked",
          "@_lang": "en-US"
        }
      ],
      "desc": "Some accounts are not associated with a human user of the system, and exist to perform some administrative function. An attacker should not be able to log into these accounts.System accounts are those user accounts with a user ID less than UID_MIN, where value of the UID_MIN directive is set inconfiguration file. In the default configuration UID_MIN is set to 500, thus system accounts are those user accounts with a user ID less than 500. If any system account(other than root) has an unlocked password, disable it with the command:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "root_logins",
        "rid": "no_shelllogin_for_systemaccounts",
        "gtitle": "Restrict Root Logins"
      },
      "id": "root_logins",
      "title": [
        {
          "#text": "Ensure that System Accounts Do Not Run a Shell Upon Login",
          "@_lang": "en-US"
        }
      ],
      "desc": "Some accounts are not associated with a human user of the system, and exist to perform some administrative function. Should an attacker be able to log into these accounts, they should not be granted access to a shell.The login shell for each local account is stored in the last field of each line in. System accounts are those user accounts with a user ID less than UID_MIN, where value of UID_MIN directive is set in /etc/login.defs configuration file. In the default configuration UID_MIN is set to 1000, thus system accounts are those user accounts with a user ID less than 1000. The user ID is stored in the third field. If any system account(other than root) has a login shell, disable it with the command:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "root_logins",
        "rid": "restrict_serial_port_logins",
        "gtitle": "Restrict Root Logins",
        "fix_id": "restrict_serial_port_logins"
      },
      "id": "root_logins",
      "title": [
        {
          "#text": "Restrict Serial Port Root Logins",
          "@_lang": "en-US"
        }
      ],
      "desc": "To restrict root logins on serial ports, ensure lines of this form do not appear in:",
      "impact": 0.5,
      "descs": {
        "fix": "sed -i '/ttyS/d' /etc/securetty"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "root_logins",
        "rid": "securetty_root_login_console_only",
        "gtitle": "Restrict Root Logins",
        "fix_id": "securetty_root_login_console_only"
      },
      "id": "root_logins",
      "title": [
        {
          "#text": "Restrict Virtual Console Root Logins",
          "@_lang": "en-US"
        }
      ],
      "desc": "To restrict root logins through the (deprecated) virtual console devices, ensure lines of this form do not appear in:",
      "impact": 0.5,
      "descs": {
        "fix": "sed -i '/^vc\\//d' /etc/securetty"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "root_logins",
        "rid": "use_pam_wheel_for_su",
        "gtitle": "Restrict Root Logins"
      },
      "id": "root_logins",
      "title": [
        {
          "#text": "Enforce usage of pam_wheel for su authentication",
          "@_lang": "en-US"
        }
      ],
      "desc": "To ensure that only users who are members of thegroup can run commands with altered privileges through thecommand, make sure that the following line exists in the file:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "root_paths",
        "rid": "accounts_root_path_dirs_no_write",
        "gtitle": "Ensure that No Dangerous Directories Exist in Root's Path"
      },
      "id": "root_paths",
      "title": [
        {
          "#text": "Ensure that Root's Path Does Not Include World or Group-Writable Directories",
          "@_lang": "en-US"
        }
      ],
      "desc": "For each element in root's path, run:and ensure that write permissions are disabled for group and other.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "root_paths",
        "rid": "root_path_no_dot",
        "gtitle": "Ensure that No Dangerous Directories Exist in Root's Path"
      },
      "id": "root_paths",
      "title": [
        {
          "#text": "Ensure that Root's Path Does Not Include Relative Paths or Null Directories",
          "@_lang": "en-US"
        }
      ],
      "desc": "Ensure that none of the directories in root's path is equal to a singlecharacter, or that it contains any instances that lead to relative path traversal, such asor beginning a path without the slash () character. Also ensure that there are no \"empty\" elements in the path, such as in these examples:These empty elements have the same effect as a singlecharacter.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "rsyslog_accepting_remote_messages",
        "rid": "package_syslogng_installed",
        "gtitle": "Configure rsyslogd to Accept Remote Messages If Acting as a Log Server",
        "fix_id": "package_syslogng_installed"
      },
      "id": "rsyslog_accepting_remote_messages",
      "title": [
        {
          "#text": "Ensure syslog-ng is Installed",
          "@_lang": "en-US"
        }
      ],
      "desc": "syslog-ng can be installed in replacement of rsyslog. Thepackage can be installed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"syslogng\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "rsyslog_accepting_remote_messages",
        "rid": "service_syslogng_enabled",
        "gtitle": "Configure rsyslogd to Accept Remote Messages If Acting as a Log Server",
        "fix_id": "service_syslogng_enabled"
      },
      "id": "rsyslog_accepting_remote_messages",
      "title": [
        {
          "#text": "Enable syslog-ng Service",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice (in replacement of rsyslog) provides syslog-style logging by default on Debian. Theservice can be enabled with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" unmask 'syslogng.service' \"$SYSTEMCTL_EXEC\" start 'syslogng.service' \"$SYSTEMCTL_EXEC\" enable 'syslogng.service' else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "rsyslog_accepting_remote_messages",
        "rid": "rsyslog_accept_remote_messages_tcp",
        "gtitle": "Configure rsyslogd to Accept Remote Messages If Acting as a Log Server"
      },
      "id": "rsyslog_accepting_remote_messages",
      "title": [
        {
          "#text": "Enable rsyslog to Accept Messages via TCP, if Acting As Log Server",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thedaemon should not accept remote messages unless the system acts as a log server. If the system needs to act as a central log server, add the following lines toto enable reception of messages over TCP:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "rsyslog_accepting_remote_messages",
        "rid": "rsyslog_accept_remote_messages_udp",
        "gtitle": "Configure rsyslogd to Accept Remote Messages If Acting as a Log Server"
      },
      "id": "rsyslog_accepting_remote_messages",
      "title": [
        {
          "#text": "Enable rsyslog to Accept Messages via UDP, if Acting As Log Server",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thedaemon should not accept remote messages unless the system acts as a log server. If the system needs to act as a central log server, add the following lines toto enable reception of messages over UDP:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "rsyslog_sending_messages",
        "rid": "rsyslog_remote_loghost",
        "gtitle": "Rsyslog Logs Sent To Remote Host"
      },
      "id": "rsyslog_sending_messages",
      "title": [
        {
          "#text": "Ensure Logs Sent To Remote Host",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure rsyslog to send logs to a remote log server, openand read and understand the last section of the file, which describes the multiple directives necessary to activate remote logging. Along with these other directives, the system can be configured to forward its logs to a particular log server by adding or correcting one of the following lines, substitutingappropriately. The choice of protocol depends on the environment of the system; although TCP and RELP provide more reliable message delivery, they may not be supported in all environments.To use UDP for log message delivery:To use TCP for log message delivery:To use RELP for log message delivery:There must be a resolvable DNS CNAME or Alias record set to \"\" for logs to be sent correctly to the centralized logging utility.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "selinux",
        "rid": "selinux_state",
        "gtitle": "SELinux"
      },
      "id": "selinux",
      "title": [
        {
          "#text": "Ensure SELinux State is Enforcing",
          "@_lang": "en-US"
        }
      ],
      "desc": "The SELinux state should be set toat system boot time. In the file, add or correct the following line to configure the system to boot into enforcing mode:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "set_password_hashing_algorithm",
        "rid": "set_password_hashing_algorithm_logindefs",
        "gtitle": "Set Password Hashing Algorithm"
      },
      "id": "set_password_hashing_algorithm",
      "title": [
        {
          "#text": "Set Password Hashing Algorithm in /etc/login.defs",
          "@_lang": "en-US"
        }
      ],
      "desc": "In, add or correct the following line to ensure the system will use SHA-512 as the hashing algorithm:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "smart_card_login",
        "rid": "package_opensc_installed",
        "gtitle": "Hardware Tokens for Authentication",
        "fix_id": "package_opensc_installed"
      },
      "id": "smart_card_login",
      "title": [
        {
          "#text": "Install the opensc Package For Multifactor Authentication",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be installed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"opensc-pkcs11\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "smart_card_login",
        "rid": "install_smartcard_packages",
        "gtitle": "Hardware Tokens for Authentication",
        "fix_id": "install_smartcard_packages"
      },
      "id": "smart_card_login",
      "title": [
        {
          "#text": "Install Smart Card Packages For Multifactor Authentication",
          "@_lang": "en-US"
        }
      ],
      "desc": "Configure the operating system to implement multifactor authentication by installing the required package with the following command: Thepackage can be installed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"libpam-pkcs11\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "smart_card_login",
        "rid": "smartcard_configure_ca",
        "gtitle": "Hardware Tokens for Authentication",
        "fix_id": "smartcard_configure_ca"
      },
      "id": "smart_card_login",
      "title": [
        {
          "#text": "Configure Smart Card Certificate Authority Validation",
          "@_lang": "en-US"
        }
      ],
      "desc": "Configure the operating system to do certificate status checking for PKI authentication. Modify all of thelines into includelike so:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ ! -f /etc/pam_pkcs11/pam_pkcs11.conf ]; then cp /usr/share/doc/libpam-pkcs11/examples/pam_pkcs11.conf.example /etc/pam_pkcs11/pam_pkcs11.conf fi if grep -v \"^\\s*\\#+cert_policy\" /etc/pam_pkcs11/pam_pkcs11.conf | grep -qv \"ca\"; then sed -i \"s/\\(^[[:blank:]]*\\)\\(\\(\\#*[[:blank:]]*cert_policy[[:blank:]]*=[[:blank:]]*.*;\\)[^ $]*\\)/\\1cert_policy = ca,signature,ocsp_on;/\" /etc/pam_pkcs11/pam_pkcs11.conf fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "smart_card_login",
        "rid": "smartcard_configure_cert_checking",
        "gtitle": "Hardware Tokens for Authentication",
        "fix_id": "smartcard_configure_cert_checking"
      },
      "id": "smart_card_login",
      "title": [
        {
          "#text": "Configure Smart Card Certificate Status Checking",
          "@_lang": "en-US"
        }
      ],
      "desc": "Configure the operating system to do certificate status checking for PKI authentication. Modify all of thelines into includelike so:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ ! -f /etc/pam_pkcs11/pam_pkcs11.conf ]; then cp /usr/share/doc/libpam-pkcs11/examples/pam_pkcs11.conf.example /etc/pam_pkcs11/pam_pkcs11.conf fi if grep -v \"^\\s*\\#+cert_policy\" /etc/pam_pkcs11/pam_pkcs11.conf | grep -qv \"oscp_on\"; then sed -i \"s/\\(^[[:blank:]]*\\)\\(\\(\\#*[[:blank:]]*cert_policy[[:blank:]]*=[[:blank:]]*.*;\\)[^ $]*\\)/\\1cert_policy = ca,signature,ocsp_on;/\" /etc/pam_pkcs11/pam_pkcs11.conf fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "smart_card_login",
        "rid": "smartcard_configure_crl",
        "gtitle": "Hardware Tokens for Authentication",
        "fix_id": "smartcard_configure_crl"
      },
      "id": "smart_card_login",
      "title": [
        {
          "#text": "Configure Smart Card Local Cache of Revocation Data",
          "@_lang": "en-US"
        }
      ],
      "desc": "Configure the operating system for PKI-based authentication to use local revocation data when unable to access the network to obtain it remotely. Modify all of thelines into includeorlike so:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ ! -f /etc/pam_pkcs11/pam_pkcs11.conf ]; then cp /usr/share/doc/libpam-pkcs11/examples/pam_pkcs11.conf.example /etc/pam_pkcs11/pam_pkcs11.conf fi if grep -v \"^\\s*\\#+cert_policy\" /etc/pam_pkcs11/pam_pkcs11.conf | grep -Eqv 'crl_auto|crl_offline'; then sed -i \"s/\\(^[[:blank:]]*\\)\\(\\(\\#*[[:blank:]]*cert_policy[[:blank:]]*=[[:blank:]]*.*;\\)[^ $]*\\)/\\1cert_policy = ca,signature,ocsp_on,crl_auto;/\" /etc/pam_pkcs11/pam_pkcs11.conf fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "smart_card_login",
        "rid": "smartcard_pam_enabled",
        "gtitle": "Hardware Tokens for Authentication",
        "fix_id": "smartcard_pam_enabled"
      },
      "id": "smart_card_login",
      "title": [
        {
          "#text": "Enable Smart Card Logins in PAM",
          "@_lang": "en-US"
        }
      ],
      "desc": "This requirement only applies to components where this is specific to the function of the device or has the concept of an organizational user (e.g., VPN, proxy capability). This does not apply to authentication for the purpose of configuring the device itself (management). Check that theoption is configured in thefile with the following command:For general information about enabling smart card authentication, consult the documentation at:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/pam.d/common-auth\" ] ; then valueRegex=\"\" defaultValue=\"\" # non-empty values need to be preceded by an equals sign [ -n \"${valueRegex}\" ] &amp;&amp; valueRegex=\"=${valueRegex}\" # add an equals sign to non-empty values [ -n \"${defaultValue}\" ] &amp;&amp; defaultValue=\"=${defaultValue}\" # fix 'type' if it's wrong if grep -q -P \"^\\\\s*(?\"'!'\"auth\\\\s)[[:alnum:]]+\\\\s+[[:alnum:]]+\\\\s+pam_pkcs11.so\" &lt; \"/etc/pam.d/common-auth\" ; then sed --follow-symlinks -i -E -e \"s/^(\\\\s*)[[:alnum:]]+(\\\\s+[[:alnum:]]+\\\\s+pam_pkcs11.so)/\\\\1auth\\\\2/\" \"/etc/pam.d/common-auth\" fi # fix 'control' if it's wrong if grep -q -P \"^\\\\s*auth\\\\s+(?\"'!'\"[success=2 default=ignore])[[:alnum:]]+\\\\s+pam_pkcs11.so\" &lt; \"/etc/pam.d/common-auth\" ; then sed --follow-symlinks -i -E -e \"s/^(\\\\s*auth\\\\s+)[[:alnum:]]+(\\\\s+pam_pkcs11.so)/\\\\1[success=2 default=ignore]\\\\2/\" \"/etc/pam.d/common-auth\" fi # fix the value for 'option' if one exists but does not match 'valueRegex' if grep -q -P \"^\\\\s*auth\\\\s+[success=2 default=ignore]\\\\s+pam_pkcs11.so(\\\\s.+)?\\\\s+(?\"'!'\"${valueRegex}(\\\\s|\\$))\" &lt; \"/etc/pam.d/common-auth\" ; then sed --follow-symlinks -i -E -e \"s/^(\\\\s*auth\\\\s+[success=2 default=ignore]\\\\s+pam_pkcs11.so(\\\\s.+)?\\\\s)=[^[:space:]]*/\\\\1${defaultValue}/\" \"/etc/pam.d/common-auth\" # add 'option=default' if option is not set elif grep -q -E \"^\\\\s*auth\\\\s+[success=2 default=ignore]\\\\s+pam_pkcs11.so\" &lt; \"/etc/pam.d/common-auth\" &amp;&amp; grep -E \"^\\\\s*auth\\\\s+[success=2 default=ignore]\\\\s+pam_pkcs11.so\" &lt; \"/etc/pam.d/common-auth\" | grep -q -E -v \"\\\\s(=|\\\\s|\\$)\" ; then sed --follow-symlinks -i -E -e \"s/^(\\\\s*auth\\\\s+[success=2 default=ignore]\\\\s+pam_pkcs11.so[^\\ ]*)/\\\\1 ${defaultValue}/\" \"/etc/pam.d/common-auth\" # add a new entry if none exists elif ! grep -q -P \"^\\\\s*auth\\\\s+[success=2 default=ignore]\\\\s+pam_pkcs11.so(\\\\s.+)?\\\\s+${valueRegex}(\\\\s|\\$)\" &lt; \"/etc/pam.d/common-auth\" ; then echo \"auth [success=2 default=ignore] pam_pkcs11.so ${defaultValue}\" &gt;&gt; \"/etc/pam.d/common-auth\" fi else echo \"/etc/pam.d/common-auth doesn't exist\" &gt;&amp;2 fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "software",
        "rid": "prefer_64bit_os",
        "gtitle": "Installing and Maintaining Software"
      },
      "id": "software",
      "title": [
        {
          "#text": "Prefer to use a 64-bit Operating System when supported",
          "@_lang": "en-US"
        }
      ],
      "desc": "Prefer installation of 64-bit operating systems when the CPU supports it.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh",
        "rid": "package_openssh-server_installed",
        "gtitle": "SSH Server",
        "fix_id": "package_openssh-server_installed"
      },
      "id": "ssh",
      "title": [
        {
          "#text": "Install the OpenSSH Server Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage should be installed. Thepackage can be installed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"openssh-server\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh",
        "rid": "package_openssh-server_removed",
        "gtitle": "SSH Server",
        "fix_id": "package_openssh-server_removed"
      },
      "id": "ssh",
      "title": [
        {
          "#text": "Remove the OpenSSH Server Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage should be removed. Thepackage can be removed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # CAUTION: This remediation script will remove openssh-server #  from the system, and may remove any packages #  that depend on openssh-server. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"openssh-server\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh",
        "rid": "service_sshd_enabled",
        "gtitle": "SSH Server",
        "fix_id": "service_sshd_enabled"
      },
      "id": "ssh",
      "title": [
        {
          "#text": "Enable the OpenSSH Service",
          "@_lang": "en-US"
        }
      ],
      "desc": "The SSH server service, sshd, is commonly needed. Theservice can be enabled with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" unmask 'ssh.service' \"$SYSTEMCTL_EXEC\" start 'ssh.service' \"$SYSTEMCTL_EXEC\" enable 'ssh.service' else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh",
        "rid": "service_sshd_disabled",
        "gtitle": "SSH Server",
        "fix_id": "service_sshd_disabled"
      },
      "id": "ssh",
      "title": [
        {
          "#text": "Disable SSH Server If Possible (Unusual)",
          "@_lang": "en-US"
        }
      ],
      "desc": "The SSH server service, sshd, is commonly needed. However, if it can be disabled, do so. Theservice can be disabled with the following command:This is unusual, as SSH is a common method for encrypted and authenticated remote access.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" stop 'sshd.service' \"$SYSTEMCTL_EXEC\" disable 'sshd.service' \"$SYSTEMCTL_EXEC\" mask 'sshd.service' # Disable socket activation if we have a unit file for it if \"$SYSTEMCTL_EXEC\" list-unit-files | grep -q '^sshd.socket'; then \"$SYSTEMCTL_EXEC\" stop 'sshd.socket' \"$SYSTEMCTL_EXEC\" mask 'sshd.socket' fi # The service may not be running because it has been started and failed, # so let's reset the state so OVAL checks pass. # Service should be 'inactive', not 'failed' after reboot though. \"$SYSTEMCTL_EXEC\" reset-failed 'sshd.service' || true else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh",
        "rid": "file_groupowner_sshd_config",
        "gtitle": "SSH Server",
        "fix_id": "file_groupowner_sshd_config"
      },
      "id": "ssh",
      "title": [
        {
          "#text": "Verify Group Who Owns SSH Server config file",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chgrp 0 /etc/ssh/sshd_config else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh",
        "rid": "file_owner_sshd_config",
        "gtitle": "SSH Server",
        "fix_id": "file_owner_sshd_config"
      },
      "id": "ssh",
      "title": [
        {
          "#text": "Verify Owner on SSH Server config file",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chown 0 /etc/ssh/sshd_config else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh",
        "rid": "file_permissions_sshd_config",
        "gtitle": "SSH Server",
        "fix_id": "file_permissions_sshd_config"
      },
      "id": "ssh",
      "title": [
        {
          "#text": "Verify Permissions on SSH Server config file",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chmod 0600 /etc/ssh/sshd_config else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh",
        "rid": "file_permissions_sshd_private_key",
        "gtitle": "SSH Server",
        "fix_id": "file_permissions_sshd_private_key"
      },
      "id": "ssh",
      "title": [
        {
          "#text": "Verify Permissions on SSH Server Private *_key Key Files",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then readarray -t files &lt; &lt;(find /etc/ssh/) for file in \"${files[@]}\"; do if basename $file | grep -q '^.*_key$'; then chmod 0600 $file fi done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh",
        "rid": "file_permissions_sshd_pub_key",
        "gtitle": "SSH Server",
        "fix_id": "file_permissions_sshd_pub_key"
      },
      "id": "ssh",
      "title": [
        {
          "#text": "Verify Permissions on SSH Server Public *.pub Key Files",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then readarray -t files &lt; &lt;(find /etc/ssh/) for file in \"${files[@]}\"; do if basename $file | grep -q '^.*.pub$'; then chmod 0644 $file fi done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh",
        "rid": "iptables_sshd_disabled",
        "gtitle": "SSH Server"
      },
      "id": "ssh",
      "title": [
        {
          "#text": "Remove SSH Server iptables Firewall exception (Unusual)",
          "@_lang": "en-US"
        }
      ],
      "desc": "By default, inbound connections to SSH's port are allowed. If the SSH server is not being used, this exception should be removed from the firewall configuration.Edit the filesand(if IPv6 is in use). In each file, locate and delete the line:This is unusual, as SSH is a common method for encrypted and authenticated remote access.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh_server",
        "rid": "disable_host_auth",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "fix_id": "disable_host_auth"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Disable Host-Based Authentication",
          "@_lang": "en-US"
        }
      ],
      "desc": "SSH's cryptographic host-based authentication is more secure thanauthentication. However, it is not recommended that hosts unilaterally trust one another, even within an organization.To disable host-based authentication, add or correct the following line in:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*HostbasedAuthentication\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"HostbasedAuthentication no\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"HostbasedAuthentication no\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gid": "ssh_server",
        "rid": "sshd_allow_only_protocol2",
        "gtitle": "Configure OpenSSH Server if Necessary"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Allow Only SSH Protocol 2",
          "@_lang": "en-US"
        }
      ],
      "desc": "Only SSH protocol version 2 connections should be permitted. The default setting inis correct, and can be verified by ensuring that the following line appears:",
      "impact": 0.7,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh_server",
        "rid": "sshd_disable_compression",
        "gtitle": "Configure OpenSSH Server if Necessary"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Disable Compression Or Set Compression to delayed",
          "@_lang": "en-US"
        }
      ],
      "desc": "Compression is useful for slow network connections over long distances but can cause performance issues on local LANs. If use of compression is required, it should be enabled only after a user has authenticated; otherwise, it should be disabled. To disable compression or delay compression until after a user has successfully authenticated, add or correct the following line in thefile:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gid": "ssh_server",
        "rid": "sshd_disable_empty_passwords",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "fix_id": "sshd_disable_empty_passwords"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Disable SSH Access via Empty Passwords",
          "@_lang": "en-US"
        }
      ],
      "desc": "To explicitly disallow SSH login from accounts with empty passwords, add or correct the following line in:Any accounts with empty passwords should be disabled immediately, and PAM configuration should prevent users from being able to assign themselves empty passwords.",
      "impact": 0.7,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*PermitEmptyPasswords\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"PermitEmptyPasswords no\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"PermitEmptyPasswords no\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh_server",
        "rid": "sshd_disable_gssapi_auth",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "fix_id": "sshd_disable_gssapi_auth"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Disable GSSAPI Authentication",
          "@_lang": "en-US"
        }
      ],
      "desc": "Unless needed, SSH should not permit extraneous or unnecessary authentication mechanisms like GSSAPI. To disable GSSAPI authentication, add or correct the following line in thefile:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*GSSAPIAuthentication\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"GSSAPIAuthentication no\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"GSSAPIAuthentication no\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh_server",
        "rid": "sshd_disable_kerb_auth",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "fix_id": "sshd_disable_kerb_auth"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Disable Kerberos Authentication",
          "@_lang": "en-US"
        }
      ],
      "desc": "Unless needed, SSH should not permit extraneous or unnecessary authentication mechanisms like Kerberos. To disable Kerberos authentication, add or correct the following line in thefile:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*KerberosAuthentication\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"KerberosAuthentication no\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"KerberosAuthentication no\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh_server",
        "rid": "sshd_disable_pubkey_auth",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "fix_id": "sshd_disable_pubkey_auth"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Disable PubkeyAuthentication Authentication",
          "@_lang": "en-US"
        }
      ],
      "desc": "Unless needed, SSH should not permit extraneous or unnecessary authentication mechanisms. To disable PubkeyAuthentication authentication, add or correct the following line in thefile:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*PubkeyAuthentication\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"PubkeyAuthentication no\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"PubkeyAuthentication no\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh_server",
        "rid": "sshd_disable_rhosts",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "fix_id": "sshd_disable_rhosts"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Disable SSH Support for .rhosts Files",
          "@_lang": "en-US"
        }
      ],
      "desc": "SSH can emulate the behavior of the obsolete rsh command in allowing users to enable insecure access to their accounts viafiles.To ensure this behavior is disabled, add or correct the following line in:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*IgnoreRhosts\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"IgnoreRhosts yes\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"IgnoreRhosts yes\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh_server",
        "rid": "sshd_disable_rhosts_rsa",
        "gtitle": "Configure OpenSSH Server if Necessary"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Disable SSH Support for Rhosts RSA Authentication",
          "@_lang": "en-US"
        }
      ],
      "desc": "SSH can allow authentication through the obsolete rsh command through the use of the authenticating user's SSH keys. This should be disabled.To ensure this behavior is disabled, add or correct the following line in:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh_server",
        "rid": "sshd_disable_root_login",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "fix_id": "sshd_disable_root_login"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Disable SSH Root Login",
          "@_lang": "en-US"
        }
      ],
      "desc": "The root user should never be allowed to login to a system directly over a network. To disable root login via SSH, add or correct the following line in:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*PermitRootLogin\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"PermitRootLogin no\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"PermitRootLogin no\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh_server",
        "rid": "sshd_disable_root_password_login",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "fix_id": "sshd_disable_root_password_login"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Disable SSH root Login with a Password (Insecure)",
          "@_lang": "en-US"
        }
      ],
      "desc": "To disable password-based root logins over SSH, add or correct the following line in:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*PermitRootLogin\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"PermitRootLogin prohibit-password\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"PermitRootLogin prohibit-password\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh_server",
        "rid": "sshd_disable_tcp_forwarding",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "fix_id": "sshd_disable_tcp_forwarding"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Disable SSH TCP Forwarding",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theparameter specifies whether TCP forwarding is permitted. To disable TCP forwarding, add or correct the following line in:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*AllowTcpForwarding\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"AllowTcpForwarding no\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"AllowTcpForwarding no\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh_server",
        "rid": "sshd_disable_user_known_hosts",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "fix_id": "sshd_disable_user_known_hosts"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Disable SSH Support for User Known Hosts",
          "@_lang": "en-US"
        }
      ],
      "desc": "SSH can allow system users to connect to systems if a cache of the remote systems public keys is available. This should be disabled.To ensure this behavior is disabled, add or correct the following line in:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*IgnoreUserKnownHosts\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"IgnoreUserKnownHosts yes\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"IgnoreUserKnownHosts yes\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh_server",
        "rid": "sshd_disable_x11_forwarding",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "fix_id": "sshd_disable_x11_forwarding"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Disable X11 Forwarding",
          "@_lang": "en-US"
        }
      ],
      "desc": "The X11Forwarding parameter provides the ability to tunnel X11 traffic through the connection to enable remote graphic connections. SSH has the capability to encrypt remote X11 connections when SSH'soption is enabled.To disable X11 Forwarding, add or correct the following line in:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*X11Forwarding\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"X11Forwarding no\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"X11Forwarding no\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh_server",
        "rid": "sshd_do_not_permit_user_env",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "fix_id": "sshd_do_not_permit_user_env"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Do Not Allow SSH Environment Options",
          "@_lang": "en-US"
        }
      ],
      "desc": "To ensure users are not able to override environment variables of the SSH daemon, add or correct the following line in:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*PermitUserEnvironment\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"PermitUserEnvironment no\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"PermitUserEnvironment no\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh_server",
        "rid": "sshd_enable_gssapi_auth",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "fix_id": "sshd_enable_gssapi_auth"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Enable GSSAPI Authentication",
          "@_lang": "en-US"
        }
      ],
      "desc": "Sites setup to use Kerberos or other GSSAPI Authenticaion require setting sshd to accept this authentication. To enable GSSAPI authentication, add or correct the following line in thefile:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*GSSAPIAuthentication\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"GSSAPIAuthentication yes\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"GSSAPIAuthentication yes\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh_server",
        "rid": "sshd_enable_strictmodes",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "fix_id": "sshd_enable_strictmodes"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Enable Use of Strict Mode Checking",
          "@_lang": "en-US"
        }
      ],
      "desc": "SSHsoption checks file and ownership permissions in the user's home directoryfolder before accepting login. If world- writable permissions are found, logon is rejected. To enablein SSH, add or correct the following line in thefile:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*StrictModes\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"StrictModes yes\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"StrictModes yes\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh_server",
        "rid": "sshd_enable_warning_banner",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "fix_id": "sshd_enable_warning_banner"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Enable SSH Warning Banner",
          "@_lang": "en-US"
        }
      ],
      "desc": "To enable the warning banner and ensure it is consistent across the system, add or correct the following line in:Another section contains information on how to create an appropriate system-wide warning banner.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*Banner\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"Banner /etc/issue\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"Banner /etc/issue\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gid": "ssh_server",
        "rid": "sshd_enable_x11_forwarding",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "fix_id": "sshd_enable_x11_forwarding"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Enable Encrypted X11 Forwarding",
          "@_lang": "en-US"
        }
      ],
      "desc": "By default, remote X11 connections are not encrypted when initiated by users. SSH has the capability to encrypt remote X11 connections when SSH'soption is enabled.To enable X11 Forwarding, add or correct the following line in:",
      "impact": 0.7,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*X11Forwarding\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"X11Forwarding yes\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"X11Forwarding yes\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh_server",
        "rid": "sshd_limit_user_access",
        "gtitle": "Configure OpenSSH Server if Necessary"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Limit Users' SSH Access",
          "@_lang": "en-US"
        }
      ],
      "desc": "By default, the SSH configuration allows any user with an account to access the system. In order to specify the users that are allowed to login via SSH and deny all other users, add or correct the following line in thefile:Whereandare valid user names.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh_server",
        "rid": "sshd_print_last_log",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "fix_id": "sshd_print_last_log"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Enable SSH Print Last Log",
          "@_lang": "en-US"
        }
      ],
      "desc": "When enabled, SSH will display the date and time of the last successful account logon. To enable LastLog in SSH, add or correct the following line in thefile:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*PrintLastLog\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"PrintLastLog yes\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"PrintLastLog yes\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh_server",
        "rid": "sshd_rekey_limit",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "fix_id": "sshd_rekey_limit"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Force frequent session key renegotiation",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theparameter specifies how often the session key of the is renegotiated, both in terms of amount of data that may be transmitted and the time elapsed. To decrease the default limits, put lineto file.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then var_rekey_limit_size=\"\" var_rekey_limit_time=\"\" if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*RekeyLimit\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"RekeyLimit $var_rekey_limit_size $var_rekey_limit_time\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"RekeyLimit $var_rekey_limit_size $var_rekey_limit_time\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh_server",
        "rid": "sshd_set_idle_timeout",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "fix_id": "sshd_set_idle_timeout"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Set SSH Idle Timeout Interval",
          "@_lang": "en-US"
        }
      ],
      "desc": "SSH allows administrators to set an idle timeout interval. After this interval has passed, the idle user will be automatically logged out.To set an idle timeout interval, edit the following line inas follows:The timeoutis given in seconds. For example, have a timeout of 10 minutes, setto 600.If a shorter timeout has already been set for the login shell, that value will preempt any SSH setting made in. Keep in mind that some processes may stop SSH from correctly detecting that the user is idle.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sshd_idle_timeout_value=\"\" if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*ClientAliveInterval\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"ClientAliveInterval $sshd_idle_timeout_value\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"ClientAliveInterval $sshd_idle_timeout_value\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh_server",
        "rid": "sshd_set_keepalive",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "fix_id": "sshd_set_keepalive"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Set SSH Client Alive Count Max",
          "@_lang": "en-US"
        }
      ],
      "desc": "The SSH server sends at mostmessages during a SSH session and waits for a response from the SSH client. The optionconfigures timeout after eachmessage. If the SSH server does not receive a response from the client, then the connection is considered idle and terminated. For SSH earlier than v8.2, avalue ofcauses an idle timeout precisely when theis set. Starting with v8.2, a value ofdisables the timeout functionality completely. If the option is set to a number greater than, then the idle session will be disconnected afterseconds.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then var_sshd_set_keepalive=\"\" if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*ClientAliveCountMax\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"ClientAliveCountMax $var_sshd_set_keepalive\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"ClientAliveCountMax $var_sshd_set_keepalive\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh_server",
        "rid": "sshd_set_keepalive_0",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "fix_id": "sshd_set_keepalive_0"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Set SSH Client Alive Count Max to zero",
          "@_lang": "en-US"
        }
      ],
      "desc": "The SSH server sends at mostmessages during a SSH session and waits for a response from the SSH client. The optionconfigures timeout after eachmessage. If the SSH server does not receive a response from the client, then the connection is considered idle and terminated. To ensure the SSH idle timeout occurs precisely when theis set, set theto value of.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*ClientAliveCountMax\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"ClientAliveCountMax 0\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"ClientAliveCountMax 0\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "ssh_server",
        "rid": "sshd_set_loglevel_info",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "fix_id": "sshd_set_loglevel_info"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Set LogLevel to INFO",
          "@_lang": "en-US"
        }
      ],
      "desc": "The INFO parameter specifices that record login and logout activity will be logged. To specify the log level in SSH, add or correct the following line in thefile:",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*LogLevel\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"LogLevel INFO\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"LogLevel INFO\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh_server",
        "rid": "sshd_set_loglevel_verbose",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "fix_id": "sshd_set_loglevel_verbose"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Set SSH Daemon LogLevel to VERBOSE",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theparameter configures the SSH daemon to record login and logout activity. To specify the log level in SSH, add or correct the following line in thefile:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*LogLevel\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"LogLevel VERBOSE\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"LogLevel VERBOSE\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh_server",
        "rid": "sshd_set_max_auth_tries",
        "gtitle": "Configure OpenSSH Server if Necessary"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Set SSH authentication attempt limit",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theparameter specifies the maximum number of authentication attempts permitted per connection. Once the number of failures reaches half this value, additional failures are logged. to set MaxAUthTries editas follows:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh_server",
        "rid": "sshd_set_max_sessions",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "fix_id": "sshd_set_max_sessions"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Set SSH MaxSessions limit",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theparameter specifies the maximum number of open sessions permitted from a given connection. To set MaxSessions editas follows:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then var_sshd_max_sessions=\"\" if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*MaxSessions\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"MaxSessions $var_sshd_max_sessions\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"MaxSessions $var_sshd_max_sessions\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh_server",
        "rid": "sshd_set_maxstartups",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "fix_id": "sshd_set_maxstartups"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Ensure SSH MaxStartups is configured",
          "@_lang": "en-US"
        }
      ],
      "desc": "The MaxStartups parameter specifies the maximum number of concurrent unauthenticated connections to the SSH daemon. Additional connections will be dropped until authentication succeeds or the LoginGraceTime expires for a connection. To confgure MaxStartups, you should add or correct the following line in thefile:CIS recommends a MaxStartups value of '10:30:60', or more restrictive where dictated by site policy.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then var_sshd_set_maxstartups=\"\" if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*MaxStartups\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"MaxStartups $var_sshd_set_maxstartups\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"MaxStartups $var_sshd_set_maxstartups\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh_server",
        "rid": "sshd_use_approved_ciphers",
        "gtitle": "Configure OpenSSH Server if Necessary"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Use Only FIPS 140-2 Validated Ciphers",
          "@_lang": "en-US"
        }
      ],
      "desc": "Limit the ciphers to those algorithms which are FIPS-approved. Counter (CTR) mode is also preferred over cipher-block chaining (CBC) mode. The following line indemonstrates use of FIPS-approved ciphers:The man pagecontains a list of supported ciphers. The rule is parametrized to use the following ciphers:.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh_server",
        "rid": "sshd_use_approved_ciphers_ordered_stig",
        "gtitle": "Configure OpenSSH Server if Necessary"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Use Only FIPS 140-2 Validated Ciphers",
          "@_lang": "en-US"
        }
      ],
      "desc": "Limit the ciphers to those algorithms which are FIPS-approved. The following line indemonstrates use of FIPS-approved ciphers:This rule ensures that there are configured ciphers mentioned above (or their subset), keeping the given order of algorithms.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh_server",
        "rid": "sshd_use_approved_macs",
        "gtitle": "Configure OpenSSH Server if Necessary"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Use Only FIPS 140-2 Validated MACs",
          "@_lang": "en-US"
        }
      ],
      "desc": "Limit the MACs to those hash algorithms which are FIPS-approved. The following line indemonstrates use of FIPS-approved MACs:The man pagecontains a list of supported MACs. The rule is parametrized to use the following MACs:.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh_server",
        "rid": "sshd_use_approved_macs_ordered_stig",
        "gtitle": "Configure OpenSSH Server if Necessary"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Use Only FIPS 140-2 Validated MACs",
          "@_lang": "en-US"
        }
      ],
      "desc": "Limit the MACs to those hash algorithms which are FIPS-approved. The following line indemonstrates use of FIPS-approved MACs:This rule ensures that there are configured MACs mentioned above (or their subset), keeping the given order of algorithms.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh_server",
        "rid": "sshd_use_priv_separation",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "fix_id": "sshd_use_priv_separation"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Enable Use of Privilege Separation",
          "@_lang": "en-US"
        }
      ],
      "desc": "When enabled, SSH will create an unprivileged child process that has the privilege of the authenticated user. To enable privilege separation in SSH, add or correct the following line in thefile:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then var_sshd_priv_separation=\"\" if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*UsePrivilegeSeparation\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"UsePrivilegeSeparation $var_sshd_priv_separation\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"UsePrivilegeSeparation $var_sshd_priv_separation\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "ssh_server",
        "rid": "sshd_x11_use_localhost",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "fix_id": "sshd_x11_use_localhost"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Prevent remote hosts from connecting to the proxy display",
          "@_lang": "en-US"
        }
      ],
      "desc": "The SSH daemon should prevent remote hosts from connecting to the proxy display. Make sure that the optionis set towithin the SSH server configuration file.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*X11UseLocalhost\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"X11UseLocalhost yes\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"X11UseLocalhost yes\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "sssd",
        "rid": "sssd_offline_cred_expiration",
        "gtitle": "System Security Services Daemon"
      },
      "id": "sssd",
      "title": [
        {
          "#text": "Configure SSSD to Expire Offline Credentials",
          "@_lang": "en-US"
        }
      ],
      "desc": "SSSD should be configured to expire offline credentials after 1 day. To configure SSSD to expire offline credentials, settounder thesection in. For example:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "sudo",
        "rid": "package_sudo_installed",
        "gtitle": "Sudo",
        "fix_id": "package_sudo_installed"
      },
      "id": "sudo",
      "title": [
        {
          "#text": "Install sudo Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be installed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"sudo\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gid": "sudo",
        "rid": "sudo_add_noexec",
        "gtitle": "Sudo",
        "fix_id": "sudo_add_noexec"
      },
      "id": "sudo",
      "title": [
        {
          "#text": "Ensure Privileged Escalated Commands Cannot Execute Other Commands - sudo NOEXEC",
          "@_lang": "en-US"
        }
      ],
      "desc": "The sudotag, when specified, prevents user executed commands from executing other commands, like a shell for example. This should be enabled by making sure that thetag exists inconfiguration file or any sudo configuration snippets in.",
      "impact": 0.7,
      "descs": {
        "fix": "if /usr/sbin/visudo -qcf /etc/sudoers; then cp /etc/sudoers /etc/sudoers.bak if ! grep -P '^[\\s]*Defaults.*\\bnoexec\\b.*$' /etc/sudoers; then # sudoers file doesn't define Option noexec echo \"Defaults noexec\" &gt;&gt; /etc/sudoers fi # Check validity of sudoers and cleanup bak if /usr/sbin/visudo -qcf /etc/sudoers; then rm -f /etc/sudoers.bak else echo \"Fail to validate remediated /etc/sudoers, reverting to original file.\" mv /etc/sudoers.bak /etc/sudoers false fi else echo \"Skipping remediation, /etc/sudoers failed to validate\" false fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "sudo",
        "rid": "sudo_add_requiretty",
        "gtitle": "Sudo",
        "fix_id": "sudo_add_requiretty"
      },
      "id": "sudo",
      "title": [
        {
          "#text": "Ensure Only Users Logged In To Real tty Can Execute Sudo - sudo requiretty",
          "@_lang": "en-US"
        }
      ],
      "desc": "The sudotag, when specified, will only execute sudo commands from users logged in to a real tty. This should be enabled by making sure that thetag exists inconfiguration file or any sudo configuration snippets in.",
      "impact": 0.5,
      "descs": {
        "fix": "if /usr/sbin/visudo -qcf /etc/sudoers; then cp /etc/sudoers /etc/sudoers.bak if ! grep -P '^[\\s]*Defaults.*\\brequiretty\\b.*$' /etc/sudoers; then # sudoers file doesn't define Option requiretty echo \"Defaults requiretty\" &gt;&gt; /etc/sudoers fi # Check validity of sudoers and cleanup bak if /usr/sbin/visudo -qcf /etc/sudoers; then rm -f /etc/sudoers.bak else echo \"Fail to validate remediated /etc/sudoers, reverting to original file.\" mv /etc/sudoers.bak /etc/sudoers false fi else echo \"Skipping remediation, /etc/sudoers failed to validate\" false fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "sudo",
        "rid": "sudo_add_use_pty",
        "gtitle": "Sudo",
        "fix_id": "sudo_add_use_pty"
      },
      "id": "sudo",
      "title": [
        {
          "#text": "Ensure Only Users Logged In To Real tty Can Execute Sudo - sudo use_pty",
          "@_lang": "en-US"
        }
      ],
      "desc": "The sudotag, when specified, will only execute sudo commands from users logged in to a real tty. This should be enabled by making sure that thetag exists inconfiguration file or any sudo configuration snippets in.",
      "impact": 0.5,
      "descs": {
        "fix": "if /usr/sbin/visudo -qcf /etc/sudoers; then cp /etc/sudoers /etc/sudoers.bak if ! grep -P '^[\\s]*Defaults.*\\buse_pty\\b.*$' /etc/sudoers; then # sudoers file doesn't define Option use_pty echo \"Defaults use_pty\" &gt;&gt; /etc/sudoers fi # Check validity of sudoers and cleanup bak if /usr/sbin/visudo -qcf /etc/sudoers; then rm -f /etc/sudoers.bak else echo \"Fail to validate remediated /etc/sudoers, reverting to original file.\" mv /etc/sudoers.bak /etc/sudoers false fi else echo \"Skipping remediation, /etc/sudoers failed to validate\" false fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "sudo",
        "rid": "sudo_custom_logfile",
        "gtitle": "Sudo",
        "fix_id": "sudo_custom_logfile"
      },
      "id": "sudo",
      "title": [
        {
          "#text": "Ensure Sudo Logfile Exists - sudo logfile",
          "@_lang": "en-US"
        }
      ],
      "desc": "A custom log sudo file can be configured with the 'logfile' tag. This rule configures a sudo custom logfile at the default location suggested by CIS, which uses /var/log/sudo.log.",
      "impact": 0.3,
      "descs": {
        "fix": "var_sudo_logfile=\"\" if /usr/sbin/visudo -qcf /etc/sudoers; then cp /etc/sudoers /etc/sudoers.bak if ! grep -P '^[\\s]*Defaults.*\\blogfile=(\"(?:\\\\\"|\\\\\\\\|[^\"\\\\ ])*\"\\B|[^\"](?:(?:\\\\,|\\\\\"|\\\\ |\\\\\\\\|[^\", \\\\ ])*)\\b)\\b.*$' /etc/sudoers; then # sudoers file doesn't define Option logfile echo \"Defaults logfile=${var_sudo_logfile}\" &gt;&gt; /etc/sudoers else # sudoers file defines Option logfile, remediate if appropriate value is not set if ! grep -P \"^[\\s]*Defaults.*\\blogfile=${var_sudo_logfile}\\b.*$\" /etc/sudoers; then sed -Ei \"s/(^[\\s]*Defaults.*\\blogfile=)[-]?\\w+(\\b.*$)/\\1${var_sudo_logfile}\\2/\" /etc/sudoers fi fi # Check validity of sudoers and cleanup bak if /usr/sbin/visudo -qcf /etc/sudoers; then rm -f /etc/sudoers.bak else echo \"Fail to validate remediated /etc/sudoers, reverting to original file.\" mv /etc/sudoers.bak /etc/sudoers false fi else echo \"Skipping remediation, /etc/sudoers failed to validate\" false fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "sudo",
        "rid": "sudo_remove_no_authenticate",
        "gtitle": "Sudo",
        "fix_id": "sudo_remove_no_authenticate"
      },
      "id": "sudo",
      "title": [
        {
          "#text": "Ensure Users Re-Authenticate for Privilege Escalation - sudo !authenticate",
          "@_lang": "en-US"
        }
      ],
      "desc": "The sudooption, when specified, allows a user to execute commands using sudo without having to authenticate. This should be disabled by making sure that theoption does not exist inconfiguration file or any sudo configuration snippets in.",
      "impact": 0.5,
      "descs": {
        "fix": "for f in /etc/sudoers /etc/sudoers.d/* ; do if [ ! -e \"$f\" ] ; then continue fi matching_list=$(grep -P '^(?!#).*[\\s]+\\!authenticate.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do # comment out \"!authenticate\" matches to preserve user data sed -i \"s/^${entry}$/# &amp;/g\" $f done &lt;&lt;&lt; \"$matching_list\" /usr/sbin/visudo -cf $f &amp;&gt; /dev/null || echo \"Fail to validate $f with visudo\" fi done"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "sudo",
        "rid": "sudo_remove_nopasswd",
        "gtitle": "Sudo",
        "fix_id": "sudo_remove_nopasswd"
      },
      "id": "sudo",
      "title": [
        {
          "#text": "Ensure Users Re-Authenticate for Privilege Escalation - sudo NOPASSWD",
          "@_lang": "en-US"
        }
      ],
      "desc": "The sudotag, when specified, allows a user to execute commands using sudo without having to authenticate. This should be disabled by making sure that thetag does not exist inconfiguration file or any sudo configuration snippets in.",
      "impact": 0.5,
      "descs": {
        "fix": "for f in /etc/sudoers /etc/sudoers.d/* ; do if [ ! -e \"$f\" ] ; then continue fi matching_list=$(grep -P '^(?!#).*[\\s]+NOPASSWD[\\s]*\\:.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do # comment out \"NOPASSWD\" matches to preserve user data sed -i \"s/^${entry}$/# &amp;/g\" $f done &lt;&lt;&lt; \"$matching_list\" /usr/sbin/visudo -cf $f &amp;&gt; /dev/null || echo \"Fail to validate $f with visudo\" fi done"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "sudo",
        "rid": "sudo_require_authentication",
        "gtitle": "Sudo",
        "fix_id": "sudo_require_authentication"
      },
      "id": "sudo",
      "title": [
        {
          "#text": "Ensure Users Re-Authenticate for Privilege Escalation - sudo",
          "@_lang": "en-US"
        }
      ],
      "desc": "The sudoandoption, when specified, allows a user to execute commands using sudo without having to authenticate. This should be disabled by making sure thatand/ordo not exist inconfiguration file or any sudo configuration snippets in.\"",
      "impact": 0.5,
      "descs": {
        "fix": "for f in /etc/sudoers /etc/sudoers.d/* ; do if [ ! -e \"$f\" ] ; then continue fi matching_list=$(grep -P '^(?!#).*[\\s]+NOPASSWD[\\s]*\\:.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do # comment out \"NOPASSWD\" matches to preserve user data sed -i \"s/^${entry}$/# &amp;/g\" $f done &lt;&lt;&lt; \"$matching_list\" /usr/sbin/visudo -cf $f &amp;&gt; /dev/null || echo \"Fail to validate $f with visudo\" fi done for f in /etc/sudoers /etc/sudoers.d/* ; do if [ ! -e \"$f\" ] ; then continue fi matching_list=$(grep -P '^(?!#).*[\\s]+\\!authenticate.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do # comment out \"!authenticate\" matches to preserve user data sed -i \"s/^${entry}$/# &amp;/g\" $f done &lt;&lt;&lt; \"$matching_list\" /usr/sbin/visudo -cf $f &amp;&gt; /dev/null || echo \"Fail to validate $f with visudo\" fi done"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "sudo",
        "rid": "sudo_vdsm_nopasswd",
        "gtitle": "Sudo"
      },
      "id": "sudo",
      "title": [
        {
          "#text": "Only the VDSM User Can Use sudo NOPASSWD",
          "@_lang": "en-US"
        }
      ],
      "desc": "The sudotag, when specified, allows a user to execute commands using sudo without having to authenticate. Only theuser should have this capability in any sudo configuration snippets in.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "sudo",
        "rid": "sudoers_explicit_command_args",
        "gtitle": "Sudo"
      },
      "id": "sudo",
      "title": [
        {
          "#text": "Explicit arguments in sudo specifications",
          "@_lang": "en-US"
        }
      ],
      "desc": "All commands in the sudoers file must strictly specify the arguments allowed to be used for a given user. If the command is supposed to be executed only without arguments, pass \"\" as an argument in the corresponding user specification.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "sudo",
        "rid": "sudoers_no_command_negation",
        "gtitle": "Sudo"
      },
      "id": "sudo",
      "title": [
        {
          "#text": "Don't define allowed commands in sudoers by means of exclusion",
          "@_lang": "en-US"
        }
      ],
      "desc": "Policies applied by sudo through the sudoers file should not involve negation. Each user specification in thefile contains a comma-delimited list of command specifications. The definition can make use glob patterns, as well as of negations. Indirect definition of those commands by means of exclusion of a set of commands is trivial to bypass, so it is not allowed to use such constructs.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "sudo",
        "rid": "sudoers_no_root_target",
        "gtitle": "Sudo"
      },
      "id": "sudo",
      "title": [
        {
          "#text": "Don't target root user in the sudoers file",
          "@_lang": "en-US"
        }
      ],
      "desc": "The targeted users of a user specification should be, as much as possible, non privileged users (i.e.: non-root). User specifications have to explicitly list the runas spec (i.e. the list of target users that can be impersonated), andorshould not be used.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "system-tools",
        "rid": "package_gnutls-utils_installed",
        "gtitle": "System Tooling / Utilities",
        "fix_id": "package_gnutls-utils_installed"
      },
      "id": "system-tools",
      "title": [
        {
          "#text": "Ensure gnutls-utils is installed",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be installed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "DEBIAN_FRONTEND=noninteractive apt-get install -y \"gnutls-utils\""
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "system-tools",
        "rid": "package_nss-tools_installed",
        "gtitle": "System Tooling / Utilities",
        "fix_id": "package_nss-tools_installed"
      },
      "id": "system-tools",
      "title": [
        {
          "#text": "Ensure nss-tools is installed",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be installed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "DEBIAN_FRONTEND=noninteractive apt-get install -y \"nss-tools\""
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "talk",
        "rid": "package_talk_removed",
        "gtitle": "Chat/Messaging Services",
        "fix_id": "package_talk_removed"
      },
      "id": "talk",
      "title": [
        {
          "#text": "Uninstall talk Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage contains the client program for the Internet talk protocol, which allows the user to chat with other users on different systems. Talk is a communication program which copies lines from one terminal to the terminal of another user. Thepackage can be removed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove talk #  from the system, and may remove any packages #  that depend on talk. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"talk\""
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "telnet",
        "rid": "package_telnet_removed",
        "gtitle": "Telnet",
        "fix_id": "package_telnet_removed"
      },
      "id": "telnet",
      "title": [
        {
          "#text": "Remove telnet Clients",
          "@_lang": "en-US"
        }
      ],
      "desc": "The telnet client allows users to start connections to other systems via the telnet protocol.",
      "impact": 0.3,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove telnet #  from the system, and may remove any packages #  that depend on telnet. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"telnet\""
      }
    },
    {
      "tags": {
        "severity": "high",
        "gid": "uefi",
        "rid": "grub2_uefi_password",
        "gtitle": "UEFI GRUB2 bootloader configuration"
      },
      "id": "uefi",
      "title": [
        {
          "#text": "Set the UEFI Boot Loader Password",
          "@_lang": "en-US"
        }
      ],
      "desc": "The grub2 boot loader should have a superuser account and password protection enabled to protect boot-time settings.Since plaintext passwords are a security risk, generate a hash for the password by running the following command:When prompted, enter the password that was selected.Using the hash from the output, modify thefile with the following content:NOTE: the bootloader superuser account and password MUST differ from the root account and password. Once the superuser password has been added, update thefile by running:",
      "impact": 0.7,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gid": "updating",
        "rid": "clean_components_post_updating",
        "gtitle": "Updating Software"
      },
      "id": "updating",
      "title": [
        {
          "#text": "Ensure apt_get Removes Previous Package Versions",
          "@_lang": "en-US"
        }
      ],
      "desc": "should be configured to remove previous software components after new versions have been installed. To configureto remove the previous software components after updating, set theandtoin.",
      "impact": 0.3,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "user_umask",
        "rid": "accounts_umask_etc_bashrc",
        "gtitle": "Ensure that Users Have Sensible Umask Values",
        "fix_id": "accounts_umask_etc_bashrc"
      },
      "id": "user_umask",
      "title": [
        {
          "#text": "Ensure the Default Bash Umask is Set Correctly",
          "@_lang": "en-US"
        }
      ],
      "desc": "To ensure the default umask for users of the Bash shell is set properly, add or correct thesetting into read as follows:",
      "impact": 0.5,
      "descs": {
        "fix": "- name: XCCDF Value var_accounts_user_umask # promote to variable set_fact: var_accounts_user_umask: !!strtags: - always - name: Set user umask in /etc/bashrc replace: path: /etc/bashrc regexp: umask.* replace: umask {{ var_accounts_user_umask }} tags: - NIST-800-53-AC-6(1) - NIST-800-53-CM-6(a) - accounts_umask_etc_bashrc - low_complexity - low_disruption - medium_severity - no_reboot_needed - restrict_strategy"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "user_umask",
        "rid": "accounts_umask_etc_csh_cshrc",
        "gtitle": "Ensure that Users Have Sensible Umask Values",
        "fix_id": "accounts_umask_etc_csh_cshrc"
      },
      "id": "user_umask",
      "title": [
        {
          "#text": "Ensure the Default C Shell Umask is Set Correctly",
          "@_lang": "en-US"
        }
      ],
      "desc": "To ensure the default umask for users of the C shell is set properly, add or correct thesetting into read as follows:",
      "impact": 0.5,
      "descs": {
        "fix": "- name: XCCDF Value var_accounts_user_umask # promote to variable set_fact: var_accounts_user_umask: !!strtags: - always - name: Set user umask in /etc/csh.cshrc replace: path: /etc/csh.cshrc regexp: umask.* replace: umask {{ var_accounts_user_umask }} tags: - NIST-800-53-AC-6(1) - NIST-800-53-CM-6(a) - accounts_umask_etc_csh_cshrc - low_complexity - low_disruption - no_reboot_needed - restrict_strategy - unknown_severity"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "user_umask",
        "rid": "accounts_umask_etc_login_defs",
        "gtitle": "Ensure that Users Have Sensible Umask Values"
      },
      "id": "user_umask",
      "title": [
        {
          "#text": "Ensure the Default Umask is Set Correctly in login.defs",
          "@_lang": "en-US"
        }
      ],
      "desc": "To ensure the default umask controlled byis set properly, add or correct thesetting into read as follows:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "user_umask",
        "rid": "accounts_umask_etc_profile",
        "gtitle": "Ensure that Users Have Sensible Umask Values",
        "fix_id": "accounts_umask_etc_profile"
      },
      "id": "user_umask",
      "title": [
        {
          "#text": "Ensure the Default Umask is Set Correctly in /etc/profile",
          "@_lang": "en-US"
        }
      ],
      "desc": "To ensure the default umask controlled byis set properly, add or correct thesetting into read as follows:",
      "impact": 0.5,
      "descs": {
        "fix": "var_accounts_user_umask=\"\" grep -q umask /etc/profile &amp;&amp; \\ sed -i \"s/umask.*/umask $var_accounts_user_umask/g\" /etc/profile if ! [ $? -eq 0 ]; then echo \"umask $var_accounts_user_umask\" &gt;&gt; /etc/profile fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "user_umask",
        "rid": "accounts_umask_interactive_users",
        "gtitle": "Ensure that Users Have Sensible Umask Values"
      },
      "id": "user_umask",
      "title": [
        {
          "#text": "Ensure the Default Umask is Set Correctly For Interactive Users",
          "@_lang": "en-US"
        }
      ],
      "desc": "Remove theenvironment variable from all interactive users initialization files.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gid": "wireless_software",
        "rid": "wireless_disable_interfaces",
        "gtitle": "Disable Wireless Through Software Configuration",
        "fix_id": "wireless_disable_interfaces"
      },
      "id": "wireless_software",
      "title": [
        {
          "#text": "Deactivate Wireless Network Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "Deactivating wireless network interfaces should prevent normal usage of the wireless capability.Configure the system to disable all wireless network interfaces with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then nmcli radio wifi off else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    }
  ],
  "name": "UBUNTU_20-04",
  "title": "Guide to the Secure Configuration of Ubuntu 20.04",
  "summary": "This guide presents a catalog of security-relevant configuration settings for Ubuntu 20.04. It is a rendering of content structured in the eXtensible Configuration Checklist Description Format (XCCDF) in order to support security automation. The SCAP content is is available in thepackage which is developed at.Providing system administrators with such guidance informs them how to securely configure systems under their control in a variety of network roles. Policy makers and baseline creators can use this catalog of settings, with its associated references to higher-level security control catalogs, in order to assist them in security baseline creation. This guide is a, and satisfaction of every item is not likely to be possible or sensible in many operational scenarios. However, the XCCDF format enables granular selection and adjustment of settings, and their association with OVAL and OCIL content provides an automated checking capability. Transformations of this document, and its associated automated checking content, are capable of providing baselines that meet a diverse set of policy objectives. Some example XCCDF, which are selections of items that form checklists and can be used as baselines, are available with this guide. They can be processed, in an automated fashion, with tools that support the Security Content Automation Protocol (SCAP). The DISA STIG, which provides required settings for US Department of Defense systems, is one example of a baseline created from this guidance."
}