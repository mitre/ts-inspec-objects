{
  "supports": [],
  "depends": [],
  "inputs": [],
  "libraries": [],
  "files": [],
  "controls": [
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Set Account Expiration Parameters",
        "gid": "account_expiration",
        "rid": "account_disable_post_pw_expiration",
        "fix_id": "account_disable_post_pw_expiration"
      },
      "id": "account_expiration",
      "title": [
        {
          "#text": "Set Account Expiration Following Inactivity",
          "@_lang": "en-US"
        }
      ],
      "desc": "To specify the number of days after a password expires (which signifies inactivity) until an account is permanently disabled, add or correct the following line in:If a password is currently on the verge of expiration, thenday(s) remain(s) until the account is automatically disabled. However, if the password will not expire for another 60 days, then 60 days plusday(s) could elapse until the account would be automatically disabled. See theman page for more information.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'login' 2&gt;/dev/null | grep -q installed; then var_account_disable_post_pw_expiration='' # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/default/useradd\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^INACTIVE\") # shellcheck disable=SC2059 printf -v formatted_output \"%s=%s\" \"$stripped_key\" \"$var_account_disable_post_pw_expiration\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^INACTIVE\\\\&gt;\" \"/etc/default/useradd\"; then \"${sed_command[@]}\" \"s/^INACTIVE\\\\&gt;.*/$formatted_output/gi\" \"/etc/default/useradd\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/default/useradd\" &gt;&gt; \"/etc/default/useradd\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/default/useradd\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Set Account Expiration Parameters",
        "gid": "account_expiration",
        "rid": "account_temp_expire_date"
      },
      "id": "account_expiration",
      "title": [
        {
          "#text": "Assign Expiration Date to Temporary Accounts",
          "@_lang": "en-US"
        }
      ],
      "desc": "Temporary accounts are established as part of normal account activation procedures when there is a need for short-term accounts. In the event temporary or emergency accounts are required, configure the system to terminate them after a documented time period. For every temporary and emergency account, run the following command to set an expiration date on it, substitutingandappropriately:indicates the documented expiration date for the account. For U.S. Government systems, the operating system must be configured to automatically terminate these types of accounts after a period of 72 hours.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Set Account Expiration Parameters",
        "gid": "account_expiration",
        "rid": "account_unique_name"
      },
      "id": "account_expiration",
      "title": [
        {
          "#text": "Ensure All Accounts on the System Have Unique Names",
          "@_lang": "en-US"
        }
      ],
      "desc": "Ensure accounts on the system have unique names. To ensure all accounts have unique names, run the following command:If a username is returned, change or delete the username.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Set Account Expiration Parameters",
        "gid": "account_expiration",
        "rid": "account_use_centralized_automated_auth"
      },
      "id": "account_expiration",
      "title": [
        {
          "#text": "Use Centralized and Automated Authentication",
          "@_lang": "en-US"
        }
      ],
      "desc": "Implement an automated system for managing user accounts that minimizes the risk of errors, either intentional or deliberate. This system should integrate with an existing enterprise user management system, such as one based on Identity Management tools such as Active Directory, Kerberos, Directory Server, etc.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Set Account Expiration Parameters",
        "gid": "account_expiration",
        "rid": "policy_temp_passwords_immediate_change"
      },
      "id": "account_expiration",
      "title": [
        {
          "#text": "Policy Requires Immediate Change of Temporary Passwords",
          "@_lang": "en-US"
        }
      ],
      "desc": "Temporary passwords for Ubuntu 20.04 operating system logons must require an immediate change to a permanent password. Verify that a policy exists that ensures when a user is created, it is creating using a method that forces a user to change their password upon their next login.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Warning Banners for System Accesses",
        "gid": "accounts-banners",
        "rid": "banner_etc_issue_net",
        "fix_id": "banner_etc_issue_net"
      },
      "id": "accounts-banners",
      "title": [
        {
          "#text": "Modify the System Login Banner",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure the system login banner edit. Replace the default text with a message compliant with the local site policy or a legal disclaimer. The DoD required text is either:OR:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then login_banner_text='' # Multiple regexes transform the banner regex into a usable banner # 0 - Remove anchors around the banner text login_banner_text=$(echo \"$login_banner_text\" | sed 's/^\\^\\(.*\\)\\$$/\\1/g') # 1 - Keep only the first banners if there are multiple # (dod_banners contains the long and short banner) login_banner_text=$(echo \"$login_banner_text\" | sed 's/^(\\(.*\\)|.*)$/\\1/g') # 2 - Add spaces ' '. (Transforms regex for \"space or newline\" into a \" \") login_banner_text=$(echo \"$login_banner_text\" | sed 's/\\[\\\\s\\ \\]+/ /g') # 3 - Adds newlines. (Transforms \"(?:\\[\\ \\]+|(?:\\ )+)\" into \" \") login_banner_text=$(echo \"$login_banner_text\" | sed 's/(?:\\[\\ \\]+|(?:\\\\\\ )+)/ /g') # 4 - Remove any leftover backslash. (From any parethesis in the banner, for example). login_banner_text=$(echo \"$login_banner_text\" | sed 's/\\\\//g') formatted=$(echo \"$login_banner_text\" | fold -sw 80) cat &lt;&lt;EOF &gt;/etc/issue.net $formatted EOF else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Warning Banners for System Accesses",
        "gid": "accounts-banners",
        "rid": "file_groupowner_etc_issue",
        "fix_id": "file_groupowner_etc_issue"
      },
      "id": "accounts-banners",
      "title": [
        {
          "#text": "Verify Group Ownership of System Login Banner",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chgrp 0 /etc/issue"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Warning Banners for System Accesses",
        "gid": "accounts-banners",
        "rid": "file_groupowner_etc_issue_net",
        "fix_id": "file_groupowner_etc_issue_net"
      },
      "id": "accounts-banners",
      "title": [
        {
          "#text": "Verify Group Ownership of Remote Login Banner",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chgrp 0 /etc/issue.net"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Warning Banners for System Accesses",
        "gid": "accounts-banners",
        "rid": "file_groupowner_etc_motd",
        "fix_id": "file_groupowner_etc_motd"
      },
      "id": "accounts-banners",
      "title": [
        {
          "#text": "Verify Group Ownership of Message of the Day Banner",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chgrp 0 /etc/motd"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Warning Banners for System Accesses",
        "gid": "accounts-banners",
        "rid": "file_owner_etc_issue",
        "fix_id": "file_owner_etc_issue"
      },
      "id": "accounts-banners",
      "title": [
        {
          "#text": "Verify ownership of System Login Banner",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chown 0 /etc/issue"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Warning Banners for System Accesses",
        "gid": "accounts-banners",
        "rid": "file_owner_etc_issue_net",
        "fix_id": "file_owner_etc_issue_net"
      },
      "id": "accounts-banners",
      "title": [
        {
          "#text": "Verify ownership of Remote Login Banner",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chown 0 /etc/issue.net"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Warning Banners for System Accesses",
        "gid": "accounts-banners",
        "rid": "file_owner_etc_motd",
        "fix_id": "file_owner_etc_motd"
      },
      "id": "accounts-banners",
      "title": [
        {
          "#text": "Verify ownership of Message of the Day Banner",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chown 0 /etc/motd"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Warning Banners for System Accesses",
        "gid": "accounts-banners",
        "rid": "file_permissions_etc_issue",
        "fix_id": "file_permissions_etc_issue"
      },
      "id": "accounts-banners",
      "title": [
        {
          "#text": "Verify permissions on System Login Banner",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chmod 0644 /etc/issue"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Warning Banners for System Accesses",
        "gid": "accounts-banners",
        "rid": "file_permissions_etc_issue_net",
        "fix_id": "file_permissions_etc_issue_net"
      },
      "id": "accounts-banners",
      "title": [
        {
          "#text": "Verify permissions on Remote Login Banner",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chmod 0644 /etc/issue.net"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Warning Banners for System Accesses",
        "gid": "accounts-banners",
        "rid": "file_permissions_etc_motd",
        "fix_id": "file_permissions_etc_motd"
      },
      "id": "accounts-banners",
      "title": [
        {
          "#text": "Verify permissions on Message of the Day Banner",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chmod 0644 /etc/motd"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Warning Banners for System Accesses",
        "gid": "accounts-banners",
        "rid": "no_etc_issue_leak",
        "fix_id": "no_etc_issue_leak"
      },
      "id": "accounts-banners",
      "title": [
        {
          "#text": "Ensure local login warning banner is configured properly",
          "@_lang": "en-US"
        }
      ],
      "desc": "The contents of the /etc/issue file are displayed to users priorto login for local terminals. Unix-based systems have typically displayed information about the OS release and patch level upon logging in to the system. This information can be useful to developers who are developing software for a particular OS platform. If mingetty(8) supports the following options, they display operating system information: \\m - machine architecture \\r - operating system release \\s - operating system name \\v - operating system version",
      "impact": 0.5,
      "descs": {
        "fix": "login_banner_text='' echo \"$login_banner_text\" &gt; /etc/issue"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Warning Banners for System Accesses",
        "gid": "accounts-banners",
        "rid": "no_etc_issue_net_leak",
        "fix_id": "no_etc_issue_net_leak"
      },
      "id": "accounts-banners",
      "title": [
        {
          "#text": "Ensure remote login warning banner is configured properly",
          "@_lang": "en-US"
        }
      ],
      "desc": "The contents of the /etc/issue.net file are displayed to users prior to login for remote connections from configured services. Unix-based systems have typically displayed information about the OS release and patch level upon logging in to the system. This information can be useful to developers who are developing software for a particular OS platform. If mingetty(8) supports the following options, they display operating system information: \\m - machine architecture \\r - operating system release \\s - operating system name \\v - operating system version",
      "impact": 0.5,
      "descs": {
        "fix": "login_banner_text='' echo \"$login_banner_text\" &gt; /etc/issue.net"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Warning Banners for System Accesses",
        "gid": "accounts-banners",
        "rid": "no_etc_motd_leak",
        "fix_id": "no_etc_motd_leak"
      },
      "id": "accounts-banners",
      "title": [
        {
          "#text": "Ensure message of the day is configured properly",
          "@_lang": "en-US"
        }
      ],
      "desc": "The contents of the /etc/motd file are displayed to users after login and function as a message of the day for authenticated users. Unix-based systems have typically displayed information about the OS release and patch level upon logging in to the system. This information can be useful to developers who are developing software for a particular OS platform. If mingetty(8) supports the following options, they display operating system information: \\m - machine architecture \\r - operating system release \\s - operating system name \\v - operating system version.",
      "impact": 0.5,
      "descs": {
        "fix": "sed -i -E 's/(\\\\s|\\\\v|\\\\m|\\\\r)//g' /etc/motd source /etc/os-release sed -i \"s#$ID##g\" /etc/motd"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Protect Accounts by Configuring PAM",
        "gid": "accounts-pam",
        "rid": "package_pam_pwquality_installed",
        "fix_id": "package_pam_pwquality_installed"
      },
      "id": "accounts-pam",
      "title": [
        {
          "#text": "Install pam_pwquality Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be installed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "DEBIAN_FRONTEND=noninteractive apt-get install -y \"libpam-pwquality\""
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Protect Accounts by Configuring PAM",
        "gid": "accounts-pam",
        "rid": "display_login_attempts",
        "fix_id": "display_login_attempts"
      },
      "id": "accounts-pam",
      "title": [
        {
          "#text": "Ensure PAM Displays Last Logon/Access Notification",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure the system to notify users of last logon/access using, add or correct thesettings into read as follows:And make sure that theoption is not set.",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'libpam-runtime' 2&gt;/dev/null | grep -q installed; thenensure_pam_module_options '/etc/pam.d/login' 'session' 'required' 'pam_lastlog.so' 'showfailed' \"\" \"\" 'silent' # remove 'silent' option sed -i --follow-symlinks -E -e 's/^([^#]+pam_lastlog\\.so[^#]*)\\ssilent/\\1/' '/etc/pam.d/login' else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gtitle": "Protect Physical Console Access",
        "gid": "accounts-physical",
        "rid": "disable_ctrlaltdel_burstaction",
        "fix_id": "disable_ctrlaltdel_burstaction"
      },
      "id": "accounts-physical",
      "title": [
        {
          "#text": "Disable Ctrl-Alt-Del Burst Action",
          "@_lang": "en-US"
        }
      ],
      "desc": "By default,will reboot the system if thekey sequence is pressed Ctrl-Alt-Delete more than 7 times in 2 seconds.To configure the system to ignore thesetting, add or modify the following to:",
      "impact": 0.7,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'systemd' 2&gt;/dev/null | grep -q installed; then # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/systemd/system.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^CtrlAltDelBurstAction=\") # shellcheck disable=SC2059 printf -v formatted_output \"%s=%s\" \"$stripped_key\" \"none\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^CtrlAltDelBurstAction=\\\\&gt;\" \"/etc/systemd/system.conf\"; then \"${sed_command[@]}\" \"s/^CtrlAltDelBurstAction=\\\\&gt;.*/$formatted_output/gi\" \"/etc/systemd/system.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/systemd/system.conf\" &gt;&gt; \"/etc/systemd/system.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/systemd/system.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gtitle": "Protect Physical Console Access",
        "gid": "accounts-physical",
        "rid": "disable_ctrlaltdel_reboot",
        "fix_id": "disable_ctrlaltdel_reboot"
      },
      "id": "accounts-physical",
      "title": [
        {
          "#text": "Disable Ctrl-Alt-Del Reboot Activation",
          "@_lang": "en-US"
        }
      ],
      "desc": "By default,will reboot the system if thekey sequence is pressed.To configure the system to ignore thekey sequence from the command line instead of rebooting the system, do either of the following:orDo not simply delete thefile, as this file may be restored during future system updates.",
      "impact": 0.7,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then systemctl disable --now ctrl-alt-del.target systemctl mask --now ctrl-alt-del.target else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Protect Physical Console Access",
        "gid": "accounts-physical",
        "rid": "single_user_authentication",
        "fix_id": "single_user_authentication"
      },
      "id": "accounts-physical",
      "title": [
        {
          "#text": "Ensure authentication required for single user mode",
          "@_lang": "en-US"
        }
      ],
      "desc": "Single user mode is used for recovery when the system detects an issue during boot or by manual selection from the bootloader.",
      "impact": 0.5,
      "descs": {
        "fix": "var_root_passwd_hash='' # Only applies the hash to /etc/shadow if the variable contains a value different from '*', '!' # or empty if [ -n \"${var_root_passwd_hash/+([[:blank:]])/}\" ] &amp;&amp; [ \"${var_root_passwd_hash}\" != \"*\" ] &amp;&amp;\\ [ \"${var_root_passwd_hash}\" != \"!\" ]; then sed -Ei \"s@^root:[^:]*@root:${var_root_passwd_hash}@\" /etc/shadow fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Secure Session Configuration Files for Login Accounts",
        "gid": "accounts-session",
        "rid": "accounts_logon_fail_delay"
      },
      "id": "accounts-session",
      "title": [
        {
          "#text": "Ensure the Logon Failure Delay is Set Correctly in login.defs",
          "@_lang": "en-US"
        }
      ],
      "desc": "To ensure the logon failure delay controlled byis set properly, add or correct thesetting into read as follows:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Secure Session Configuration Files for Login Accounts",
        "gid": "accounts-session",
        "rid": "accounts_max_concurrent_login_sessions",
        "fix_id": "accounts_max_concurrent_login_sessions"
      },
      "id": "accounts-session",
      "title": [
        {
          "#text": "Limit the Number of Concurrent Login Sessions Allowed Per User",
          "@_lang": "en-US"
        }
      ],
      "desc": "Limiting the number of allowed users and sessions per user can limit risks related to Denial of Service attacks. This addresses concurrent sessions for a single account and does not address concurrent sessions by a single user via multiple accounts. To set the number of concurrent sessions per user add the following line inor a file under:",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'libpam-runtime' 2&gt;/dev/null | grep -q installed; then var_accounts_max_concurrent_login_sessions='' if grep -q '^[^#]*\\&lt;maxlogins\\&gt;' /etc/security/limits.d/*.conf; then  sed -i \"/^[^#]*\\&lt;maxlogins\\&gt;/ s/maxlogins.*/maxlogins $var_accounts_max_concurrent_login_sessions/\" /etc/security/limits.d/*.conf elif grep -q '^[^#]*\\&lt;maxlogins\\&gt;' /etc/security/limits.conf; then  sed -i \"/^[^#]*\\&lt;maxlogins\\&gt;/ s/maxlogins.*/maxlogins $var_accounts_max_concurrent_login_sessions/\" /etc/security/limits.conf else  echo \"* hard maxlogins $var_accounts_max_concurrent_login_sessions\" &gt;&gt; /etc/security/limits.conf fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Secure Session Configuration Files for Login Accounts",
        "gid": "accounts-session",
        "rid": "accounts_polyinstantiated_tmp",
        "fix_id": "accounts_polyinstantiated_tmp"
      },
      "id": "accounts-session",
      "title": [
        {
          "#text": "Configure Polyinstantiation of /tmp Directories",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure polyinstantiated /tmp directories, first create the parent directories which will hold the polyinstantiation child directories. Use the following command:Then, add the following entry to:",
      "impact": 0.3,
      "descs": {
        "fix": "if ! [ -d /tmp/tmp-inst ] ; then mkdir --mode 000 /tmp/tmp-inst fi chmod 000 /tmp/tmp-inst chcon --reference=/tmp /tmp/tmp-inst if ! grep -Eq '^\\s*/tmp\\s+/tmp/tmp-inst/\\s+level\\s+root,adm$' /etc/security/namespace.conf ; then if grep -Eq '^\\s*/tmp\\s+' /etc/security/namespace.conf ; then sed -i '/^\\s*\\/tmp/d' /etc/security/namespace.conf fi echo \"/tmp /tmp/tmp-inst/ level root,adm\" &gt;&gt; /etc/security/namespace.conf fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Secure Session Configuration Files for Login Accounts",
        "gid": "accounts-session",
        "rid": "accounts_polyinstantiated_var_tmp",
        "fix_id": "accounts_polyinstantiated_var_tmp"
      },
      "id": "accounts-session",
      "title": [
        {
          "#text": "Configure Polyinstantiation of /var/tmp Directories",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure polyinstantiated /tmp directories, first create the parent directories which will hold the polyinstantiation child directories. Use the following command:Then, add the following entry to:",
      "impact": 0.3,
      "descs": {
        "fix": "if ! [ -d /tmp-inst ] ; then mkdir --mode 000 /var/tmp/tmp-inst fi chmod 000 /var/tmp/tmp-inst chcon --reference=/var/tmp/ /var/tmp/tmp-inst if ! grep -Eq '^\\s*/var/tmp\\s+/var/tmp/tmp-inst/\\s+level\\s+root,adm$' /etc/security/namespace.conf ; then if grep -Eq '^\\s*/var/tmp\\s+' /etc/security/namespace.conf ; then sed -i '/^\\s*\\/var\\/tmp/d' /etc/security/namespace.conf fi echo \"/var/tmp /var/tmp/tmp-inst/ level root,adm\" &gt;&gt; /etc/security/namespace.conf fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Secure Session Configuration Files for Login Accounts",
        "gid": "accounts-session",
        "rid": "accounts_tmout",
        "fix_id": "accounts_tmout"
      },
      "id": "accounts-session",
      "title": [
        {
          "#text": "Set Interactive Session Timeout",
          "@_lang": "en-US"
        }
      ],
      "desc": "Setting theoption inensures that all user sessions will terminate based on inactivity. Thesetting in a file loaded by, e.g.should read as follows:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then var_accounts_tmout='' # if 0, no occurence of tmout found, if 1, occurence found tmout_found=0 for f in /etc/profile /etc/profile.d/*.sh; do if grep --silent '^\\s*TMOUT' $f; then sed -i -E \"s/^(\\s*)TMOUT\\s*=\\s*(\\w|\\$)*(.*)$/\\1TMOUT=$var_accounts_tmout\\3/g\" $f tmout_found=1 fi done if [ $tmout_found -eq 0 ]; then echo -e \" # Set TMOUT to $var_accounts_tmout per security requirements\" &gt;&gt; /etc/profile.d/tmout.sh echo \"TMOUT=$var_accounts_tmout\" &gt;&gt; /etc/profile.d/tmout.sh fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Secure Session Configuration Files for Login Accounts",
        "gid": "accounts-session",
        "rid": "accounts_user_dot_group_ownership",
        "fix_id": "accounts_user_dot_group_ownership"
      },
      "id": "accounts-session",
      "title": [
        {
          "#text": "User Initialization Files Must Be Group-Owned By The Primary User",
          "@_lang": "en-US"
        }
      ],
      "desc": "Change the group owner of interactive users files to the group found infor the user. To change the group owner of a local interactive user home directory, use the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "fetch_users_and_homedir |\\ while read user dir; do group_name=\"$(id --group --name \"$user\")\" find \"$dir\" -iname '.*' -type f -execdir chgrp \"$group_name\" {} \\; done"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Secure Session Configuration Files for Login Accounts",
        "gid": "accounts-session",
        "rid": "accounts_user_dot_user_ownership",
        "fix_id": "accounts_user_dot_user_ownership"
      },
      "id": "accounts-session",
      "title": [
        {
          "#text": "User Initialization Files Must Be Owned By the Primary User",
          "@_lang": "en-US"
        }
      ],
      "desc": "Set the owner of the user initialization files for interactive users to the primary owner with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "fetch_users_and_homedir |\\ while read user dir; do find \"$dir\" -maxdepth 1 -iname '.*' -type f -execdir chown \"$user\" {} \\; done"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Secure Session Configuration Files for Login Accounts",
        "gid": "accounts-session",
        "rid": "accounts_user_interactive_home_directory_exists"
      },
      "id": "accounts-session",
      "title": [
        {
          "#text": "All Interactive Users Home Directories Must Exist",
          "@_lang": "en-US"
        }
      ],
      "desc": "Create home directories to all interactive users that currently do not have a home directory assigned. Use the following commands to create the user home directory assigned in:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Secure Session Configuration Files for Login Accounts",
        "gid": "accounts-session",
        "rid": "accounts_users_own_home_directories",
        "fix_id": "accounts_users_own_home_directories"
      },
      "id": "accounts-session",
      "title": [
        {
          "#text": "Ensure users own their home directories",
          "@_lang": "en-US"
        }
      ],
      "desc": "The user home directory is space defined for the particular user to set local environment variables and to store personal files. Since the user is accountable for files stored in the user home directory, the user must be the owner of the directory.",
      "impact": 0.5,
      "descs": {
        "fix": "fetch_users_and_homedir |\\ while read user dir; do chown \"${user}\" \"${dir}\" done"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Secure Session Configuration Files for Login Accounts",
        "gid": "accounts-session",
        "rid": "adduser_home_directories_mode",
        "fix_id": "adduser_home_directories_mode"
      },
      "id": "accounts-session",
      "title": [
        {
          "#text": "Ensure appropriate umask set for adduser",
          "@_lang": "en-US"
        }
      ],
      "desc": "While the system administrator can establish secure permissions for users' home directories, the users can easily override these. Settingforhelps ensure safe default permissions are chosen.",
      "impact": 0.5,
      "descs": {
        "fix": "var_adduser_home_directories_mode='' valid_mode=${var_adduser_home_directories_mode} adduser_conf=/etc/adduser.conf dir_mode=\"$(awk -F= '/^\\s*DIR_MODE\\s*=\\s*[0-7]?[0-7]{3}/{ printf(\"%04d\", strtonum($2)) }' ${adduser_conf})\" if [ -z \"${dir_mode}\" ] || [ $(( $dir_mode &amp; 0$valid_mode )) -ne \"${dir_mode}\" ]; then sed -i '/^\\s*DIR_MODE\\b/d' ${adduser_conf} echo 'DIR_MODE='\"${valid_mode}\" &gt;&gt; ${adduser_conf} fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Secure Session Configuration Files for Login Accounts",
        "gid": "accounts-session",
        "rid": "file_permissions_home_directories",
        "fix_id": "file_permissions_home_directories"
      },
      "id": "accounts-session",
      "title": [
        {
          "#text": "All Interactive User Home Directories Must Have mode 0750 Or Less Permissive",
          "@_lang": "en-US"
        }
      ],
      "desc": "Change the mode of interactive users home directories to. To change the mode of interactive users home directory, use the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "fetch_users_and_homedir |\\ while read user dir; do chmod o-wrx,g-w \"${dir}\" done"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Secure Session Configuration Files for Login Accounts",
        "gid": "accounts-session",
        "rid": "file_permissions_home_dirs"
      },
      "id": "accounts-session",
      "title": [
        {
          "#text": "Ensure that User Home Directories are not Group-Writable or World-Readable",
          "@_lang": "en-US"
        }
      ],
      "desc": "For each human user of the system, view the permissions of the user's home directory:Ensure that the directory is not group-writable and that it is not world-readable. If necessary, repair the permissions:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Secure Session Configuration Files for Login Accounts",
        "gid": "accounts-session",
        "rid": "no_forward_files"
      },
      "id": "accounts-session",
      "title": [
        {
          "#text": "Ensure no users have .forward files",
          "@_lang": "en-US"
        }
      ],
      "desc": "The .forward file specifies an email address to forward the user's mail to. Use of the .forward file poses a security risk in that sensitive data may be inadvertently transferred outside the organization. The .forward file also poses a risk as it can be used to execute commands that may perform unintended actions.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Secure Session Configuration Files for Login Accounts",
        "gid": "accounts-session",
        "rid": "no_group_world_writable_dot_files",
        "fix_id": "no_group_world_writable_dot_files"
      },
      "id": "accounts-session",
      "title": [
        {
          "#text": "Ensure users' dot files are not group or world writable",
          "@_lang": "en-US"
        }
      ],
      "desc": "While the system administrator can establish secure permissions for users' \"dot\" files, the users can easily override these. Group or world-writable user configuration files may enable malicious users to steal or modify other users' data or to gain another user's system privileges.",
      "impact": 0.5,
      "descs": {
        "fix": "fetch_users_and_homedir |\\ while read user dir; do find \"$dir\" -maxdepth 1 -iname '.*' -type f -execdir chmod o-w,g-w {} \\; done"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Secure Session Configuration Files for Login Accounts",
        "gid": "accounts-session",
        "rid": "useradd_home_directories_mode",
        "fix_id": "useradd_home_directories_mode"
      },
      "id": "accounts-session",
      "title": [
        {
          "#text": "Ensure appropriate homedir mode set for useradd",
          "@_lang": "en-US"
        }
      ],
      "desc": "While the system administrator can establish secure permissions for users' home directories, the users can easily override these. Settingon /etc/login.defs forhelps ensure safe default permissions are chosen.",
      "impact": 0.5,
      "descs": {
        "fix": "var_useradd_home_directories_mode='' valid_mode=${var_useradd_home_directories_mode} useradd_conf=/etc/login.defs home_mode=\"$(awk -F= '/^\\s*HOME_MODE\\s*=\\s*[0-7]?[0-7]{3}/{ printf(\"%04d\", strtonum($2)) }' ${useradd_conf})\" if [ -z \"${home_mode}\" ] || [ $(( $home_mode &amp; 0$valid_mode )) -ne \"${home_mode}\" ]; then sed -i '/^\\s*HOME_MODE\\b/d' ${useradd_conf} echo -e 'HOME_MODE\\t'\"${valid_mode}\" &gt;&gt; ${useradd_conf} fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Integrity with AIDE",
        "gid": "aide",
        "rid": "package_aide_installed",
        "fix_id": "package_aide_installed"
      },
      "id": "aide",
      "title": [
        {
          "#text": "Install AIDE",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be installed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"aide\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Integrity with AIDE",
        "gid": "aide",
        "rid": "aide_build_database",
        "fix_id": "aide_build_database"
      },
      "id": "aide",
      "title": [
        {
          "#text": "Build and Test AIDE Database",
          "@_lang": "en-US"
        }
      ],
      "desc": "Run the following command to generate a new database:By default, the database will be written to the file. Storing the database, the configuration file, and the binary(or hashes of these files), in a secure location (such as on read-only media) provides additional assurance about their integrity. The newly-generated database can be installed as follows:To initiate a manual check, run the following command:If this check produces any unexpected output, investigate.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"aide\" AIDE_CONFIG=/etc/aide/aide.conf DEFAULT_DB_PATH=/var/lib/aide/aide.db # Fix db path in the config file, if necessary if ! grep -q '^database=file:' ${AIDE_CONFIG}; then # replace_or_append gets confused by 'database=file' as a key, so should not be used. #replace_or_append \"${AIDE_CONFIG}\" '^database=file' \"${DEFAULT_DB_PATH}\" '' '%s:%s' echo \"database=file:${DEFAULT_DB_PATH}\" &gt;&gt; ${AIDE_CONFIG} fi # Fix db out path in the config file, if necessary if ! grep -q '^database_out=file:' ${AIDE_CONFIG}; then echo \"database_out=file:${DEFAULT_DB_PATH}.new\" &gt;&gt; ${AIDE_CONFIG} fi /usr/sbin/aideinit -y -f else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Integrity with AIDE",
        "gid": "aide",
        "rid": "aide_check_audit_tools",
        "fix_id": "aide_check_audit_tools"
      },
      "id": "aide",
      "title": [
        {
          "#text": "Configure AIDE to Verify the Audit Tools",
          "@_lang": "en-US"
        }
      ],
      "desc": "The Ubuntu 20.04 operating system file integrity tool must be configured to protect the integrity of the audit tools.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"aide\" if grep -i '^.*/usr/sbin/auditctl.*$' /etc/aide/aide.conf; then sed -i \"s#.*/usr/sbin/auditctl.*#/usr/sbin/auditctl p+i+n+u+g+s+b+acl+xattrs+sha512#\" /etc/aide/aide.conf else echo \"/usr/sbin/auditctl p+i+n+u+g+s+b+acl+xattrs+sha512\" &gt;&gt; /etc/aide/aide.conf fi if grep -i '^.*/usr/sbin/auditd.*$' /etc/aide/aide.conf; then sed -i \"s#.*/usr/sbin/auditd.*#/usr/sbin/auditd p+i+n+u+g+s+b+acl+xattrs+sha512#\" /etc/aide/aide.conf else echo \"/usr/sbin/auditd p+i+n+u+g+s+b+acl+xattrs+sha512\" &gt;&gt; /etc/aide/aide.conf fi if grep -i '^.*/usr/sbin/ausearch.*$' /etc/aide/aide.conf; then sed -i \"s#.*/usr/sbin/ausearch.*#/usr/sbin/ausearch p+i+n+u+g+s+b+acl+xattrs+sha512#\" /etc/aide/aide.conf else echo \"/usr/sbin/ausearch p+i+n+u+g+s+b+acl+xattrs+sha512\" &gt;&gt; /etc/aide/aide.conf fi if grep -i '^.*/usr/sbin/aureport.*$' /etc/aide/aide.conf; then sed -i \"s#.*/usr/sbin/aureport.*#/usr/sbin/aureport p+i+n+u+g+s+b+acl+xattrs+sha512#\" /etc/aide/aide.conf else echo \"/usr/sbin/aureport p+i+n+u+g+s+b+acl+xattrs+sha512\" &gt;&gt; /etc/aide/aide.conf fi if grep -i '^.*/usr/sbin/autrace.*$' /etc/aide/aide.conf; then sed -i \"s#.*/usr/sbin/autrace.*#/usr/sbin/autrace p+i+n+u+g+s+b+acl+xattrs+sha512#\" /etc/aide/aide.conf else echo \"/usr/sbin/autrace p+i+n+u+g+s+b+acl+xattrs+sha512\" &gt;&gt; /etc/aide/aide.conf fi if grep -i '^.*/usr/sbin/augenrules.*$' /etc/aide/aide.conf; then sed -i \"s#.*/usr/sbin/augenrules.*#/usr/sbin/augenrules p+i+n+u+g+s+b+acl+xattrs+sha512#\" /etc/aide/aide.conf else echo \"/usr/sbin/augenrules p+i+n+u+g+s+b+acl+xattrs+sha512\" &gt;&gt; /etc/aide/aide.conf fi if grep -i '^.*/usr/sbin/audispd.*$' /etc/aide/aide.conf; then sed -i \"s#.*/usr/sbin/audispd.*#/usr/sbin/audispd p+i+n+u+g+s+b+acl+xattrs+sha512#\" /etc/aide/aide.conf else echo \"/usr/sbin/audispd p+i+n+u+g+s+b+acl+xattrs+sha512\" &gt;&gt; /etc/aide/aide.conf fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Integrity with AIDE",
        "gid": "aide",
        "rid": "aide_periodic_cron_checking",
        "fix_id": "aide_periodic_cron_checking"
      },
      "id": "aide",
      "title": [
        {
          "#text": "Configure Periodic Execution of AIDE",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, AIDE should be configured to run a weekly scan. To implement a daily execution of AIDE at 4:05am using cron, add the following line to:To implement a weekly execution of AIDE at 4:05am using cron, add the following line to:AIDE can be executed periodically through other means; this is merely one example. The usage of cron's special time codes, such asandis acceptable.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"aide\" # AiDE usually adds its own cron jobs to /etc/cron.daily. If script is there, this rule is # compliant. Otherwise, we copy the script to the /etc/cron.weekly if ! egrep -q '^(/usr/bin/)?aide\\.wrapper\\s+' /etc/cron.*/*; then cp -f /usr/share/aide/config/cron.daily/aide /etc/cron.weekly/ fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "AppArmor",
        "gid": "apparmor",
        "rid": "package_apparmor_installed",
        "fix_id": "package_apparmor_installed"
      },
      "id": "apparmor",
      "title": [
        {
          "#text": "Ensure AppArmor is installed",
          "@_lang": "en-US"
        }
      ],
      "desc": "AppArmor provide Mandatory Access Controls.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"apparmor\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "AppArmor",
        "gid": "apparmor",
        "rid": "apparmor_configured",
        "fix_id": "apparmor_configured"
      },
      "id": "apparmor",
      "title": [
        {
          "#text": "Ensure AppArmor is Active and Configured",
          "@_lang": "en-US"
        }
      ],
      "desc": "Verify that the Apparmor tool is configured to control whitelisted applications and user home directory access control.Theservice can be enabled with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # Enable apparmor /usr/bin/systemctl enable \"apparmor\" /usr/bin/systemctl start \"apparmor\" # The service may not be running because it has been started and failed, # so let's reset the state so OVAL checks pass. # Service should be 'inactive', not 'failed' after reboot though. /usr/bin/systemctl reset-failed \"apparmor\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "AppArmor",
        "gid": "apparmor",
        "rid": "ensure_apparmor_enforce",
        "fix_id": "ensure_apparmor_enforce"
      },
      "id": "apparmor",
      "title": [
        {
          "#text": "Ensure all AppArmor Profiles are in enforce mode",
          "@_lang": "en-US"
        }
      ],
      "desc": "AppArmor profiles define what resources applications are able to access.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # apparmor and apparmor-utils must be installed to be compliant to this rule. dpkg-query --show --showformat='${db:Status-Status} ' \"apparmor\" 2&gt;/dev/null | grep -q installed || DEBIAN_FRONTEND=noninteractive apt-get install apparmor -y dpkg-query --show --showformat='${db:Status-Status} ' \"apparmor-utils\" 2&gt;/dev/null | grep -q installed || DEBIAN_FRONTEND=noninteractive apt-get install apparmor-utils -y aa-enforce /etc/apparmor.d/* else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "AppArmor",
        "gid": "apparmor",
        "rid": "ensure_apparmor_enforce_or_complain",
        "fix_id": "ensure_apparmor_enforce_or_complain"
      },
      "id": "apparmor",
      "title": [
        {
          "#text": "Ensure all AppArmor Profiles are in enforce or complain mode",
          "@_lang": "en-US"
        }
      ],
      "desc": "AppArmor profiles define what resources applications are able to access.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then var_set_apparmor_enforce_mode='' local lvl1_aa_enforce=${var_set_apparmor_enforce_mode} # apparmor and apparmor-utils must be installed to be compliant to this rule. dpkg-query --show --showformat='${db:Status-Status} ' \"apparmor\" 2&gt;/dev/null | grep -q installed || DEBIAN_FRONTEND=noninteractive apt-get install apparmor -y dpkg-query --show --showformat='${db:Status-Status} ' \"apparmor-utils\" 2&gt;/dev/null | grep -q installed || DEBIAN_FRONTEND=noninteractive apt-get install apparmor-utils -y if [ -z \"${lvl1_aa_enforce}\" ] || [ \"${lvl1_aa_enforce}\" != true ]; then aa-complain /etc/apparmor.d/* else aa-enforce /etc/apparmor.d/* fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "AppArmor",
        "gid": "apparmor",
        "rid": "grub2_enable_apparmor",
        "fix_id": "grub2_enable_apparmor"
      },
      "id": "apparmor",
      "title": [
        {
          "#text": "Ensure AppArmor is enabled in the bootloader configuration",
          "@_lang": "en-US"
        }
      ],
      "desc": "Configure AppArmor to be enabled at boot time and verify that it has not been overwritten by the bootloader boot parameters. Note: This recommendation is designed around the grub bootloader, if LILO or another bootloader is in use in your environment, enact equivalent settings.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; thenadd_kernel_boot_param apparmor 1 add_kernel_boot_param security apparmordo_update_grub else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "critical",
        "gtitle": "Apport Service",
        "gid": "apport",
        "rid": "service_apport_disabled",
        "fix_id": "service_apport_disabled"
      },
      "id": "apport",
      "title": [
        {
          "#text": "Disable Apport Service",
          "@_lang": "en-US"
        }
      ],
      "desc": "The Apport modifies certain kernel configuration values at runtime which may decrease the overall security of the system and expose sensitive data. Theservice can be disabled with the following command:",
      "impact": 1,
      "descs": {
        "fix": "SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" stop 'apport.service' \"$SYSTEMCTL_EXEC\" disable 'apport.service' \"$SYSTEMCTL_EXEC\" mask 'apport.service' # Disable socket activation if we have a unit file for it if \"$SYSTEMCTL_EXEC\" list-unit-files | grep -q '^apport.socket'; then \"$SYSTEMCTL_EXEC\" stop 'apport.socket' \"$SYSTEMCTL_EXEC\" mask 'apport.socket' fi # The service may not be running because it has been started and failed, # so let's reset the state so OVAL checks pass. # Service should be 'inactive', not 'failed' after reboot though. \"$SYSTEMCTL_EXEC\" reset-failed 'apport.service' || true"
      }
    },
    {
      "tags": {
        "severity": "critical",
        "gtitle": "APT service configuration",
        "gid": "apt",
        "rid": "apt_conf_disallow_unauthenticated",
        "fix_id": "apt_conf_disallow_unauthenticated"
      },
      "id": "apt",
      "title": [
        {
          "#text": "Disable unauthenticated repositories in APT configuration",
          "@_lang": "en-US"
        }
      ],
      "desc": "Unauthenticated repositories should not be used for updates.",
      "impact": 1,
      "descs": {
        "fix": "for file in /etc/apt/apt.conf.d/*; do if [ -e \"$file\" ]; then if grep -qi \"APT::Get::AllowUnauthenticated\" $file; then sed -i --follow-symlinks \"s/^.*APT::Get::AllowUnauthenticated.*/APT::Get::AllowUnauthenticated \\\"false\\\";/I\" $file fi fi done"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Events that Modify the System's Discretionary Access Controls",
        "gid": "audit_dac_actions",
        "rid": "audit_rules_dac_modification_chmod",
        "fix_id": "audit_rules_dac_modification_chmod"
      },
      "id": "audit_dac_actions",
      "title": [
        {
          "#text": "Record Events that Modify the System's Discretionary Access Controls - chmod",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file permission changes for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"\"  AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\"  SYSCALL=\"chmod\"  KEY=\"perm_mod\"  SYSCALL_GROUPING=\"chmod fchmod fchmodat\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Events that Modify the System's Discretionary Access Controls",
        "gid": "audit_dac_actions",
        "rid": "audit_rules_dac_modification_chown",
        "fix_id": "audit_rules_dac_modification_chown"
      },
      "id": "audit_dac_actions",
      "title": [
        {
          "#text": "Record Events that Modify the System's Discretionary Access Controls - chown",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file permission changes for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"\"  AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\"  SYSCALL=\"chown\"  KEY=\"perm_mod\"  SYSCALL_GROUPING=\"chown fchown fchownat lchown\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Events that Modify the System's Discretionary Access Controls",
        "gid": "audit_dac_actions",
        "rid": "audit_rules_dac_modification_fchmod",
        "fix_id": "audit_rules_dac_modification_fchmod"
      },
      "id": "audit_dac_actions",
      "title": [
        {
          "#text": "Record Events that Modify the System's Discretionary Access Controls - fchmod",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file permission changes for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"\"  AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\"  SYSCALL=\"fchmod\"  KEY=\"perm_mod\"  SYSCALL_GROUPING=\"chmod fchmod fchmodat\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Events that Modify the System's Discretionary Access Controls",
        "gid": "audit_dac_actions",
        "rid": "audit_rules_dac_modification_fchmodat",
        "fix_id": "audit_rules_dac_modification_fchmodat"
      },
      "id": "audit_dac_actions",
      "title": [
        {
          "#text": "Record Events that Modify the System's Discretionary Access Controls - fchmodat",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file permission changes for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"\"  AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\"  SYSCALL=\"fchmodat\"  KEY=\"perm_mod\"  SYSCALL_GROUPING=\"chmod fchmod fchmodat\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Events that Modify the System's Discretionary Access Controls",
        "gid": "audit_dac_actions",
        "rid": "audit_rules_dac_modification_fchown",
        "fix_id": "audit_rules_dac_modification_fchown"
      },
      "id": "audit_dac_actions",
      "title": [
        {
          "#text": "Record Events that Modify the System's Discretionary Access Controls - fchown",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file permission changes for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"\"  AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\"  SYSCALL=\"fchown\"  KEY=\"perm_mod\"  SYSCALL_GROUPING=\"chown fchown fchownat lchown\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Events that Modify the System's Discretionary Access Controls",
        "gid": "audit_dac_actions",
        "rid": "audit_rules_dac_modification_fchownat",
        "fix_id": "audit_rules_dac_modification_fchownat"
      },
      "id": "audit_dac_actions",
      "title": [
        {
          "#text": "Record Events that Modify the System's Discretionary Access Controls - fchownat",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file permission changes for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"\"  AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\"  SYSCALL=\"fchownat\"  KEY=\"perm_mod\"  SYSCALL_GROUPING=\"chown fchown fchownat lchown\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Events that Modify the System's Discretionary Access Controls",
        "gid": "audit_dac_actions",
        "rid": "audit_rules_dac_modification_fremovexattr",
        "fix_id": "audit_rules_dac_modification_fremovexattr"
      },
      "id": "audit_dac_actions",
      "title": [
        {
          "#text": "Record Events that Modify the System's Discretionary Access Controls - fremovexattr",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file permission changes for all users and root.If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"\"  AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\"  SYSCALL=\"fremovexattr\"  KEY=\"perm_mod\"  SYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Events that Modify the System's Discretionary Access Controls",
        "gid": "audit_dac_actions",
        "rid": "audit_rules_dac_modification_fsetxattr",
        "fix_id": "audit_rules_dac_modification_fsetxattr"
      },
      "id": "audit_dac_actions",
      "title": [
        {
          "#text": "Record Events that Modify the System's Discretionary Access Controls - fsetxattr",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file permission changes for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"\"  AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\"  SYSCALL=\"fsetxattr\"  KEY=\"perm_mod\"  SYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Events that Modify the System's Discretionary Access Controls",
        "gid": "audit_dac_actions",
        "rid": "audit_rules_dac_modification_lchown",
        "fix_id": "audit_rules_dac_modification_lchown"
      },
      "id": "audit_dac_actions",
      "title": [
        {
          "#text": "Record Events that Modify the System's Discretionary Access Controls - lchown",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file permission changes for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"\"  AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\"  SYSCALL=\"lchown\"  KEY=\"perm_mod\"  SYSCALL_GROUPING=\"chown fchown fchownat lchown\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Events that Modify the System's Discretionary Access Controls",
        "gid": "audit_dac_actions",
        "rid": "audit_rules_dac_modification_lremovexattr",
        "fix_id": "audit_rules_dac_modification_lremovexattr"
      },
      "id": "audit_dac_actions",
      "title": [
        {
          "#text": "Record Events that Modify the System's Discretionary Access Controls - lremovexattr",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file permission changes for all users and root.If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"\"  AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\"  SYSCALL=\"lremovexattr\"  KEY=\"perm_mod\"  SYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Events that Modify the System's Discretionary Access Controls",
        "gid": "audit_dac_actions",
        "rid": "audit_rules_dac_modification_lsetxattr",
        "fix_id": "audit_rules_dac_modification_lsetxattr"
      },
      "id": "audit_dac_actions",
      "title": [
        {
          "#text": "Record Events that Modify the System's Discretionary Access Controls - lsetxattr",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file permission changes for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"\"  AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\"  SYSCALL=\"lsetxattr\"  KEY=\"perm_mod\"  SYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Events that Modify the System's Discretionary Access Controls",
        "gid": "audit_dac_actions",
        "rid": "audit_rules_dac_modification_removexattr",
        "fix_id": "audit_rules_dac_modification_removexattr"
      },
      "id": "audit_dac_actions",
      "title": [
        {
          "#text": "Record Events that Modify the System's Discretionary Access Controls - removexattr",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file permission changes for all users and root.If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"\"  AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\"  SYSCALL=\"removexattr\"  KEY=\"perm_mod\"  SYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Events that Modify the System's Discretionary Access Controls",
        "gid": "audit_dac_actions",
        "rid": "audit_rules_dac_modification_setxattr",
        "fix_id": "audit_rules_dac_modification_setxattr"
      },
      "id": "audit_dac_actions",
      "title": [
        {
          "#text": "Record Events that Modify the System's Discretionary Access Controls - setxattr",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file permission changes for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"\"  AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\"  SYSCALL=\"setxattr\"  KEY=\"perm_mod\"  SYSCALL_GROUPING=\"fremovexattr lremovexattr removexattr fsetxattr lsetxattr setxattr\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Events that Modify the System's Discretionary Access Controls",
        "gid": "audit_dac_actions",
        "rid": "audit_rules_dac_modification_umount",
        "fix_id": "audit_rules_dac_modification_umount"
      },
      "id": "audit_dac_actions",
      "title": [
        {
          "#text": "Record Events that Modify the System's Discretionary Access Controls - umount",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file system umount changes. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"\"  AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\"  SYSCALL=\"umount\"  KEY=\"perm_mod\"  SYSCALL_GROUPING=\"\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Events that Modify the System's Discretionary Access Controls",
        "gid": "audit_dac_actions",
        "rid": "audit_rules_dac_modification_umount2",
        "fix_id": "audit_rules_dac_modification_umount2"
      },
      "id": "audit_dac_actions",
      "title": [
        {
          "#text": "Record Events that Modify the System's Discretionary Access Controls - umount2",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file system umount2 changes. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"\"  AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\"  SYSCALL=\"umount2\"  KEY=\"perm_mod\"  SYSCALL_GROUPING=\"\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Execution Attempts to Run ACL Privileged Commands",
        "gid": "audit_execution_acl_commands",
        "rid": "audit_rules_execution_chacl",
        "fix_id": "audit_rules_execution_chacl"
      },
      "id": "audit_execution_acl_commands",
      "title": [
        {
          "#text": "Record Any Attempts to Run chacl",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect any execution attempt of thecommand for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then ACTION_ARCH_FILTERS=\"-a always,exit\" OTHER_FILTERS=\"-F path=/usr/bin/chacl -F perm=x\" AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Execution Attempts to Run ACL Privileged Commands",
        "gid": "audit_execution_acl_commands",
        "rid": "audit_rules_execution_setfacl",
        "fix_id": "audit_rules_execution_setfacl"
      },
      "id": "audit_execution_acl_commands",
      "title": [
        {
          "#text": "Record Any Attempts to Run setfacl",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect any execution attempt of thecommand for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then ACTION_ARCH_FILTERS=\"-a always,exit\" OTHER_FILTERS=\"-F path=/usr/bin/setfacl -F perm=x\" AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Execution Attempts to Run SELinux Privileged Commands",
        "gid": "audit_execution_selinux_commands",
        "rid": "audit_rules_execution_chcon",
        "fix_id": "audit_rules_execution_chcon"
      },
      "id": "audit_execution_selinux_commands",
      "title": [
        {
          "#text": "Record Any Attempts to Run chcon",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect any execution attempt of thecommand for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then ACTION_ARCH_FILTERS=\"-a always,exit\" OTHER_FILTERS=\"-F path=/usr/bin/chcon -F perm=x\" AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record File Deletion Events by User",
        "gid": "audit_file_deletion_events",
        "rid": "audit_rules_file_deletion_events_rename",
        "fix_id": "audit_rules_file_deletion_events_rename"
      },
      "id": "audit_file_deletion_events",
      "title": [
        {
          "#text": "Ensure auditd Collects File Deletion Events by User - rename",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file deletion events for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory, setting ARCH to either b32 or b64 as appropriate for your system:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile, setting ARCH to either b32 or b64 as appropriate for your system:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"\"  AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\"  SYSCALL=\"rename\"  KEY=\"delete\"  SYSCALL_GROUPING=\"unlink unlinkat rename renameat rmdir\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record File Deletion Events by User",
        "gid": "audit_file_deletion_events",
        "rid": "audit_rules_file_deletion_events_renameat",
        "fix_id": "audit_rules_file_deletion_events_renameat"
      },
      "id": "audit_file_deletion_events",
      "title": [
        {
          "#text": "Ensure auditd Collects File Deletion Events by User - renameat",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file deletion events for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory, setting ARCH to either b32 or b64 as appropriate for your system:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile, setting ARCH to either b32 or b64 as appropriate for your system:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"\"  AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\"  SYSCALL=\"renameat\"  KEY=\"delete\"  SYSCALL_GROUPING=\"unlink unlinkat rename renameat rmdir\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record File Deletion Events by User",
        "gid": "audit_file_deletion_events",
        "rid": "audit_rules_file_deletion_events_rmdir",
        "fix_id": "audit_rules_file_deletion_events_rmdir"
      },
      "id": "audit_file_deletion_events",
      "title": [
        {
          "#text": "Ensure auditd Collects File Deletion Events by User - rmdir",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file deletion events for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory, setting ARCH to either b32 or b64 as appropriate for your system:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile, setting ARCH to either b32 or b64 as appropriate for your system:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"\"  AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\"  SYSCALL=\"rmdir\"  KEY=\"delete\"  SYSCALL_GROUPING=\"unlink unlinkat rename renameat rmdir\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record File Deletion Events by User",
        "gid": "audit_file_deletion_events",
        "rid": "audit_rules_file_deletion_events_unlink",
        "fix_id": "audit_rules_file_deletion_events_unlink"
      },
      "id": "audit_file_deletion_events",
      "title": [
        {
          "#text": "Ensure auditd Collects File Deletion Events by User - unlink",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file deletion events for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory, setting ARCH to either b32 or b64 as appropriate for your system:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile, setting ARCH to either b32 or b64 as appropriate for your system:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"\"  AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\"  SYSCALL=\"unlink\"  KEY=\"delete\"  SYSCALL_GROUPING=\"unlink unlinkat rename renameat rmdir\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record File Deletion Events by User",
        "gid": "audit_file_deletion_events",
        "rid": "audit_rules_file_deletion_events_unlinkat",
        "fix_id": "audit_rules_file_deletion_events_unlinkat"
      },
      "id": "audit_file_deletion_events",
      "title": [
        {
          "#text": "Ensure auditd Collects File Deletion Events by User - unlinkat",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect file deletion events for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory, setting ARCH to either b32 or b64 as appropriate for your system:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile, setting ARCH to either b32 or b64 as appropriate for your system:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"\"  AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\"  SYSCALL=\"unlinkat\"  KEY=\"delete\"  SYSCALL_GROUPING=\"unlink unlinkat rename renameat rmdir\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Unauthorized Access Attempts Events to Files (unsuccessful)",
        "gid": "audit_file_modification",
        "rid": "audit_rules_unsuccessful_file_modification_creat",
        "fix_id": "audit_rules_unsuccessful_file_modification_creat"
      },
      "id": "audit_file_modification",
      "title": [
        {
          "#text": "Record Unsuccessful Access Attempts to Files - creat",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect unauthorized file accesses for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory:If the system is 64 bit then also add the following lines:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile:If the system is 64 bit then also add the following lines:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"creat\" KEY=\"access\" SYSCALL_GROUPING=\"creat ftruncate truncate open openat open_by_handle_at\" for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"-F exit=-EACCES\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"-F exit=-EPERM\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Unauthorized Access Attempts Events to Files (unsuccessful)",
        "gid": "audit_file_modification",
        "rid": "audit_rules_unsuccessful_file_modification_ftruncate",
        "fix_id": "audit_rules_unsuccessful_file_modification_ftruncate"
      },
      "id": "audit_file_modification",
      "title": [
        {
          "#text": "Record Unsuccessful Access Attempts to Files - ftruncate",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect unauthorized file accesses for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory:If the system is 64 bit then also add the following lines:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile:If the system is 64 bit then also add the following lines:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"ftruncate\" KEY=\"access\" SYSCALL_GROUPING=\"creat ftruncate truncate open openat open_by_handle_at\" for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"-F exit=-EACCES\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"-F exit=-EPERM\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Unauthorized Access Attempts Events to Files (unsuccessful)",
        "gid": "audit_file_modification",
        "rid": "audit_rules_unsuccessful_file_modification_open",
        "fix_id": "audit_rules_unsuccessful_file_modification_open"
      },
      "id": "audit_file_modification",
      "title": [
        {
          "#text": "Record Unsuccessful Access Attempts to Files - open",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect unauthorized file accesses for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory:If the system is 64 bit then also add the following lines:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile:If the system is 64 bit then also add the following lines:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"open\" KEY=\"access\" SYSCALL_GROUPING=\"creat ftruncate truncate open openat open_by_handle_at\" for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"-F exit=-EACCES\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"-F exit=-EPERM\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Unauthorized Access Attempts Events to Files (unsuccessful)",
        "gid": "audit_file_modification",
        "rid": "audit_rules_unsuccessful_file_modification_open_by_handle_at",
        "fix_id": "audit_rules_unsuccessful_file_modification_open_by_handle_at"
      },
      "id": "audit_file_modification",
      "title": [
        {
          "#text": "Record Unsuccessful Access Attempts to Files - open_by_handle_at",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect unauthorized file accesses for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory:If the system is 64 bit then also add the following lines:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile:If the system is 64 bit then also add the following lines:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"open_by_handle_at\" KEY=\"access\" SYSCALL_GROUPING=\"creat ftruncate truncate open openat open_by_handle_at\" for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"-F exit=-EACCES\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"-F exit=-EPERM\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Unauthorized Access Attempts Events to Files (unsuccessful)",
        "gid": "audit_file_modification",
        "rid": "audit_rules_unsuccessful_file_modification_openat",
        "fix_id": "audit_rules_unsuccessful_file_modification_openat"
      },
      "id": "audit_file_modification",
      "title": [
        {
          "#text": "Record Unsuccessful Access Attempts to Files - openat",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect unauthorized file accesses for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory:If the system is 64 bit then also add the following lines:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile:If the system is 64 bit then also add the following lines:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"openat\" KEY=\"access\" SYSCALL_GROUPING=\"creat ftruncate truncate open openat open_by_handle_at\" for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"-F exit=-EACCES\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"-F exit=-EPERM\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Unauthorized Access Attempts Events to Files (unsuccessful)",
        "gid": "audit_file_modification",
        "rid": "audit_rules_unsuccessful_file_modification_truncate",
        "fix_id": "audit_rules_unsuccessful_file_modification_truncate"
      },
      "id": "audit_file_modification",
      "title": [
        {
          "#text": "Record Unsuccessful Access Attempts to Files - truncate",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect unauthorized file accesses for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory:If the system is 64 bit then also add the following lines:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile:If the system is 64 bit then also add the following lines:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"truncate\" KEY=\"access\" SYSCALL_GROUPING=\"creat ftruncate truncate open openat open_by_handle_at\" for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"-F exit=-EACCES\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"-F exit=-EPERM\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on Kernel Modules Loading and Unloading",
        "gid": "audit_kernel_module_loading",
        "rid": "audit_rules_kernel_module_loading_delete",
        "fix_id": "audit_rules_kernel_module_loading_delete"
      },
      "id": "audit_kernel_module_loading",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on Kernel Module Unloading - delete_module",
          "@_lang": "en-US"
        }
      ],
      "desc": "To capture kernel module unloading events, use following line, setting ARCH to either b32 for 32-bit system, or having two lines for both b32 and b64 in case your system is 64-bit:Place to add the line depends on a waydaemon is configured. If it is configured to use theprogram (the default), add the line to a file with suffixin the directory. If thedaemon is configured to use theutility, add the line to file.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system # Note: 32-bit and 64-bit kernel syscall numbers not always line up =&gt; # it's required on a 64-bit system to check also for the presence # of 32-bit's equivalent of the corresponding rule. # (See `man 7 audit.rules` for details ) [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"\"  AUID_FILTERS=\"\"  SYSCALL=\"delete_module\"  KEY=\"modules\"  SYSCALL_GROUPING=\"delete_module\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on Kernel Modules Loading and Unloading",
        "gid": "audit_kernel_module_loading",
        "rid": "audit_rules_kernel_module_loading_finit",
        "fix_id": "audit_rules_kernel_module_loading_finit"
      },
      "id": "audit_kernel_module_loading",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on Kernel Module Loading and Unloading - finit_module",
          "@_lang": "en-US"
        }
      ],
      "desc": "If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directoryto capture kernel module loading and unloading events, setting ARCH to either b32 or b64 as appropriate for your system:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile in order to capture kernel module loading and unloading events, setting ARCH to either b32 or b64 as appropriate for your system:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system # Note: 32-bit and 64-bit kernel syscall numbers not always line up =&gt; # it's required on a 64-bit system to check also for the presence # of 32-bit's equivalent of the corresponding rule. # (See `man 7 audit.rules` for details ) [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"\"  AUID_FILTERS=\"\"  SYSCALL=\"finit_module\"  KEY=\"modules\"  SYSCALL_GROUPING=\"init_module finit_module\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on Kernel Modules Loading and Unloading",
        "gid": "audit_kernel_module_loading",
        "rid": "audit_rules_kernel_module_loading_init",
        "fix_id": "audit_rules_kernel_module_loading_init"
      },
      "id": "audit_kernel_module_loading",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on Kernel Module Loading - init_module",
          "@_lang": "en-US"
        }
      ],
      "desc": "To capture kernel module loading events, use following line, setting ARCH to either b32 for 32-bit system, or having two lines for both b32 and b64 in case your system is 64-bit:Place to add the line depends on a waydaemon is configured. If it is configured to use theprogram (the default), add the line to a file with suffixin the directory. If thedaemon is configured to use theutility, add the line to file.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system # Note: 32-bit and 64-bit kernel syscall numbers not always line up =&gt; # it's required on a 64-bit system to check also for the presence # of 32-bit's equivalent of the corresponding rule. # (See `man 7 audit.rules` for details ) [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"\"  AUID_FILTERS=\"\"  SYSCALL=\"init_module\"  KEY=\"modules\"  SYSCALL_GROUPING=\"init_module finit_module\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Attempts to Alter Logon and Logout Events",
        "gid": "audit_login_events",
        "rid": "audit_rules_login_events_faillog",
        "fix_id": "audit_rules_login_events_faillog"
      },
      "id": "audit_login_events",
      "title": [
        {
          "#text": "Record Attempts to Alter Logon and Logout Events - faillog",
          "@_lang": "en-US"
        }
      ],
      "desc": "The audit system already collects login information for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directoryin order to watch for attempted manual edits of files involved in storing logon events:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile in order to watch for unattempted manual edits of files involved in storing logon events:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_watch_rule \"auditctl\" \"/var/log/faillog\" \"wa\" \"logins\" fix_audit_watch_rule \"augenrules\" \"/var/log/faillog\" \"wa\" \"logins\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Attempts to Alter Logon and Logout Events",
        "gid": "audit_login_events",
        "rid": "audit_rules_login_events_lastlog",
        "fix_id": "audit_rules_login_events_lastlog"
      },
      "id": "audit_login_events",
      "title": [
        {
          "#text": "Record Attempts to Alter Logon and Logout Events - lastlog",
          "@_lang": "en-US"
        }
      ],
      "desc": "The audit system already collects login information for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directoryin order to watch for attempted manual edits of files involved in storing logon events:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile in order to watch for unattempted manual edits of files involved in storing logon events:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_watch_rule \"auditctl\" \"/var/log/lastlog\" \"wa\" \"logins\" fix_audit_watch_rule \"augenrules\" \"/var/log/lastlog\" \"wa\" \"logins\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Attempts to Alter Logon and Logout Events",
        "gid": "audit_login_events",
        "rid": "audit_rules_login_events_tallylog",
        "fix_id": "audit_rules_login_events_tallylog"
      },
      "id": "audit_login_events",
      "title": [
        {
          "#text": "Record Attempts to Alter Logon and Logout Events - tallylog",
          "@_lang": "en-US"
        }
      ],
      "desc": "The audit system already collects login information for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directoryin order to watch for attempted manual edits of files involved in storing logon events:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile in order to watch for unattempted manual edits of files involved in storing logon events:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_watch_rule \"auditctl\" \"/var/log/tallylog\" \"wa\" \"logins\" fix_audit_watch_rule \"augenrules\" \"/var/log/tallylog\" \"wa\" \"logins\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on the Use of Privileged Commands",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands",
          "@_lang": "en-US"
        }
      ],
      "desc": "The audit system should collect information about usage of privileged commands for all users and root. To find the relevant setuid / setgid programs, run the following command for each local partition:If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directoryfor each setuid / setgid program on the system, replacing thepart with the full path of that setuid / setgid program in the list:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form tofor each setuid / setgid program on the system, replacing thepart with the full path of that setuid / setgid program in the list:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on the Use of Privileged Commands",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_apparmor_parser",
        "fix_id": "audit_rules_privileged_commands_apparmor_parser"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Record Any Attempts to Run apparmor_parser",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect any execution attempt of thecommand for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then ACTION_ARCH_FILTERS=\"-a always,exit\" OTHER_FILTERS=\"-F path=/sbin/apparmor_parser -F perm=x\" AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on the Use of Privileged Commands",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_at",
        "fix_id": "audit_rules_privileged_commands_at"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - at",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then ACTION_ARCH_FILTERS=\"-a always,exit\" OTHER_FILTERS=\"-F path=/usr/bin/at -F perm=x\" AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on the Use of Privileged Commands",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_chage",
        "fix_id": "audit_rules_privileged_commands_chage"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - chage",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then ACTION_ARCH_FILTERS=\"-a always,exit\" OTHER_FILTERS=\"-F path=/usr/bin/chage -F perm=x\" AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on the Use of Privileged Commands",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_chfn",
        "fix_id": "audit_rules_privileged_commands_chfn"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - chfn",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then ACTION_ARCH_FILTERS=\"-a always,exit\" OTHER_FILTERS=\"-F path=/usr/bin/chfn -F perm=x\" AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on the Use of Privileged Commands",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_chsh",
        "fix_id": "audit_rules_privileged_commands_chsh"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - chsh",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then ACTION_ARCH_FILTERS=\"-a always,exit\" OTHER_FILTERS=\"-F path=/usr/bin/chsh -F perm=x\" AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on the Use of Privileged Commands",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_crontab",
        "fix_id": "audit_rules_privileged_commands_crontab"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - crontab",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then ACTION_ARCH_FILTERS=\"-a always,exit\" OTHER_FILTERS=\"-F path=/usr/bin/crontab -F perm=x\" AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on the Use of Privileged Commands",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_fdisk",
        "fix_id": "audit_rules_privileged_commands_fdisk"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - fdisk",
          "@_lang": "en-US"
        }
      ],
      "desc": "Configure the operating system to audit the execution of the partition management program \"fdisk\".",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_watch_rule \"auditctl\" \"/sbin/fdisk\" \"x\" \"modules\" fix_audit_watch_rule \"augenrules\" \"/sbin/fdisk\" \"x\" \"modules\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on the Use of Privileged Commands",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_gpasswd",
        "fix_id": "audit_rules_privileged_commands_gpasswd"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - gpasswd",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then ACTION_ARCH_FILTERS=\"-a always,exit\" OTHER_FILTERS=\"-F path=/usr/bin/gpasswd -F perm=x\" AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on the Use of Privileged Commands",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_insmod",
        "fix_id": "audit_rules_privileged_commands_insmod"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - insmod",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_watch_rule \"auditctl\" \"/sbin/insmod\" \"x\" \"modules\" fix_audit_watch_rule \"augenrules\" \"/sbin/insmod\" \"x\" \"modules\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on the Use of Privileged Commands",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_kmod_0",
        "fix_id": "audit_rules_privileged_commands_kmod_0"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - kmod",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; thenfix_audit_watch_rule \"auditctl\" \"/bin/kmod\" \"x\" \"modules\" fix_audit_watch_rule \"augenrules\" \"/bin/kmod\" \"x\" \"modules\" augenrules --load else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on the Use of Privileged Commands",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_modprobe",
        "fix_id": "audit_rules_privileged_commands_modprobe"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - modprobe",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_watch_rule \"auditctl\" \"/sbin/modprobe\" \"x\" \"modules\" fix_audit_watch_rule \"augenrules\" \"/sbin/modprobe\" \"x\" \"modules\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on the Use of Privileged Commands",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_mount",
        "fix_id": "audit_rules_privileged_commands_mount"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - mount",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then ACTION_ARCH_FILTERS=\"-a always,exit\" OTHER_FILTERS=\"-F path=/usr/bin/mount -F perm=x\" AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on the Use of Privileged Commands",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_newgidmap",
        "fix_id": "audit_rules_privileged_commands_newgidmap"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - newgidmap",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then ACTION_ARCH_FILTERS=\"-a always,exit\" OTHER_FILTERS=\"-F path=/usr/bin/newgidmap -F perm=x\" AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on the Use of Privileged Commands",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_newgrp",
        "fix_id": "audit_rules_privileged_commands_newgrp"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - newgrp",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then ACTION_ARCH_FILTERS=\"-a always,exit\" OTHER_FILTERS=\"-F path=/usr/bin/newgrp -F perm=x\" AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on the Use of Privileged Commands",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_newuidmap",
        "fix_id": "audit_rules_privileged_commands_newuidmap"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - newuidmap",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then ACTION_ARCH_FILTERS=\"-a always,exit\" OTHER_FILTERS=\"-F path=/usr/bin/newuidmap -F perm=x\" AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on the Use of Privileged Commands",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_pam_timestamp_check",
        "fix_id": "audit_rules_privileged_commands_pam_timestamp_check"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - pam_timestamp_check",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then ACTION_ARCH_FILTERS=\"-a always,exit\" OTHER_FILTERS=\"-F path=/usr/sbin/pam_timestamp_check -F perm=x\" AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on the Use of Privileged Commands",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_passwd",
        "fix_id": "audit_rules_privileged_commands_passwd"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - passwd",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then ACTION_ARCH_FILTERS=\"-a always,exit\" OTHER_FILTERS=\"-F path=/usr/bin/passwd -F perm=x\" AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on the Use of Privileged Commands",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_postdrop",
        "fix_id": "audit_rules_privileged_commands_postdrop"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - postdrop",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then ACTION_ARCH_FILTERS=\"-a always,exit\" OTHER_FILTERS=\"-F path=/usr/sbin/postdrop -F perm=x\" AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on the Use of Privileged Commands",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_postqueue",
        "fix_id": "audit_rules_privileged_commands_postqueue"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - postqueue",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then ACTION_ARCH_FILTERS=\"-a always,exit\" OTHER_FILTERS=\"-F path=/usr/sbin/postqueue -F perm=x\" AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on the Use of Privileged Commands",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_rmmod",
        "fix_id": "audit_rules_privileged_commands_rmmod"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - rmmod",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_watch_rule \"auditctl\" \"/sbin/rmmod\" \"x\" \"modules\" fix_audit_watch_rule \"augenrules\" \"/sbin/rmmod\" \"x\" \"modules\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on the Use of Privileged Commands",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_ssh_agent",
        "fix_id": "audit_rules_privileged_commands_ssh_agent"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Record Any Attempts to Run ssh-agent",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect any execution attempt of thecommand for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then ACTION_ARCH_FILTERS=\"-a always,exit\" OTHER_FILTERS=\"-F path=/usr/bin/ssh-agent -F perm=x\" AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on the Use of Privileged Commands",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_ssh_keysign",
        "fix_id": "audit_rules_privileged_commands_ssh_keysign"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - ssh-keysign",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then ACTION_ARCH_FILTERS=\"-a always,exit\" OTHER_FILTERS=\"-F path=/usr/lib/openssh/ssh-keysign -F perm=x\" AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on the Use of Privileged Commands",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_su",
        "fix_id": "audit_rules_privileged_commands_su"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - su",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then ACTION_ARCH_FILTERS=\"-a always,exit\" OTHER_FILTERS=\"-F path=/usr/bin/su -F perm=x\" AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on the Use of Privileged Commands",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_sudo",
        "fix_id": "audit_rules_privileged_commands_sudo"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - sudo",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then ACTION_ARCH_FILTERS=\"-a always,exit\" OTHER_FILTERS=\"-F path=/usr/bin/sudo -F perm=x\" AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on the Use of Privileged Commands",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_sudoedit",
        "fix_id": "audit_rules_privileged_commands_sudoedit"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - sudoedit",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then ACTION_ARCH_FILTERS=\"-a always,exit\" OTHER_FILTERS=\"-F path=/usr/bin/sudoedit -F perm=x\" AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on the Use of Privileged Commands",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_umount",
        "fix_id": "audit_rules_privileged_commands_umount"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - umount",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then ACTION_ARCH_FILTERS=\"-a always,exit\" OTHER_FILTERS=\"-F path=/usr/bin/umount -F perm=x\" AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on the Use of Privileged Commands",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_unix_chkpwd",
        "fix_id": "audit_rules_privileged_commands_unix_chkpwd"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - unix_chkpwd",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then ACTION_ARCH_FILTERS=\"-a always,exit\" OTHER_FILTERS=\"-F path=/usr/sbin/unix_chkpwd -F perm=x\" AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on the Use of Privileged Commands",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_unix_update",
        "fix_id": "audit_rules_privileged_commands_unix_update"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - unix_update",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then ACTION_ARCH_FILTERS=\"-a always,exit\" OTHER_FILTERS=\"-F path=/sbin/unix_update -F perm=x\" AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Record Information on the Use of Privileged Commands",
        "gid": "audit_privileged_commands",
        "rid": "audit_rules_privileged_commands_usermod",
        "fix_id": "audit_rules_privileged_commands_usermod"
      },
      "id": "audit_privileged_commands",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on the Use of Privileged Commands - usermod",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect the execution of privileged commands for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add a line of the following form to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add a line of the following form to:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then ACTION_ARCH_FILTERS=\"-a always,exit\" OTHER_FILTERS=\"-F path=/usr/sbin/usermod -F perm=x\" AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"privileged\" SYSCALL_GROUPING=\"\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Records Events that Modify Date and Time Information",
        "gid": "audit_time_rules",
        "rid": "audit_rules_time_adjtimex",
        "fix_id": "audit_rules_time_adjtimex"
      },
      "id": "audit_time_rules",
      "title": [
        {
          "#text": "Record attempts to alter time through adjtimex",
          "@_lang": "en-US"
        }
      ],
      "desc": "If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:The -k option allows for the specification of a key in string form that can be used for better reporting capability through ausearch and aureport. Multiple system calls can be defined on the same line to save space if desired, but is not required. See an example of multiple combined syscalls:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; thenperform_audit_adjtimex_settimeofday_stime_remediation else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Records Events that Modify Date and Time Information",
        "gid": "audit_time_rules",
        "rid": "audit_rules_time_clock_settime",
        "fix_id": "audit_rules_time_clock_settime"
      },
      "id": "audit_time_rules",
      "title": [
        {
          "#text": "Record Attempts to Alter Time Through clock_settime",
          "@_lang": "en-US"
        }
      ],
      "desc": "If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:The -k option allows for the specification of a key in string form that can be used for better reporting capability through ausearch and aureport. Multiple system calls can be defined on the same line to save space if desired, but is not required. See an example of multiple combined syscalls:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"-F a0=0x0\"  AUID_FILTERS=\"\"  SYSCALL=\"clock_settime\"  KEY=\"time-change\"  SYSCALL_GROUPING=\"\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Records Events that Modify Date and Time Information",
        "gid": "audit_time_rules",
        "rid": "audit_rules_time_settimeofday",
        "fix_id": "audit_rules_time_settimeofday"
      },
      "id": "audit_time_rules",
      "title": [
        {
          "#text": "Record attempts to alter time through settimeofday",
          "@_lang": "en-US"
        }
      ],
      "desc": "If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If the system is 64 bit then also add the following line:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:If the system is 64 bit then also add the following line:The -k option allows for the specification of a key in string form that can be used for better reporting capability through ausearch and aureport. Multiple system calls can be defined on the same line to save space if desired, but is not required. See an example of multiple combined syscalls:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; thenperform_audit_adjtimex_settimeofday_stime_remediation else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Records Events that Modify Date and Time Information",
        "gid": "audit_time_rules",
        "rid": "audit_rules_time_stime",
        "fix_id": "audit_rules_time_stime"
      },
      "id": "audit_time_rules",
      "title": [
        {
          "#text": "Record Attempts to Alter Time Through stime",
          "@_lang": "en-US"
        }
      ],
      "desc": "If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directoryfor both 32 bit and 64 bit systems:Since the 64 bit version of the \"stime\" system call is not defined in the audit lookup table, the corresponding \"-F arch=b64\" form of this rule is not expected to be defined on 64 bit systems (the aforementioned \"-F arch=b32\" stime rule form itself is sufficient for both 32 bit and 64 bit systems). If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile for both 32 bit and 64 bit systems:Since the 64 bit version of the \"stime\" system call is not defined in the audit lookup table, the corresponding \"-F arch=b64\" form of this rule is not expected to be defined on 64 bit systems (the aforementioned \"-F arch=b32\" stime rule form itself is sufficient for both 32 bit and 64 bit systems). The -k option allows for the specification of a key in string form that can be used for better reporting capability through ausearch and aureport. Multiple system calls can be defined on the same line to save space if desired, but is not required. See an example of multiple combined system calls:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; thenperform_audit_adjtimex_settimeofday_stime_remediation else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Records Events that Modify Date and Time Information",
        "gid": "audit_time_rules",
        "rid": "audit_rules_time_watch_localtime",
        "fix_id": "audit_rules_time_watch_localtime"
      },
      "id": "audit_time_rules",
      "title": [
        {
          "#text": "Record Attempts to Alter the localtime File",
          "@_lang": "en-US"
        }
      ],
      "desc": "If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:The -k option allows for the specification of a key in string form that can be used for better reporting capability through ausearch and aureport and should always be used.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_watch_rule \"auditctl\" \"/etc/localtime\" \"wa\" \"audit_time_rules\" fix_audit_watch_rule \"augenrules\" \"/etc/localtime\" \"wa\" \"audit_time_rules\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing",
        "gid": "auditd_configure_rules",
        "rid": "audit_rules_immutable",
        "fix_id": "audit_rules_immutable"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Make the auditd Configuration Immutable",
          "@_lang": "en-US"
        }
      ],
      "desc": "If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directoryin order to make the auditd configuration immutable:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile in order to make the auditd configuration immutable:With this setting, a reboot will be required to change any audit rules.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # Traverse all of: # # /etc/audit/audit.rules,   (for auditctl case) # /etc/audit/rules.d/*.rules   (for augenrules case) # # files to check if '-e .*' setting is present in that '*.rules' file already. # If found, delete such occurrence since auditctl(8) manual page instructs the # '-e 2' rule should be placed as the last rule in the configuration find /etc/audit /etc/audit/rules.d -maxdepth 1 -type f -name '*.rules' -exec sed -i '/-e[[:space:]]\\+.*/d' {} ';' # Append '-e 2' requirement at the end of both: # * /etc/audit/audit.rules file   (for auditctl case) # * /etc/audit/rules.d/immutable.rules  (for augenrules case) for AUDIT_FILE in \"/etc/audit/audit.rules\" \"/etc/audit/rules.d/immutable.rules\" do  echo '' &gt;&gt; $AUDIT_FILE  echo '# Set the audit.rules configuration immutable per security requirements' &gt;&gt; $AUDIT_FILE  echo '# Reboot is required to change audit rules once this setting is applied' &gt;&gt; $AUDIT_FILE  echo '-e 2' &gt;&gt; $AUDIT_FILE  chmod o-rwx $AUDIT_FILE done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing",
        "gid": "auditd_configure_rules",
        "rid": "audit_rules_mac_modification",
        "fix_id": "audit_rules_mac_modification"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Record Events that Modify the System's Mandatory Access Controls",
          "@_lang": "en-US"
        }
      ],
      "desc": "If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_watch_rule \"auditctl\" \"/etc/apparmor/\" \"wa\" \"MAC-policy\" fix_audit_watch_rule \"auditctl\" \"/etc/apparmor.d/\" \"wa\" \"MAC-policy\"fix_audit_watch_rule \"augenrules\" \"/etc/apparmor/\" \"wa\" \"MAC-policy\" fix_audit_watch_rule \"augenrules\" \"/etc/apparmor.d/\" \"wa\" \"MAC-policy\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing",
        "gid": "auditd_configure_rules",
        "rid": "audit_rules_media_export",
        "fix_id": "audit_rules_media_export"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Ensure auditd Collects Information on Exporting to Media (successful)",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect media exportation events for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory, setting ARCH to either b32 or b64 as appropriate for your system:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile, setting ARCH to either b32 or b64 as appropriate for your system:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"\"  AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\"  SYSCALL=\"mount\"  KEY=\"perm_mod\"  SYSCALL_GROUPING=\"\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing",
        "gid": "auditd_configure_rules",
        "rid": "audit_rules_networkconfig_modification",
        "fix_id": "audit_rules_networkconfig_modification"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Record Events that Modify the System's Network Environment",
          "@_lang": "en-US"
        }
      ],
      "desc": "If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory, setting ARCH to either b32 or b64 as appropriate for your system:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile, setting ARCH to either b32 or b64 as appropriate for your system:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"\"  AUID_FILTERS=\"\"  SYSCALL=\"sethostname setdomainname\"  KEY=\"audit_rules_networkconfig_modification\"  SYSCALL_GROUPING=\"sethostname setdomainname\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done # Then perform the remediations for the watch rules # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_watch_rule \"auditctl\" \"/etc/issue\" \"wa\" \"audit_rules_networkconfig_modification\" fix_audit_watch_rule \"augenrules\" \"/etc/issue\" \"wa\" \"audit_rules_networkconfig_modification\"fix_audit_watch_rule \"auditctl\" \"/etc/issue.net\" \"wa\" \"audit_rules_networkconfig_modification\" fix_audit_watch_rule \"augenrules\" \"/etc/issue.net\" \"wa\" \"audit_rules_networkconfig_modification\"fix_audit_watch_rule \"auditctl\" \"/etc/hosts\" \"wa\" \"audit_rules_networkconfig_modification\" fix_audit_watch_rule \"augenrules\" \"/etc/hosts\" \"wa\" \"audit_rules_networkconfig_modification\"fix_audit_watch_rule \"auditctl\" \"/etc/network\" \"wa\" \"audit_rules_networkconfig_modification\" fix_audit_watch_rule \"augenrules\" \"/etc/network\" \"wa\" \"audit_rules_networkconfig_modification\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing",
        "gid": "auditd_configure_rules",
        "rid": "audit_rules_session_events",
        "fix_id": "audit_rules_session_events"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Record Attempts to Alter Process and Session Initiation Information",
          "@_lang": "en-US"
        }
      ],
      "desc": "The audit system already collects process information for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directoryin order to watch for attempted manual edits of files involved in storing such process information:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile in order to watch for attempted manual edits of files involved in storing such process information:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # Perform the remediation # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_watch_rule \"auditctl\" \"/var/run/utmp\" \"wa\" \"session\" fix_audit_watch_rule \"augenrules\" \"/var/run/utmp\" \"wa\" \"session\"fix_audit_watch_rule \"auditctl\" \"/var/log/btmp\" \"wa\" \"session\" fix_audit_watch_rule \"augenrules\" \"/var/log/btmp\" \"wa\" \"session\"fix_audit_watch_rule \"auditctl\" \"/var/log/wtmp\" \"wa\" \"session\" fix_audit_watch_rule \"augenrules\" \"/var/log/wtmp\" \"wa\" \"session\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing",
        "gid": "auditd_configure_rules",
        "rid": "audit_rules_session_events_btmp",
        "fix_id": "audit_rules_session_events_btmp"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Record Attempts to Alter Process and Session Initiation Information btmp",
          "@_lang": "en-US"
        }
      ],
      "desc": "The audit system already collects process information for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directoryin order to watch for attempted manual edits of files involved in storing such process information:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile in order to watch for attempted manual edits of files involved in storing such process information:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # Perform the remediation # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_watch_rule \"auditctl\" \"/var/log/btmp\" \"wa\" \"session\" fix_audit_watch_rule \"augenrules\" \"/var/log/btmp\" \"wa\" \"session\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing",
        "gid": "auditd_configure_rules",
        "rid": "audit_rules_session_events_utmp",
        "fix_id": "audit_rules_session_events_utmp"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Record Attempts to Alter Process and Session Initiation Information utmp",
          "@_lang": "en-US"
        }
      ],
      "desc": "The audit system already collects process information for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directoryin order to watch for attempted manual edits of files involved in storing such process information:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile in order to watch for attempted manual edits of files involved in storing such process information:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # Perform the remediation # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_watch_rule \"auditctl\" \"/var/run/utmp\" \"wa\" \"session\" fix_audit_watch_rule \"augenrules\" \"/var/run/utmp\" \"wa\" \"session\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing",
        "gid": "auditd_configure_rules",
        "rid": "audit_rules_session_events_wtmp",
        "fix_id": "audit_rules_session_events_wtmp"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Record Attempts to Alter Process and Session Initiation Information wtmp",
          "@_lang": "en-US"
        }
      ],
      "desc": "The audit system already collects process information for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directoryin order to watch for attempted manual edits of files involved in storing such process information:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile in order to watch for attempted manual edits of files involved in storing such process information:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # Perform the remediation # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_watch_rule \"auditctl\" \"/var/log/wtmp\" \"wa\" \"session\" fix_audit_watch_rule \"augenrules\" \"/var/log/wtmp\" \"wa\" \"session\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing",
        "gid": "auditd_configure_rules",
        "rid": "audit_rules_suid_privilege_function",
        "fix_id": "audit_rules_suid_privilege_function"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Record Events When Privileged Executables Are Run",
          "@_lang": "en-US"
        }
      ],
      "desc": "Verify the system generates an audit record when privileged functions are executed.If both the \"b32\" and \"b64\" audit rules for \"SUID\" files are not defined, this is a finding. If both the \"b32\" and \"b64\" audit rules for \"SGID\" files are not defined, this is a finding.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # First perform the remediation of the syscall rule # Retrieve hardware architecture of the underlying system [ \"$(getconf LONG_BIT)\" = \"32\" ] &amp;&amp; RULE_ARCHS=(\"b32\") || RULE_ARCHS=(\"b32\" \"b64\") for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"-C uid!=euid -F euid=0\"  AUID_FILTERS=\"\"  SYSCALL=\"execve\"  KEY=\"setuid\"  SYSCALL_GROUPING=\"\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done for ARCH in \"${RULE_ARCHS[@]}\" do  ACTION_ARCH_FILTERS=\"-a always,exit -F arch=$ARCH\"  OTHER_FILTERS=\"-C gid!=egid -F egid=0\"  AUID_FILTERS=\"\"  SYSCALL=\"execve\"  KEY=\"setgid\"  SYSCALL_GROUPING=\"\"  # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\"  fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing",
        "gid": "auditd_configure_rules",
        "rid": "audit_rules_sysadmin_actions",
        "fix_id": "audit_rules_sysadmin_actions"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Ensure auditd Collects System Administrator Actions",
          "@_lang": "en-US"
        }
      ],
      "desc": "At a minimum, the audit system should collect administrator actions for all users and root. If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following line to a file with suffixin the directory:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following line tofile:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_watch_rule \"auditctl\" \"/etc/sudoers\" \"wa\" \"actions\" fix_audit_watch_rule \"augenrules\" \"/etc/sudoers\" \"wa\" \"actions\"fix_audit_watch_rule \"auditctl\" \"/etc/sudoers.d/\" \"wa\" \"actions\" fix_audit_watch_rule \"augenrules\" \"/etc/sudoers.d/\" \"wa\" \"actions\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing",
        "gid": "auditd_configure_rules",
        "rid": "audit_rules_usergroup_modification"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Record Events that Modify User/Group Information",
          "@_lang": "en-US"
        }
      ],
      "desc": "If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory, in order to capture events that modify account changes:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile, in order to capture events that modify account changes:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing",
        "gid": "auditd_configure_rules",
        "rid": "audit_rules_usergroup_modification_group",
        "fix_id": "audit_rules_usergroup_modification_group"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Record Events that Modify User/Group Information - /etc/group",
          "@_lang": "en-US"
        }
      ],
      "desc": "If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory, in order to capture events that modify account changes:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile, in order to capture events that modify account changes:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_watch_rule \"auditctl\" \"/etc/group\" \"wa\" \"audit_rules_usergroup_modification\" fix_audit_watch_rule \"augenrules\" \"/etc/group\" \"wa\" \"audit_rules_usergroup_modification\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing",
        "gid": "auditd_configure_rules",
        "rid": "audit_rules_usergroup_modification_gshadow",
        "fix_id": "audit_rules_usergroup_modification_gshadow"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Record Events that Modify User/Group Information - /etc/gshadow",
          "@_lang": "en-US"
        }
      ],
      "desc": "If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory, in order to capture events that modify account changes:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile, in order to capture events that modify account changes:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_watch_rule \"auditctl\" \"/etc/gshadow\" \"wa\" \"audit_rules_usergroup_modification\" fix_audit_watch_rule \"augenrules\" \"/etc/gshadow\" \"wa\" \"audit_rules_usergroup_modification\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing",
        "gid": "auditd_configure_rules",
        "rid": "audit_rules_usergroup_modification_opasswd",
        "fix_id": "audit_rules_usergroup_modification_opasswd"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Record Events that Modify User/Group Information - /etc/security/opasswd",
          "@_lang": "en-US"
        }
      ],
      "desc": "If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory, in order to capture events that modify account changes:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile, in order to capture events that modify account changes:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_watch_rule \"auditctl\" \"/etc/security/opasswd\" \"wa\" \"audit_rules_usergroup_modification\" fix_audit_watch_rule \"augenrules\" \"/etc/security/opasswd\" \"wa\" \"audit_rules_usergroup_modification\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing",
        "gid": "auditd_configure_rules",
        "rid": "audit_rules_usergroup_modification_passwd",
        "fix_id": "audit_rules_usergroup_modification_passwd"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Record Events that Modify User/Group Information - /etc/passwd",
          "@_lang": "en-US"
        }
      ],
      "desc": "If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory, in order to capture events that modify account changes:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile, in order to capture events that modify account changes:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_watch_rule \"auditctl\" \"/etc/passwd\" \"wa\" \"audit_rules_usergroup_modification\" fix_audit_watch_rule \"augenrules\" \"/etc/passwd\" \"wa\" \"audit_rules_usergroup_modification\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing",
        "gid": "auditd_configure_rules",
        "rid": "audit_rules_usergroup_modification_shadow",
        "fix_id": "audit_rules_usergroup_modification_shadow"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Record Events that Modify User/Group Information - /etc/shadow",
          "@_lang": "en-US"
        }
      ],
      "desc": "If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the following lines to a file with suffixin the directory, in order to capture events that modify account changes:If thedaemon is configured to use theutility to read audit rules during daemon startup, add the following lines tofile, in order to capture events that modify account changes:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_watch_rule \"auditctl\" \"/etc/shadow\" \"wa\" \"audit_rules_usergroup_modification\" fix_audit_watch_rule \"augenrules\" \"/etc/shadow\" \"wa\" \"audit_rules_usergroup_modification\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing",
        "gid": "auditd_configure_rules",
        "rid": "audit_sudo_log_events",
        "fix_id": "audit_sudo_log_events"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Record Attempts to perform maintenance activities",
          "@_lang": "en-US"
        }
      ],
      "desc": "The Ubuntu 20.04 operating system must generate audit records for privileged activities, nonlocal maintenance, diagnostic sessions and other system-level access. Verify the operating system audits activities performed during nonlocal maintenance and diagnostic sessions. Run the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_watch_rule \"auditctl\" \"/var/log/sudo.log\" \"wa\" \"logins\" fix_audit_watch_rule \"augenrules\" \"/var/log/sudo.log\" \"wa\" \"logins\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing",
        "gid": "auditd_configure_rules",
        "rid": "directory_access_var_log_audit",
        "fix_id": "directory_access_var_log_audit"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Record Access Events to Audit Log Directory",
          "@_lang": "en-US"
        }
      ],
      "desc": "The audit system should collect access events to read audit log directory. The following audit rule will assure that access to audit log directory are collected.If thedaemon is configured to use theprogram to read audit rules during daemon startup (the default), add the rule to a file with suffixin the directory. If thedaemon is configured to use theutility to read audit rules during daemon startup, add the rule tofile.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then ACTION_ARCH_FILTERS=\"-a always,exit\" OTHER_FILTERS=\"-F dir=/var/log/audit/ -F perm=r\" AUID_FILTERS=\"-F auid&gt;=1000 -F auid!=unset\" SYSCALL=\"\" KEY=\"access-audit-trail\" SYSCALL_GROUPING=\"\" # Perform the remediation for both possible tools: 'auditctl' and 'augenrules'fix_audit_syscall_rule \"augenrules\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" fix_audit_syscall_rule \"auditctl\" \"$ACTION_ARCH_FILTERS\" \"$OTHER_FILTERS\" \"$AUID_FILTERS\" \"$SYSCALL\" \"$SYSCALL_GROUPING\" \"$KEY\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing",
        "gid": "auditd_configure_rules",
        "rid": "directory_permissions_var_log_audit",
        "fix_id": "directory_permissions_var_log_audit"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "System Audit Logs Must Have Mode 0750 or Less Permissive",
          "@_lang": "en-US"
        }
      ],
      "desc": "Ifinis set to a group other than thegroup account, change the mode of the audit log files with the following command:Otherwise, change the mode of the audit log files with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if LC_ALL=C grep -iw ^log_file /etc/audit/auditd.conf; then DIR=$(awk -F \"=\" '/^log_file/ {print $2}' /etc/audit/auditd.conf | tr -d ' ' | rev | cut -d\"/\" -f2- | rev) else DIR=\"/var/log/audit\" fi if LC_ALL=C grep -m 1 -q ^log_group /etc/audit/auditd.conf; then GROUP=$(awk -F \"=\" '/log_group/ {print $2}' /etc/audit/auditd.conf | tr -d ' ') if ! [ \"${GROUP}\" == 'root' ] ; then chmod 0750 $DIR else chmod 0700 $DIR fi else chmod 0700 $DIR fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing",
        "gid": "auditd_configure_rules",
        "rid": "file_group_ownership_var_log_audit",
        "fix_id": "file_group_ownership_var_log_audit"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "System Audit Logs Must Be Group Owned By Root",
          "@_lang": "en-US"
        }
      ],
      "desc": "All audit logs must be group owned by root user. By default, the path for audit log is. To properly set the group owner of, run the command:Ifinis set to a group other than thegroup account, change the group ownership of the audit logs to this specific group.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if LC_ALL=C grep -iw log_file /etc/audit/auditd.conf; then FILE=$(awk -F \"=\" '/^log_file/ {print $2}' /etc/audit/auditd.conf | tr -d ' ') else FILE=\"/var/log/audit/audit.log\" fi if LC_ALL=C grep -m 1 -q ^log_group /etc/audit/auditd.conf; then GROUP=$(awk -F \"=\" '/log_group/ {print $2}' /etc/audit/auditd.conf | tr -d ' ') if ! [ \"${GROUP}\" == 'root' ]; then chgrp ${GROUP} $FILE* else chgrp root $FILE* fi else chgrp root $FILE* fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing",
        "gid": "auditd_configure_rules",
        "rid": "file_groupownership_audit_configuration",
        "fix_id": "file_groupownership_audit_configuration"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Audit Configuration Files Must Be Owned By Group root",
          "@_lang": "en-US"
        }
      ],
      "desc": "All audit configuration files must be owned by group root.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then readarray -t files &lt; &lt;(find /etc/audit/) for file in \"${files[@]}\"; do if basename $file | grep -qE '^audit(\\.rules|d\\.conf)$'; then chgrp 0 $file fi done readarray -t files &lt; &lt;(find /etc/audit/rules.d/) for file in \"${files[@]}\"; do if basename $file | grep -qE '^.*\\.rules$'; then chgrp 0 $file fi done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing",
        "gid": "auditd_configure_rules",
        "rid": "file_ownership_audit_configuration",
        "fix_id": "file_ownership_audit_configuration"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "Audit Configuration Files Must Be Owned By Root",
          "@_lang": "en-US"
        }
      ],
      "desc": "All audit configuration files must be owned by root user. To properly set the owner of, run the command:To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then readarray -t files &lt; &lt;(find /etc/audit/) for file in \"${files[@]}\"; do if basename $file | grep -qE '^audit(\\.rules|d\\.conf)$'; then chown 0 $file fi done readarray -t files &lt; &lt;(find /etc/audit/rules.d/) for file in \"${files[@]}\"; do if basename $file | grep -qE '^.*\\.rules$'; then chown 0 $file fi done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing",
        "gid": "auditd_configure_rules",
        "rid": "file_ownership_var_log_audit",
        "fix_id": "file_ownership_var_log_audit"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "System Audit Logs Must Be Owned By Root",
          "@_lang": "en-US"
        }
      ],
      "desc": "All audit logs must be owned by root user and group. By default, the path for audit log is. To properly set the owner of, run the command:To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if LC_ALL=C grep -m 1 -q ^log_group /etc/audit/auditd.conf; then GROUP=$(awk -F \"=\" '/log_group/ {print $2}' /etc/audit/auditd.conf | tr -d ' ') if ! [ \"${GROUP}\" == 'root' ] ; then chown root.${GROUP} /var/log/audit chown root.${GROUP} /var/log/audit/audit.log* else chown root.root /var/log/audit chown root.root /var/log/audit/audit.log* fi else chown root.root /var/log/audit chown root.root /var/log/audit/audit.log* fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing",
        "gid": "auditd_configure_rules",
        "rid": "file_ownership_var_log_audit_stig",
        "fix_id": "file_ownership_var_log_audit_stig"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "System Audit Logs Must Be Owned By Root",
          "@_lang": "en-US"
        }
      ],
      "desc": "All audit logs must be owned by root user. By default, the path for audit log is. To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if LC_ALL=C grep -iw log_file /etc/audit/auditd.conf; then FILE=$(awk -F \"=\" '/^log_file/ {print $2}' /etc/audit/auditd.conf | tr -d ' ') chown root $FILE* else chown root /var/log/audit/audit.log* fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Rules for Comprehensive Auditing",
        "gid": "auditd_configure_rules",
        "rid": "file_permissions_var_log_audit",
        "fix_id": "file_permissions_var_log_audit"
      },
      "id": "auditd_configure_rules",
      "title": [
        {
          "#text": "System Audit Logs Must Have Mode 0640 or Less Permissive",
          "@_lang": "en-US"
        }
      ],
      "desc": "Ifinis set to a group other than thegroup account, change the mode of the audit log files with the following command:Otherwise, change the mode of the audit log files with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if LC_ALL=C grep -iw log_file /etc/audit/auditd.conf; then FILE=$(awk -F \"=\" '/^log_file/ {print $2}' /etc/audit/auditd.conf | tr -d ' ') else FILE=\"/var/log/audit/audit.log\" fi if LC_ALL=C grep -m 1 -q ^log_group /etc/audit/auditd.conf; then GROUP=$(awk -F \"=\" '/log_group/ {print $2}' /etc/audit/auditd.conf | tr -d ' ') if ! [ \"${GROUP}\" == 'root' ] ; then chmod 0640 $FILE chmod 0440 $FILE.* else chmod 0600 $FILE chmod 0400 $FILE.* fi else chmod 0600 $FILE chmod 0400 $FILE.* fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "System Accounting with auditd",
        "gid": "auditing",
        "rid": "package_audit-audispd-plugins_installed",
        "fix_id": "package_audit-audispd-plugins_installed"
      },
      "id": "auditing",
      "title": [
        {
          "#text": "Ensure the default plugins for the audit dispatcher are Installed",
          "@_lang": "en-US"
        }
      ],
      "desc": "The audit-audispd-plugins package should be installed.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"audispd-plugins\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "System Accounting with auditd",
        "gid": "auditing",
        "rid": "package_audit_installed",
        "fix_id": "package_audit_installed"
      },
      "id": "auditing",
      "title": [
        {
          "#text": "Ensure the audit Subsystem is Installed",
          "@_lang": "en-US"
        }
      ],
      "desc": "The audit package should be installed.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"auditd\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "System Accounting with auditd",
        "gid": "auditing",
        "rid": "service_auditd_enabled",
        "fix_id": "service_auditd_enabled"
      },
      "id": "auditing",
      "title": [
        {
          "#text": "Enable auditd Service",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice is an essential userspace component of the Linux Auditing System, as it is responsible for writing audit records to disk. Theservice can be enabled with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" unmask 'auditd.service' \"$SYSTEMCTL_EXEC\" start 'auditd.service' \"$SYSTEMCTL_EXEC\" enable 'auditd.service' else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "System Accounting with auditd",
        "gid": "auditing",
        "rid": "grub2_audit_argument",
        "fix_id": "grub2_audit_argument"
      },
      "id": "auditing",
      "title": [
        {
          "#text": "Enable Auditing for Processes Which Start Prior to the Audit Daemon",
          "@_lang": "en-US"
        }
      ],
      "desc": "To ensure all processes can be audited, even those which start prior to the audit daemon, add the argumentto the default GRUB 2 command line for the Linux operating system in, so that the line looks similar toIn case theis set to true, then the parameter should be added to theinstead.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { dpkg-query --show --showformat='${db:Status-Status} ' 'grub2-common' 2&gt;/dev/null | grep -q installed; }; then # Correct the form of default kernel command line in GRUB if grep -q '^GRUB_CMDLINE_LINUX=.*audit=.*\"' '/etc/default/grub' ; then  # modify the GRUB command-line if an audit= arg already exists  sed -i 's/\\(^GRUB_CMDLINE_LINUX=\".*\\)audit=[^[:space:]]*\\(.*\"\\)/\\1 audit=1 \\2/' '/etc/default/grub' else  # no audit=arg is present, append it  sed -i 's/\\(^GRUB_CMDLINE_LINUX=\".*\\)\"/\\1 audit=1\"/' '/etc/default/grub' fi update-grub else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "System Accounting with auditd",
        "gid": "auditing",
        "rid": "grub2_audit_backlog_limit_argument",
        "fix_id": "grub2_audit_backlog_limit_argument"
      },
      "id": "auditing",
      "title": [
        {
          "#text": "Extend Audit Backlog Limit for the Audit Daemon",
          "@_lang": "en-US"
        }
      ],
      "desc": "To improve the kernel capacity to queue all log events, even those which occurred prior to the audit daemon, add the argumentto the default GRUB 2 command line for the Linux operating system in, in the manner below:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { dpkg-query --show --showformat='${db:Status-Status} ' 'grub2-common' 2&gt;/dev/null | grep -q installed; }; then # Correct the form of default kernel command line in GRUB if grep -q '^GRUB_CMDLINE_LINUX=.*audit_backlog_limit=.*\"' '/etc/default/grub' ; then  # modify the GRUB command-line if an audit_backlog_limit= arg already exists  sed -i 's/\\(^GRUB_CMDLINE_LINUX=\".*\\)audit_backlog_limit=[^[:space:]]*\\(.*\"\\)/\\1 audit_backlog_limit=8192 \\2/' '/etc/default/grub' else  # no audit_backlog_limit=arg is present, append it  sed -i 's/\\(^GRUB_CMDLINE_LINUX=\".*\\)\"/\\1 audit_backlog_limit=8192\"/' '/etc/default/grub' fi update-grub else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Configure Avahi if Necessary",
        "gid": "avahi_configuration",
        "rid": "avahi_disable_publishing"
      },
      "id": "avahi_configuration",
      "title": [
        {
          "#text": "Disable Avahi Publishing",
          "@_lang": "en-US"
        }
      ],
      "desc": "To prevent Avahi from publishing its records, editand ensure the following line appears in thesection:",
      "impact": 0.3,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Base Services",
        "gid": "base",
        "rid": "service_kdump_disabled",
        "fix_id": "service_kdump_disabled"
      },
      "id": "base",
      "title": [
        {
          "#text": "Disable KDump Kernel Crash Analyzer (kdump)",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice provides a kernel crash dump analyzer. It uses thesystem call to boot a secondary kernel (\"capture\" kernel) following a system crash, which can load information from the crashed kernel for analysis. Theservice can be disabled with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" stop 'kdump.service' \"$SYSTEMCTL_EXEC\" disable 'kdump.service' \"$SYSTEMCTL_EXEC\" mask 'kdump.service' # Disable socket activation if we have a unit file for it if \"$SYSTEMCTL_EXEC\" list-unit-files | grep -q '^kdump.socket'; then \"$SYSTEMCTL_EXEC\" stop 'kdump.socket' \"$SYSTEMCTL_EXEC\" mask 'kdump.socket' fi # The service may not be running because it has been started and failed, # so let's reset the state so OVAL checks pass. # Service should be 'inactive', not 'failed' after reboot though. \"$SYSTEMCTL_EXEC\" reset-failed 'kdump.service' || true else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "critical",
        "gtitle": "GRUB2 bootloader configuration",
        "gid": "bootloader-grub2",
        "rid": "grub2_enable_iommu_force",
        "fix_id": "grub2_enable_iommu_force"
      },
      "id": "bootloader-grub2",
      "title": [
        {
          "#text": "IOMMU configuration directive",
          "@_lang": "en-US"
        }
      ],
      "desc": "On x86 architecture supporting VT-d, the IOMMU manages the access control policy between the hardware devices and some of the system critical units such as the memory.",
      "impact": 1,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'grub2-common' 2&gt;/dev/null | grep -q installed &amp;&amp; { [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; }; then # Correct the form of default kernel command line in GRUB if grep -q '^GRUB_CMDLINE_LINUX=.*iommu=.*\"' '/etc/default/grub' ; then  # modify the GRUB command-line if an iommu= arg already exists  sed -i 's/\\(^GRUB_CMDLINE_LINUX=\".*\\)iommu=[^[:space:]]*\\(.*\"\\)/\\1 iommu=force \\2/' '/etc/default/grub' else  # no iommu=arg is present, append it  sed -i 's/\\(^GRUB_CMDLINE_LINUX=\".*\\)\"/\\1 iommu=force\"/' '/etc/default/grub' fi update-grub else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "zIPL bootloader configuration",
        "gid": "bootloader-zipl",
        "rid": "zipl_audit_argument"
      },
      "id": "bootloader-zipl",
      "title": [
        {
          "#text": "Enable Auditing to Start Prior to the Audit Daemon in zIPL",
          "@_lang": "en-US"
        }
      ],
      "desc": "To ensure all processes can be audited, even those which start prior to the audit daemon, check that all boot entries inhaveincluded in its options.To ensure that new kernels and boot entries continue to enable audit, addto.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "zIPL bootloader configuration",
        "gid": "bootloader-zipl",
        "rid": "zipl_audit_backlog_limit_argument"
      },
      "id": "bootloader-zipl",
      "title": [
        {
          "#text": "Extend Audit Backlog Limit for the Audit Daemon in zIPL",
          "@_lang": "en-US"
        }
      ],
      "desc": "To improve the kernel capacity to queue all log events, even those which start prior to the audit daemon, check that all boot entries inhaveincluded in its options.To ensure that new kernels and boot entries continue to extend the audit log events queue, addto.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gtitle": "Operating System Vendor Support and Certification",
        "gid": "certified-vendor",
        "rid": "installed_OS_is_FIPS_certified"
      },
      "id": "certified-vendor",
      "title": [
        {
          "#text": "The Installed Operating System Is FIPS 140-2 Certified",
          "@_lang": "en-US"
        }
      ],
      "desc": "To enable processing of sensitive information the operating system must provide certified cryptographic modules compliant with FIPS 140-2 standard. Ubuntu Linux is supported by Canonical Ltd. As the Ubuntu Linux Vendor, Canonical Ltd. is responsible for government certifications and standards. Users of Ubuntu Linux either need an Ubuntu Advantage subscription or need to be using Ubuntu Pro from a sponsored vendor in order to have access to FIPS content supported by Canonical.",
      "impact": 0.7,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Data Retention",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_audispd_configure_remote_server",
        "fix_id": "auditd_audispd_configure_remote_server"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Configure audispd Plugin To Send Logs To Remote Server",
          "@_lang": "en-US"
        }
      ],
      "desc": "Configure the audispd plugin to off-load audit records onto a different system or media from the system being audited. First, set theoption inSet theoption inwith an IP address or hostname of the system that the audispd plugin should send audit records to. For example",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then var_audispd_remote_server='' AUDITCONFIG=/etc/audisp/audisp-remote.conf AUREMOTECONFIG=/etc/audisp/plugins.d/au-remote.conf # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"$AUREMOTECONFIG\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^active\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"yes\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^active\\\\&gt;\" \"$AUREMOTECONFIG\"; then \"${sed_command[@]}\" \"s/^active\\\\&gt;.*/$formatted_output/gi\" \"$AUREMOTECONFIG\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"$AUREMOTECONFIG\" &gt;&gt; \"$AUREMOTECONFIG\" printf '%s ' \"$formatted_output\" &gt;&gt; \"$AUREMOTECONFIG\" fi # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"$AUDITCONFIG\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^remote_server\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_audispd_remote_server\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^remote_server\\\\&gt;\" \"$AUDITCONFIG\"; then \"${sed_command[@]}\" \"s/^remote_server\\\\&gt;.*/$formatted_output/gi\" \"$AUDITCONFIG\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"$AUDITCONFIG\" &gt;&gt; \"$AUDITCONFIG\" printf '%s ' \"$formatted_output\" &gt;&gt; \"$AUDITCONFIG\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Data Retention",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_audispd_configure_sufficiently_large_partition"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Configure a Sufficiently Large Partition for Audit Logs",
          "@_lang": "en-US"
        }
      ],
      "desc": "The Ubuntu 20.04 operating system must allocate audit record storage capacity to store at least one weeks worth of audit records when audit records are not immediately sent to a central audit record storage facility. The partition size needed to capture a week's worth of audit records is based on the activity level of the system and the total storage capacity available. In normal circumstances, 10.0 GB of storage space for audit records will be sufficient. Determine which partition the audit records are being written to with the following command:Check the size of the partition that audit records are written to with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Data Retention",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_audispd_syslog_plugin_activated",
        "fix_id": "auditd_audispd_syslog_plugin_activated"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Configure auditd to use audispd's syslog plugin",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure theservice to use theplug-in of theaudit event multiplexor, set theline into. Restart theservice:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then var_syslog_active=\"yes\" AUDISP_SYSLOGCONFIG=/etc/audisp/plugins.d/syslog.conf # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"$AUDISP_SYSLOGCONFIG\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^active\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_syslog_active\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^active\\\\&gt;\" \"$AUDISP_SYSLOGCONFIG\"; then \"${sed_command[@]}\" \"s/^active\\\\&gt;.*/$formatted_output/gi\" \"$AUDISP_SYSLOGCONFIG\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"$AUDISP_SYSLOGCONFIG\" &gt;&gt; \"$AUDISP_SYSLOGCONFIG\" printf '%s ' \"$formatted_output\" &gt;&gt; \"$AUDISP_SYSLOGCONFIG\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Data Retention",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_data_disk_error_action"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Configure auditd Disk Error Action on Disk Error",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice can be configured to take an action when there is a disk error. Edit the file. Add or modify the following line, substitutingappropriately:Set this value toto cause the system to switch to single-user mode for corrective action. Acceptable values also include,,, and. For certain systems, the need for availability outweighs the need to log all actions, and a different setting should be determined. Details regarding all possible values forare described in theman page.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Data Retention",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_data_disk_full_action",
        "fix_id": "auditd_data_disk_full_action"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Configure auditd Disk Full Action when Disk Space Is Full",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice can be configured to take an action when disk space is running low but prior to running out of space completely. Edit the file. Add or modify the following line, substitutingappropriately:Set this value toto cause the system to switch to single-user mode for corrective action. Acceptable values also include,,, and. For certain systems, the need for availability outweighs the need to log all actions, and a different setting should be determined. Details regarding all possible values forare described in theman page.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then var_auditd_disk_full_action='' # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/audit/auditd.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^disk_full_action\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_auditd_disk_full_action\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^disk_full_action\\\\&gt;\" \"/etc/audit/auditd.conf\"; then \"${sed_command[@]}\" \"s/^disk_full_action\\\\&gt;.*/$formatted_output/gi\" \"/etc/audit/auditd.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/audit/auditd.conf\" &gt;&gt; \"/etc/audit/auditd.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/audit/auditd.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Data Retention",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_data_retention_action_mail_acct",
        "fix_id": "auditd_data_retention_action_mail_acct"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Configure auditd mail_acct Action on Low Disk Space",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice can be configured to send email to a designated account in certain situations. Add or correct the following line into ensure that administrators are notified via email for those situations:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then var_auditd_action_mail_acct='' AUDITCONFIG=/etc/audit/auditd.conf # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"$AUDITCONFIG\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^action_mail_acct\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_auditd_action_mail_acct\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^action_mail_acct\\\\&gt;\" \"$AUDITCONFIG\"; then \"${sed_command[@]}\" \"s/^action_mail_acct\\\\&gt;.*/$formatted_output/gi\" \"$AUDITCONFIG\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"$AUDITCONFIG\" &gt;&gt; \"$AUDITCONFIG\" printf '%s ' \"$formatted_output\" &gt;&gt; \"$AUDITCONFIG\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Data Retention",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_data_retention_admin_space_left_action",
        "fix_id": "auditd_data_retention_admin_space_left_action"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Configure auditd admin_space_left Action on Low Disk Space",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice can be configured to take an action when disk space is running low but prior to running out of space completely. Edit the file. Add or modify the following line, substitutingappropriately:Set this value toto cause the system to switch to single user mode for corrective action. Acceptable values also includeand. For certain systems, the need for availability outweighs the need to log all actions, and a different setting should be determined. Details regarding all possible values forare described in theman page.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then var_auditd_admin_space_left_action='' AUDITCONFIG=/etc/audit/auditd.conf # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"$AUDITCONFIG\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^admin_space_left_action\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_auditd_admin_space_left_action\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^admin_space_left_action\\\\&gt;\" \"$AUDITCONFIG\"; then \"${sed_command[@]}\" \"s/^admin_space_left_action\\\\&gt;.*/$formatted_output/gi\" \"$AUDITCONFIG\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"$AUDITCONFIG\" &gt;&gt; \"$AUDITCONFIG\" printf '%s ' \"$formatted_output\" &gt;&gt; \"$AUDITCONFIG\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Data Retention",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_data_retention_max_log_file",
        "fix_id": "auditd_data_retention_max_log_file"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Configure auditd Max Log File Size",
          "@_lang": "en-US"
        }
      ],
      "desc": "Determine the amount of audit data (in megabytes) which should be retained in each log file. Edit the file. Add or modify the following line, substituting the correct value offor:Set the value to(MB) or higher for general-purpose systems. Larger values, of course, support retention of even more audit data.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then var_auditd_max_log_file='' AUDITCONFIG=/etc/audit/auditd.conf # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"$AUDITCONFIG\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^max_log_file\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_auditd_max_log_file\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^max_log_file\\\\&gt;\" \"$AUDITCONFIG\"; then \"${sed_command[@]}\" \"s/^max_log_file\\\\&gt;.*/$formatted_output/gi\" \"$AUDITCONFIG\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"$AUDITCONFIG\" &gt;&gt; \"$AUDITCONFIG\" printf '%s ' \"$formatted_output\" &gt;&gt; \"$AUDITCONFIG\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Data Retention",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_data_retention_max_log_file_action",
        "fix_id": "auditd_data_retention_max_log_file_action"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Configure auditd max_log_file_action Upon Reaching Maximum Log Size",
          "@_lang": "en-US"
        }
      ],
      "desc": "The default action to take when the logs reach their maximum size is to rotate the log files, discarding the oldest one. To configure the action taken by, add or correct the line in:Possible values forare described in theman page. These include:Set thetoto ensure log rotation occurs. This is the default. The setting is case-insensitive.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then var_auditd_max_log_file_action='' AUDITCONFIG=/etc/audit/auditd.conf # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"$AUDITCONFIG\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^max_log_file_action\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_auditd_max_log_file_action\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^max_log_file_action\\\\&gt;\" \"$AUDITCONFIG\"; then \"${sed_command[@]}\" \"s/^max_log_file_action\\\\&gt;.*/$formatted_output/gi\" \"$AUDITCONFIG\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"$AUDITCONFIG\" &gt;&gt; \"$AUDITCONFIG\" printf '%s ' \"$formatted_output\" &gt;&gt; \"$AUDITCONFIG\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Data Retention",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_data_retention_num_logs",
        "fix_id": "auditd_data_retention_num_logs"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Configure auditd Number of Logs Retained",
          "@_lang": "en-US"
        }
      ],
      "desc": "Determine how many log filesshould retain when it rotates logs. Edit the file. Add or modify the following line, substitutingwith the correct value of:Set the value to 5 for general-purpose systems. Note that values less than 2 result in no log rotation.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then var_auditd_num_logs='' AUDITCONFIG=/etc/audit/auditd.conf # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"$AUDITCONFIG\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^num_logs\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_auditd_num_logs\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^num_logs\\\\&gt;\" \"$AUDITCONFIG\"; then \"${sed_command[@]}\" \"s/^num_logs\\\\&gt;.*/$formatted_output/gi\" \"$AUDITCONFIG\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"$AUDITCONFIG\" &gt;&gt; \"$AUDITCONFIG\" printf '%s ' \"$formatted_output\" &gt;&gt; \"$AUDITCONFIG\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Data Retention",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_data_retention_space_left",
        "fix_id": "auditd_data_retention_space_left"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Configure auditd space_left on Low Disk Space",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice can be configured to take an action when disk space is running low but prior to running out of space completely. Edit the file. Add or modify the following line, substitutingappropriately:Set this value to the appropriate size in Megabytes cause the system to notify the user of an issue.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then var_auditd_space_left='' grep -q \"^space_left[[:space:]]*=.*$\" /etc/audit/auditd.conf &amp;&amp; \\ sed -i \"s/^space_left[[:space:]]*=.*$/space_left = $var_auditd_space_left/g\" /etc/audit/auditd.conf || \\ echo \"space_left = $var_auditd_space_left\" &gt;&gt; /etc/audit/auditd.conf else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Data Retention",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_data_retention_space_left_action",
        "fix_id": "auditd_data_retention_space_left_action"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Configure auditd space_left Action on Low Disk Space",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice can be configured to take an action when disk spaceto run low. Edit the file. Modify the following line, substitutingappropriately:Possible values forare described in theman page. These include:Set this to(instead of the default, which is) as it is more likely to get prompt attention. Acceptable values also include,, and.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then var_auditd_space_left_action='' # # If space_left_action present in /etc/audit/auditd.conf, change value # to var_auditd_space_left_action, else # add \"space_left_action = $var_auditd_space_left_action\" to /etc/audit/auditd.conf # AUDITCONFIG=/etc/audit/auditd.conf # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"$AUDITCONFIG\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^space_left_action\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_auditd_space_left_action\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^space_left_action\\\\&gt;\" \"$AUDITCONFIG\"; then \"${sed_command[@]}\" \"s/^space_left_action\\\\&gt;.*/$formatted_output/gi\" \"$AUDITCONFIG\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"$AUDITCONFIG\" &gt;&gt; \"$AUDITCONFIG\" printf '%s ' \"$formatted_output\" &gt;&gt; \"$AUDITCONFIG\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Data Retention",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_freq",
        "fix_id": "auditd_freq"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Set number of records to cause an explicit flush to audit logs",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure Audit daemon to issue an explicit flush to disk command after writing 50 records, settoin.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/audit/auditd.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*freq\\s*=\\s*/Id\" \"/etc/audit/auditd.conf\" else touch \"/etc/audit/auditd.conf\" fi cp \"/etc/audit/auditd.conf\" \"/etc/audit/auditd.conf.bak\" # Insert at the end of the file printf '%s ' \"freq = 50\" &gt;&gt; \"/etc/audit/auditd.conf\" # Clean up after ourselves. rm \"/etc/audit/auditd.conf.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Data Retention",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_local_events",
        "fix_id": "auditd_local_events"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Include Local Events in Audit Logs",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure Audit daemon to include local events in Audit logs, settoin. This is the default setting.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/audit/auditd.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*local_events\\s*=\\s*/Id\" \"/etc/audit/auditd.conf\" else touch \"/etc/audit/auditd.conf\" fi cp \"/etc/audit/auditd.conf\" \"/etc/audit/auditd.conf.bak\" # Insert at the end of the file printf '%s ' \"local_events = yes\" &gt;&gt; \"/etc/audit/auditd.conf\" # Clean up after ourselves. rm \"/etc/audit/auditd.conf.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Data Retention",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_log_format",
        "fix_id": "auditd_log_format"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Resolve information before writing to audit logs",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure Audit daemon to resolve all uid, gid, syscall, architecture, and socket address information before writing the events to disk, settoin.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/audit/auditd.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*log_format\\s*=\\s*/Id\" \"/etc/audit/auditd.conf\" else touch \"/etc/audit/auditd.conf\" fi cp \"/etc/audit/auditd.conf\" \"/etc/audit/auditd.conf.bak\" # Insert at the end of the file printf '%s ' \"log_format = ENRICHED\" &gt;&gt; \"/etc/audit/auditd.conf\" # Clean up after ourselves. rm \"/etc/audit/auditd.conf.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Data Retention",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_name_format",
        "fix_id": "auditd_name_format"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Set hostname as computer node name in audit logs",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure Audit daemon to use value returned by gethostname syscall as computer node name in the audit events, settoin.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/audit/auditd.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*name_format\\s*=\\s*/Id\" \"/etc/audit/auditd.conf\" else touch \"/etc/audit/auditd.conf\" fi cp \"/etc/audit/auditd.conf\" \"/etc/audit/auditd.conf.bak\" # Insert at the end of the file printf '%s ' \"name_format = hostname\" &gt;&gt; \"/etc/audit/auditd.conf\" # Clean up after ourselves. rm \"/etc/audit/auditd.conf.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Data Retention",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_offload_logs"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Offload audit Logs to External Media",
          "@_lang": "en-US"
        }
      ],
      "desc": "The operating system must have a crontab script running weekly to offload audit events of standalone systems.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Data Retention",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_overflow_action"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Appropriate Action Must be Setup When the Internal Audit Event Queue is Full",
          "@_lang": "en-US"
        }
      ],
      "desc": "The audit system should have an action setup in the event the internal event queue becomes full. To setup an overflow action edit. Setto one of the following values:,,.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure auditd Data Retention",
        "gid": "configure_auditd_data_retention",
        "rid": "auditd_write_logs",
        "fix_id": "auditd_write_logs"
      },
      "id": "configure_auditd_data_retention",
      "title": [
        {
          "#text": "Write Audit Logs to the Disk",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure Audit daemon to write Audit logs to the disk, settoin. This is the default setting.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/audit/auditd.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*write_logs\\s*=\\s*/Id\" \"/etc/audit/auditd.conf\" else touch \"/etc/audit/auditd.conf\" fi cp \"/etc/audit/auditd.conf\" \"/etc/audit/auditd.conf.bak\" # Insert at the end of the file printf '%s ' \"write_logs = yes\" &gt;&gt; \"/etc/audit/auditd.conf\" # Clean up after ourselves. rm \"/etc/audit/auditd.conf.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure IPv6 Settings if Necessary",
        "gid": "configuring_ipv6",
        "rid": "sysctl_net_ipv6_conf_all_accept_ra",
        "fix_id": "sysctl_net_ipv6_conf_all_accept_ra"
      },
      "id": "configuring_ipv6",
      "title": [
        {
          "#text": "Configure Accepting Router Advertisements on All IPv6 Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv6_conf_all_accept_ra_value='' # # Set runtime for net.ipv6.conf.all.accept_ra # /sbin/sysctl -q -n -w net.ipv6.conf.all.accept_ra=\"$sysctl_net_ipv6_conf_all_accept_ra_value\" # # If net.ipv6.conf.all.accept_ra present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv6.conf.all.accept_ra = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv6.conf.all.accept_ra\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv6_conf_all_accept_ra_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv6.conf.all.accept_ra\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv6.conf.all.accept_ra\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure IPv6 Settings if Necessary",
        "gid": "configuring_ipv6",
        "rid": "sysctl_net_ipv6_conf_all_accept_redirects",
        "fix_id": "sysctl_net_ipv6_conf_all_accept_redirects"
      },
      "id": "configuring_ipv6",
      "title": [
        {
          "#text": "Disable Accepting ICMP Redirects for All IPv6 Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv6_conf_all_accept_redirects_value='' # # Set runtime for net.ipv6.conf.all.accept_redirects # /sbin/sysctl -q -n -w net.ipv6.conf.all.accept_redirects=\"$sysctl_net_ipv6_conf_all_accept_redirects_value\" # # If net.ipv6.conf.all.accept_redirects present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv6.conf.all.accept_redirects = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv6.conf.all.accept_redirects\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv6_conf_all_accept_redirects_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv6.conf.all.accept_redirects\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv6.conf.all.accept_redirects\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure IPv6 Settings if Necessary",
        "gid": "configuring_ipv6",
        "rid": "sysctl_net_ipv6_conf_all_accept_source_route",
        "fix_id": "sysctl_net_ipv6_conf_all_accept_source_route"
      },
      "id": "configuring_ipv6",
      "title": [
        {
          "#text": "Disable Kernel Parameter for Accepting Source-Routed Packets on all IPv6 Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv6_conf_all_accept_source_route_value='' # # Set runtime for net.ipv6.conf.all.accept_source_route # /sbin/sysctl -q -n -w net.ipv6.conf.all.accept_source_route=\"$sysctl_net_ipv6_conf_all_accept_source_route_value\" # # If net.ipv6.conf.all.accept_source_route present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv6.conf.all.accept_source_route = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv6.conf.all.accept_source_route\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv6_conf_all_accept_source_route_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv6.conf.all.accept_source_route\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv6.conf.all.accept_source_route\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure IPv6 Settings if Necessary",
        "gid": "configuring_ipv6",
        "rid": "sysctl_net_ipv6_conf_all_forwarding",
        "fix_id": "sysctl_net_ipv6_conf_all_forwarding"
      },
      "id": "configuring_ipv6",
      "title": [
        {
          "#text": "Disable Kernel Parameter for IPv6 Forwarding",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv6_conf_all_forwarding_value='' # # Set runtime for net.ipv6.conf.all.forwarding # /sbin/sysctl -q -n -w net.ipv6.conf.all.forwarding=\"$sysctl_net_ipv6_conf_all_forwarding_value\" # # If net.ipv6.conf.all.forwarding present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv6.conf.all.forwarding = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv6.conf.all.forwarding\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv6_conf_all_forwarding_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv6.conf.all.forwarding\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv6.conf.all.forwarding\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure IPv6 Settings if Necessary",
        "gid": "configuring_ipv6",
        "rid": "sysctl_net_ipv6_conf_default_accept_ra",
        "fix_id": "sysctl_net_ipv6_conf_default_accept_ra"
      },
      "id": "configuring_ipv6",
      "title": [
        {
          "#text": "Disable Accepting Router Advertisements on all IPv6 Interfaces by Default",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv6_conf_default_accept_ra_value='' # # Set runtime for net.ipv6.conf.default.accept_ra # /sbin/sysctl -q -n -w net.ipv6.conf.default.accept_ra=\"$sysctl_net_ipv6_conf_default_accept_ra_value\" # # If net.ipv6.conf.default.accept_ra present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv6.conf.default.accept_ra = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv6.conf.default.accept_ra\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv6_conf_default_accept_ra_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv6.conf.default.accept_ra\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv6.conf.default.accept_ra\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure IPv6 Settings if Necessary",
        "gid": "configuring_ipv6",
        "rid": "sysctl_net_ipv6_conf_default_accept_redirects",
        "fix_id": "sysctl_net_ipv6_conf_default_accept_redirects"
      },
      "id": "configuring_ipv6",
      "title": [
        {
          "#text": "Disable Kernel Parameter for Accepting ICMP Redirects by Default on IPv6 Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv6_conf_default_accept_redirects_value='' # # Set runtime for net.ipv6.conf.default.accept_redirects # /sbin/sysctl -q -n -w net.ipv6.conf.default.accept_redirects=\"$sysctl_net_ipv6_conf_default_accept_redirects_value\" # # If net.ipv6.conf.default.accept_redirects present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv6.conf.default.accept_redirects = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv6.conf.default.accept_redirects\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv6_conf_default_accept_redirects_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv6.conf.default.accept_redirects\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv6.conf.default.accept_redirects\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure IPv6 Settings if Necessary",
        "gid": "configuring_ipv6",
        "rid": "sysctl_net_ipv6_conf_default_accept_source_route",
        "fix_id": "sysctl_net_ipv6_conf_default_accept_source_route"
      },
      "id": "configuring_ipv6",
      "title": [
        {
          "#text": "Disable Kernel Parameter for Accepting Source-Routed Packets on IPv6 Interfaces by Default",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv6_conf_default_accept_source_route_value='' # # Set runtime for net.ipv6.conf.default.accept_source_route # /sbin/sysctl -q -n -w net.ipv6.conf.default.accept_source_route=\"$sysctl_net_ipv6_conf_default_accept_source_route_value\" # # If net.ipv6.conf.default.accept_source_route present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv6.conf.default.accept_source_route = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv6.conf.default.accept_source_route\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv6_conf_default_accept_source_route_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv6.conf.default.accept_source_route\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv6.conf.default.accept_source_route\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure Console Screen Locking",
        "gid": "console_screen_locking",
        "rid": "vlock_installed",
        "fix_id": "vlock_installed"
      },
      "id": "console_screen_locking",
      "title": [
        {
          "#text": "Check that vlock is installed to allow session locking",
          "@_lang": "en-US"
        }
      ],
      "desc": "The Ubuntu 20.04 operating system must have vlock installed to allow for session locking. Thepackage can be installed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "DEBIAN_FRONTEND=noninteractive apt-get install -y \"vlock\""
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Disable Core Dumps",
        "gid": "coredumps",
        "rid": "coredump_disable_backtraces",
        "fix_id": "coredump_disable_backtraces"
      },
      "id": "coredumps",
      "title": [
        {
          "#text": "Disable core dump backtraces",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theoption insection ofspecifies the maximum size in bytes of a core which will be processed. Core dumps exceeding this size may be stored, but the backtrace will not be generated.",
      "impact": 0.5,
      "descs": {
        "fix": "if [ -e \"/etc/systemd/coredump.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*ProcessSizeMax\\s*=\\s*/Id\" \"/etc/systemd/coredump.conf\" else touch \"/etc/systemd/coredump.conf\" fi cp \"/etc/systemd/coredump.conf\" \"/etc/systemd/coredump.conf.bak\" # Insert at the end of the file printf '%s ' \"ProcessSizeMax=0\" &gt;&gt; \"/etc/systemd/coredump.conf\" # Clean up after ourselves. rm \"/etc/systemd/coredump.conf.bak\""
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Disable Core Dumps",
        "gid": "coredumps",
        "rid": "coredump_disable_storage",
        "fix_id": "coredump_disable_storage"
      },
      "id": "coredumps",
      "title": [
        {
          "#text": "Disable storing core dump",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theoption insection ofcan be set toto disable storing core dumps permanently.",
      "impact": 0.5,
      "descs": {
        "fix": "if [ -e \"/etc/systemd/coredump.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*Storage\\s*=\\s*/Id\" \"/etc/systemd/coredump.conf\" else touch \"/etc/systemd/coredump.conf\" fi cp \"/etc/systemd/coredump.conf\" \"/etc/systemd/coredump.conf.bak\" # Insert at the end of the file printf '%s ' \"Storage=none\" &gt;&gt; \"/etc/systemd/coredump.conf\" # Clean up after ourselves. rm \"/etc/systemd/coredump.conf.bak\""
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Disable Core Dumps",
        "gid": "coredumps",
        "rid": "disable_users_coredumps",
        "fix_id": "disable_users_coredumps"
      },
      "id": "coredumps",
      "title": [
        {
          "#text": "Disable Core Dumps for All Users",
          "@_lang": "en-US"
        }
      ],
      "desc": "To disable core dumps for all users, add the following line to, or to a file within thedirectory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'libpam-runtime' 2&gt;/dev/null | grep -q installed; then SECURITY_LIMITS_FILE=\"/etc/security/limits.conf\" if grep -qE '\\*\\s+hard\\s+core' $SECURITY_LIMITS_FILE; then sed -ri 's/(hard\\s+core\\s+)[[:digit:]]+/\\1 0/' $SECURITY_LIMITS_FILE else echo \"* hard core 0\" &gt;&gt; $SECURITY_LIMITS_FILE fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Disable Core Dumps",
        "gid": "coredumps",
        "rid": "sysctl_fs_suid_dumpable",
        "fix_id": "sysctl_fs_suid_dumpable"
      },
      "id": "coredumps",
      "title": [
        {
          "#text": "Disable Core Dumps for SUID programs",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # # Set runtime for fs.suid_dumpable # /sbin/sysctl -q -n -w fs.suid_dumpable=\"0\" # # If fs.suid_dumpable present in /etc/sysctl.conf, change value to \"0\" # else, add \"fs.suid_dumpable = 0\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^fs.suid_dumpable\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"0\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^fs.suid_dumpable\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^fs.suid_dumpable\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Cron and At Daemons",
        "gid": "cron_and_at",
        "rid": "package_cron_installed",
        "fix_id": "package_cron_installed"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Install the cron service",
          "@_lang": "en-US"
        }
      ],
      "desc": "The Cron service should be installed.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"cron\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Cron and At Daemons",
        "gid": "cron_and_at",
        "rid": "service_cron_enabled",
        "fix_id": "service_cron_enabled"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Enable cron Service",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice is used to execute commands at preconfigured times. It is required by almost all systems to perform necessary maintenance tasks, such as notifying root of system activity. Theservice can be enabled with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" unmask 'cron.service' \"$SYSTEMCTL_EXEC\" start 'cron.service' \"$SYSTEMCTL_EXEC\" enable 'cron.service' else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Cron and At Daemons",
        "gid": "cron_and_at",
        "rid": "file_groupowner_cron_d",
        "fix_id": "file_groupowner_cron_d"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Group Who Owns cron.d",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chgrp 0 /etc/cron.d/ else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Cron and At Daemons",
        "gid": "cron_and_at",
        "rid": "file_groupowner_cron_daily",
        "fix_id": "file_groupowner_cron_daily"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Group Who Owns cron.daily",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chgrp 0 /etc/cron.daily/ else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Cron and At Daemons",
        "gid": "cron_and_at",
        "rid": "file_groupowner_cron_hourly",
        "fix_id": "file_groupowner_cron_hourly"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Group Who Owns cron.hourly",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chgrp 0 /etc/cron.hourly/ else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Cron and At Daemons",
        "gid": "cron_and_at",
        "rid": "file_groupowner_cron_monthly",
        "fix_id": "file_groupowner_cron_monthly"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Group Who Owns cron.monthly",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chgrp 0 /etc/cron.monthly/ else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Cron and At Daemons",
        "gid": "cron_and_at",
        "rid": "file_groupowner_cron_weekly",
        "fix_id": "file_groupowner_cron_weekly"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Group Who Owns cron.weekly",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chgrp 0 /etc/cron.weekly/ else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Cron and At Daemons",
        "gid": "cron_and_at",
        "rid": "file_groupowner_crontab",
        "fix_id": "file_groupowner_crontab"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Group Who Owns Crontab",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chgrp 0 /etc/crontab else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Cron and At Daemons",
        "gid": "cron_and_at",
        "rid": "file_owner_cron_d",
        "fix_id": "file_owner_cron_d"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Owner on cron.d",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chown 0 /etc/cron.d/ else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Cron and At Daemons",
        "gid": "cron_and_at",
        "rid": "file_owner_cron_daily",
        "fix_id": "file_owner_cron_daily"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Owner on cron.daily",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chown 0 /etc/cron.daily/ else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Cron and At Daemons",
        "gid": "cron_and_at",
        "rid": "file_owner_cron_hourly",
        "fix_id": "file_owner_cron_hourly"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Owner on cron.hourly",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chown 0 /etc/cron.hourly/ else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Cron and At Daemons",
        "gid": "cron_and_at",
        "rid": "file_owner_cron_monthly",
        "fix_id": "file_owner_cron_monthly"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Owner on cron.monthly",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chown 0 /etc/cron.monthly/ else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Cron and At Daemons",
        "gid": "cron_and_at",
        "rid": "file_owner_cron_weekly",
        "fix_id": "file_owner_cron_weekly"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Owner on cron.weekly",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chown 0 /etc/cron.weekly/ else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Cron and At Daemons",
        "gid": "cron_and_at",
        "rid": "file_owner_crontab",
        "fix_id": "file_owner_crontab"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Owner on crontab",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chown 0 /etc/crontab else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Cron and At Daemons",
        "gid": "cron_and_at",
        "rid": "file_permissions_cron_d",
        "fix_id": "file_permissions_cron_d"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Permissions on cron.d",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chmod 0700 /etc/cron.d/ else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Cron and At Daemons",
        "gid": "cron_and_at",
        "rid": "file_permissions_cron_daily",
        "fix_id": "file_permissions_cron_daily"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Permissions on cron.daily",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chmod 0700 /etc/cron.daily/ else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Cron and At Daemons",
        "gid": "cron_and_at",
        "rid": "file_permissions_cron_hourly",
        "fix_id": "file_permissions_cron_hourly"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Permissions on cron.hourly",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chmod 0700 /etc/cron.hourly/ else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Cron and At Daemons",
        "gid": "cron_and_at",
        "rid": "file_permissions_cron_monthly",
        "fix_id": "file_permissions_cron_monthly"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Permissions on cron.monthly",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chmod 0700 /etc/cron.monthly/ else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Cron and At Daemons",
        "gid": "cron_and_at",
        "rid": "file_permissions_cron_weekly",
        "fix_id": "file_permissions_cron_weekly"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Permissions on cron.weekly",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chmod 0700 /etc/cron.weekly/ else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Cron and At Daemons",
        "gid": "cron_and_at",
        "rid": "file_permissions_crontab",
        "fix_id": "file_permissions_crontab"
      },
      "id": "cron_and_at",
      "title": [
        {
          "#text": "Verify Permissions on crontab",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chmod 0600 /etc/crontab else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gtitle": "System Cryptographic Policies",
        "gid": "crypto",
        "rid": "configure_crypto_policy",
        "fix_id": "configure_crypto_policy"
      },
      "id": "crypto",
      "title": [
        {
          "#text": "Configure System Cryptography Policy",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure the system cryptography policy to use ciphers only from thepolicy, run the following command:The rule checks if settings for selected crypto policy are configured as expected. Configuration files in theare either symlinks to correct files provided by Crypto-policies package or they are regular files in case crypto policy customizations are applied. Crypto policies may be customized by crypto policy modules, in which case it is delimited from the base policy using a colon.",
      "impact": 0.7,
      "descs": {
        "fix": "# include remediation functions library var_system_crypto_policy='' stderr_of_call=$(update-crypto-policies --set ${var_system_crypto_policy} 2&gt;&amp;1 &gt; /dev/null) rc=$? if test \"$rc\" = 127; then  echo \"$stderr_of_call\" &gt;&amp;2  echo \"Make sure that the script is installed on the remediated system.\" &gt;&amp;2  echo \"See output of the 'dnf provides update-crypto-policies' command\" &gt;&amp;2  echo \"to see what package to (re)install\" &gt;&amp;2  false # end with an error code elif test \"$rc\" != 0; then  echo \"Error invoking the update-crypto-policies script: $stderr_of_call\" &gt;&amp;2  false # end with an error code fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "System Cryptographic Policies",
        "gid": "crypto",
        "rid": "harden_ssh_client_crypto_policy",
        "fix_id": "harden_ssh_client_crypto_policy"
      },
      "id": "crypto",
      "title": [
        {
          "#text": "Harden SSH client Crypto Policy",
          "@_lang": "en-US"
        }
      ],
      "desc": "Crypto Policies are means of enforcing certain cryptographic settings for selected applications including OpenSSH client. To override the system wide crypto policy for Openssh client, place a file in theso that it is loaded before the. In this case it is file namedcontaining parameters which need to be changed with respect to the crypto policy. This rule checks if the file exists and if it contains required parameters and values which modify the Crypto Policy. During the parsing process, as soon as Openssh client parses some configuration option and its value, it remembers it and ignores any subsequent overrides. The customization mechanism provided by crypto policies appends eventual customizations at the end of the system wide crypto policy. Therefore, if the crypto policy customization overrides some parameter which is already configured in the system wide crypto policy, the SSH client will not honor that customized parameter.",
      "impact": 0.5,
      "descs": {
        "fix": "#the file starts with 02 so that it is loaded before the 05-redhat.conf which activates configuration provided by system vide crypto policy file=\"/etc/ssh/ssh_config.d/02-ospp.conf\" echo -e \"Match final all \\ RekeyLimit 512M 1h \\ GSSAPIAuthentication no \\ Ciphers aes256-ctr,aes256-cbc,aes128-ctr,aes128-cbc \\ PubkeyAcceptedKeyTypes ssh-rsa,ecdsa-sha2-nistp384,ecdsa-sha2-nistp256 \\ MACs hmac-sha2-512,hmac-sha2-256 \\ KexAlgorithms ecdh-sha2-nistp521,ecdh-sha2-nistp384,ecdh-sha2-nistp256,diffie-hellman-group14-sha1 \" &gt; \"$file\""
      }
    },
    {
      "tags": {
        "severity": "high",
        "gtitle": "Deprecated services",
        "gid": "deprecated",
        "rid": "package_inetutils-telnetd_removed",
        "fix_id": "package_inetutils-telnetd_removed"
      },
      "id": "deprecated",
      "title": [
        {
          "#text": "Uninstall the inet-based telnet server",
          "@_lang": "en-US"
        }
      ],
      "desc": "The inet-based telnet daemon should be uninstalled.",
      "impact": 0.7,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove inetutils-telnetd #  from the system, and may remove any packages #  that depend on inetutils-telnetd. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"inetutils-telnetd\""
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Deprecated services",
        "gid": "deprecated",
        "rid": "package_nis_removed",
        "fix_id": "package_nis_removed"
      },
      "id": "deprecated",
      "title": [
        {
          "#text": "Uninstall the nis package",
          "@_lang": "en-US"
        }
      ],
      "desc": "The support for Yellowpages should not be installed unless it is required.",
      "impact": 0.3,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove nis #  from the system, and may remove any packages #  that depend on nis. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"nis\""
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Deprecated services",
        "gid": "deprecated",
        "rid": "package_ntpdate_removed",
        "fix_id": "package_ntpdate_removed"
      },
      "id": "deprecated",
      "title": [
        {
          "#text": "Uninstall the ntpdate package",
          "@_lang": "en-US"
        }
      ],
      "desc": "ntpdate is a historical ntp synchronization client for unixes. It sould be uninstalled.",
      "impact": 0.3,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove ntpdate #  from the system, and may remove any packages #  that depend on ntpdate. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"ntpdate\""
      }
    },
    {
      "tags": {
        "severity": "high",
        "gtitle": "Deprecated services",
        "gid": "deprecated",
        "rid": "package_telnetd-ssl_removed",
        "fix_id": "package_telnetd-ssl_removed"
      },
      "id": "deprecated",
      "title": [
        {
          "#text": "Uninstall the ssl compliant telnet server",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thedaemon, even with ssl support, should be uninstalled.",
      "impact": 0.7,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove telnetd-ssl #  from the system, and may remove any packages #  that depend on telnetd-ssl. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"telnetd-ssl\""
      }
    },
    {
      "tags": {
        "severity": "high",
        "gtitle": "Deprecated services",
        "gid": "deprecated",
        "rid": "package_telnetd_removed",
        "fix_id": "package_telnetd_removed"
      },
      "id": "deprecated",
      "title": [
        {
          "#text": "Uninstall the telnet server",
          "@_lang": "en-US"
        }
      ],
      "desc": "The telnet daemon should be uninstalled.",
      "impact": 0.7,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove telnetd #  from the system, and may remove any packages #  that depend on telnetd. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"telnetd\""
      }
    },
    {
      "tags": {
        "severity": "critical",
        "gtitle": "Configure DHCP Client if Necessary",
        "gid": "dhcp_client_configuration",
        "rid": "dhcp_client_restrict_options"
      },
      "id": "dhcp_client_configuration",
      "title": [
        {
          "#text": "Minimize the DHCP-Configured Options",
          "@_lang": "en-US"
        }
      ],
      "desc": "Create the file, and add an appropriate setting for each of the ten configuration settings which can be obtained via DHCP. For each setting, do one of the following:If the setting shouldbe configured remotely by the DHCP server, select an appropriate static value, and add the line:If the setting should be configured remotely by the DHCP server, add the lines:For example, suppose the DHCP server should provide only the IP address itself and the subnet mask. Then the entire file should look like:",
      "impact": 1,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "critical",
        "gtitle": "Configure DHCP Server",
        "gid": "dhcp_server_configuration",
        "rid": "dhcp_server_minimize_served_info"
      },
      "id": "dhcp_server_configuration",
      "title": [
        {
          "#text": "Minimize Served Information",
          "@_lang": "en-US"
        }
      ],
      "desc": "Edit /etc/dhcp/dhcpd.conf. Examine each address range section within the file, and ensure that the following options are not defined unless there is an operational need to provide this information via DHCP:",
      "impact": 1,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Disable Avahi Server if Possible",
        "gid": "disable_avahi_group",
        "rid": "package_avahi-daemon_removed",
        "fix_id": "package_avahi-daemon_removed"
      },
      "id": "disable_avahi_group",
      "title": [
        {
          "#text": "Uninstall avahi-daemon Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be removed with the following command:",
      "impact": 0.3,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove avahi-daemon #  from the system, and may remove any packages #  that depend on avahi-daemon. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"avahi-daemon\""
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Disable Avahi Server if Possible",
        "gid": "disable_avahi_group",
        "rid": "service_avahi-daemon_disabled",
        "fix_id": "service_avahi-daemon_disabled"
      },
      "id": "disable_avahi_group",
      "title": [
        {
          "#text": "Disable Avahi Server Software",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice can be disabled with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" stop 'avahi-daemon.service' \"$SYSTEMCTL_EXEC\" disable 'avahi-daemon.service' \"$SYSTEMCTL_EXEC\" mask 'avahi-daemon.service' # Disable socket activation if we have a unit file for it if \"$SYSTEMCTL_EXEC\" list-unit-files | grep -q '^avahi-daemon.socket'; then \"$SYSTEMCTL_EXEC\" stop 'avahi-daemon.socket' \"$SYSTEMCTL_EXEC\" mask 'avahi-daemon.socket' fi # The service may not be running because it has been started and failed, # so let's reset the state so OVAL checks pass. # Service should be 'inactive', not 'failed' after reboot though. \"$SYSTEMCTL_EXEC\" reset-failed 'avahi-daemon.service' || true else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Disable DHCP Server",
        "gid": "disabling_dhcp_server",
        "rid": "package_dhcp_removed",
        "fix_id": "package_dhcp_removed"
      },
      "id": "disabling_dhcp_server",
      "title": [
        {
          "#text": "Uninstall DHCP Server Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "If the system does not need to act as a DHCP server, the dhcp package can be uninstalled. Thepackage can be removed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove isc-dhcp-server #  from the system, and may remove any packages #  that depend on isc-dhcp-server. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"isc-dhcp-server\""
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Disable DNS Server",
        "gid": "disabling_dns_server",
        "rid": "package_bind_removed",
        "fix_id": "package_bind_removed"
      },
      "id": "disabling_dns_server",
      "title": [
        {
          "#text": "Uninstall bind Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice is provided by thepackage. Thepackage can be removed with the following command:",
      "impact": 0.3,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove bind9 #  from the system, and may remove any packages #  that depend on bind9. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"bind9\""
      }
    },
    {
      "tags": {
        "severity": "critical",
        "gtitle": "Disable Dovecot",
        "gid": "disabling_dovecot",
        "rid": "package_dovecot_removed",
        "fix_id": "package_dovecot_removed"
      },
      "id": "disabling_dovecot",
      "title": [
        {
          "#text": "Uninstall dovecot Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be removed with the following command:",
      "impact": 1,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove dovecot-core #  from the system, and may remove any packages #  that depend on dovecot-core. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"dovecot-core\""
      }
    },
    {
      "tags": {
        "severity": "critical",
        "gtitle": "Disable Apache if Possible",
        "gid": "disabling_httpd",
        "rid": "package_httpd_removed",
        "fix_id": "package_httpd_removed"
      },
      "id": "disabling_httpd",
      "title": [
        {
          "#text": "Uninstall httpd Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be removed with the following command:",
      "impact": 1,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove apache2 #  from the system, and may remove any packages #  that depend on apache2. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"apache2\""
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Disable Support for IPv6 Unless Needed",
        "gid": "disabling_ipv6",
        "rid": "kernel_module_ipv6_option_disabled",
        "fix_id": "kernel_module_ipv6_option_disabled"
      },
      "id": "disabling_ipv6",
      "title": [
        {
          "#text": "Disable IPv6 Networking Support Automatic Loading",
          "@_lang": "en-US"
        }
      ],
      "desc": "To prevent the IPv6 kernel module () from binding to the IPv6 networking stack, add the following line to(or another file in):This permits the IPv6 module to be loaded (and thus satisfy other modules that depend on it), while disabling support for the IPv6 protocol.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # Prevent the IPv6 kernel module (ipv6) from loading the IPv6 networking stack echo \"options ipv6 disable=1\" &gt; /etc/modprobe.d/ipv6.conf # Since according to: https://access.redhat.com/solutions/72733 # \"ipv6 disable=1\" options doesn't always disable the IPv6 networking stack from # loading, instruct also sysctl configuration to disable IPv6 according to: # https://access.redhat.com/solutions/8709#rhel6disable declare -a IPV6_SETTINGS=(\"net.ipv6.conf.all.disable_ipv6\" \"net.ipv6.conf.default.disable_ipv6\") for setting in \"${IPV6_SETTINGS[@]}\" do  # Set runtime =1 for setting  /sbin/sysctl -q -n -w \"$setting=1\"  # If setting is present in /etc/sysctl.conf, change value to \"1\"  # else, add \"$setting = 1\" to /etc/sysctl.conf  if grep -q ^\"$setting\" /etc/sysctl.conf ; then   sed -i \"s/^$setting.*/$setting = 1/g\" /etc/sysctl.conf  else   echo \"\" &gt;&gt; /etc/sysctl.conf   echo \"# Set $setting = 1 per security requirements\" &gt;&gt; /etc/sysctl.conf   echo \"$setting = 1\" &gt;&gt; /etc/sysctl.conf  fi done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Disable Support for IPv6 Unless Needed",
        "gid": "disabling_ipv6",
        "rid": "sysctl_net_ipv6_conf_all_disable_ipv6",
        "fix_id": "sysctl_net_ipv6_conf_all_disable_ipv6"
      },
      "id": "disabling_ipv6",
      "title": [
        {
          "#text": "Disable IPv6 Networking Support Automatic Loading",
          "@_lang": "en-US"
        }
      ],
      "desc": "To disable support for () add the following line to(or another file in):This disables IPv6 on all network interfaces as other services and system functionality require the IPv6 stack loaded to work.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # # Set runtime for net.ipv6.conf.all.disable_ipv6 # /sbin/sysctl -q -n -w net.ipv6.conf.all.disable_ipv6=\"1\" # # If net.ipv6.conf.all.disable_ipv6 present in /etc/sysctl.conf, change value to \"1\" # else, add \"net.ipv6.conf.all.disable_ipv6 = 1\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv6.conf.all.disable_ipv6\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"1\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv6.conf.all.disable_ipv6\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv6.conf.all.disable_ipv6\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "critical",
        "gtitle": "Disable netfs if Possible",
        "gid": "disabling_netfs",
        "rid": "service_netfs_disabled",
        "fix_id": "service_netfs_disabled"
      },
      "id": "disabling_netfs",
      "title": [
        {
          "#text": "Disable Network File Systems (netfs)",
          "@_lang": "en-US"
        }
      ],
      "desc": "The netfs script manages the boot-time mounting of several types of networked filesystems, of which NFS and Samba are the most common. If these filesystem types are not in use, the script can be disabled, protecting the system somewhat against accidental or malicious changes toand against flaws in the netfs script itself. Theservice can be disabled with the following command:",
      "impact": 1,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" stop 'netfs.service' \"$SYSTEMCTL_EXEC\" disable 'netfs.service' \"$SYSTEMCTL_EXEC\" mask 'netfs.service' # Disable socket activation if we have a unit file for it if \"$SYSTEMCTL_EXEC\" list-unit-files | grep -q '^netfs.socket'; then \"$SYSTEMCTL_EXEC\" stop 'netfs.socket' \"$SYSTEMCTL_EXEC\" mask 'netfs.socket' fi # The service may not be running because it has been started and failed, # so let's reset the state so OVAL checks pass. # Service should be 'inactive', not 'failed' after reboot though. \"$SYSTEMCTL_EXEC\" reset-failed 'netfs.service' || true else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Disable Services Used Only by NFS",
        "gid": "disabling_nfs_services",
        "rid": "package_nfs-kernel-server_removed",
        "fix_id": "package_nfs-kernel-server_removed"
      },
      "id": "disabling_nfs_services",
      "title": [
        {
          "#text": "Uninstall nfs-kernel-server Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be removed with the following command:",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # CAUTION: This remediation script will remove nfs-kernel-server #  from the system, and may remove any packages #  that depend on nfs-kernel-server. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"nfs-kernel-server\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Disable Services Used Only by NFS",
        "gid": "disabling_nfs_services",
        "rid": "package_rpcbind_removed",
        "fix_id": "package_rpcbind_removed"
      },
      "id": "disabling_nfs_services",
      "title": [
        {
          "#text": "Uninstall rpcbind Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be removed with the following command:",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # CAUTION: This remediation script will remove rpcbind #  from the system, and may remove any packages #  that depend on rpcbind. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"rpcbind\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "critical",
        "gtitle": "Disable Samba if Possible",
        "gid": "disabling_samba",
        "rid": "package_samba_removed",
        "fix_id": "package_samba_removed"
      },
      "id": "disabling_samba",
      "title": [
        {
          "#text": "Uninstall Samba Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be removed with the following command:",
      "impact": 1,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove samba #  from the system, and may remove any packages #  that depend on samba. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"samba\""
      }
    },
    {
      "tags": {
        "severity": "critical",
        "gtitle": "Disable SNMP Server if Possible",
        "gid": "disabling_snmp_service",
        "rid": "package_net-snmp_removed",
        "fix_id": "package_net-snmp_removed"
      },
      "id": "disabling_snmp_service",
      "title": [
        {
          "#text": "Uninstall net-snmp Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage provides the snmpd service. Thepackage can be removed with the following command:",
      "impact": 1,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove snmp #  from the system, and may remove any packages #  that depend on snmp. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"snmp\""
      }
    },
    {
      "tags": {
        "severity": "critical",
        "gtitle": "Disable Squid if Possible",
        "gid": "disabling_squid",
        "rid": "package_squid_removed",
        "fix_id": "package_squid_removed"
      },
      "id": "disabling_squid",
      "title": [
        {
          "#text": "Uninstall squid Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be removed with the following command:",
      "impact": 1,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove squid #  from the system, and may remove any packages #  that depend on squid. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"squid\""
      }
    },
    {
      "tags": {
        "severity": "high",
        "gtitle": "Disable vsftpd if Possible",
        "gid": "disabling_vsftpd",
        "rid": "package_vsftpd_removed",
        "fix_id": "package_vsftpd_removed"
      },
      "id": "disabling_vsftpd",
      "title": [
        {
          "#text": "Uninstall vsftpd Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be removed with the following command:",
      "impact": 0.7,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove vsftpd #  from the system, and may remove any packages #  that depend on vsftpd. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"vsftpd\""
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Disable X Windows",
        "gid": "disabling_xwindows",
        "rid": "package_xorg-x11-server-common_removed",
        "fix_id": "package_xorg-x11-server-common_removed"
      },
      "id": "disabling_xwindows",
      "title": [
        {
          "#text": "Remove the X Windows Package Group",
          "@_lang": "en-US"
        }
      ],
      "desc": "By removing the xorg-x11-server-common package, the system no longer has X Windows installed. If X Windows is not installed then the system cannot boot into graphical user mode. This prevents the system from being accidentally or maliciously booted into amode. To do so, run the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove xserver-xorg #  from the system, and may remove any packages #  that depend on xserver-xorg. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"xserver-xorg\""
      }
    },
    {
      "tags": {
        "severity": "high",
        "gtitle": "Disk Partitioning",
        "gid": "disk_partitioning",
        "rid": "encrypt_partitions"
      },
      "id": "disk_partitioning",
      "title": [
        {
          "#text": "Encrypt Partitions",
          "@_lang": "en-US"
        }
      ],
      "desc": "Ubuntu 20.04 natively supports partition encryption through the Linux Unified Key Setup-on-disk-format (LUKS) technology. The easiest way to encrypt a partition is during installation time.For manual installations, select thecheckbox during partition creation to encrypt the partition. When this option is selected the system will prompt for a passphrase to use in decrypting the partition. The passphrase will subsequently need to be entered manually every time the system boots.Detailed information on encrypting partitions using LUKS or LUKS ciphers can be found on the Ubuntu 20.04 Documentation web site:.",
      "impact": 0.7,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Disk Partitioning",
        "gid": "disk_partitioning",
        "rid": "partition_for_home"
      },
      "id": "disk_partitioning",
      "title": [
        {
          "#text": "Ensure /home Located On Separate Partition",
          "@_lang": "en-US"
        }
      ],
      "desc": "If user home directories will be stored locally, create a separate partition forat installation time (or migrate it later using LVM). Ifwill be mounted from another system such as an NFS server, then creating a separate partition is not necessary at installation time, and the mountpoint can instead be configured later.",
      "impact": 0.3,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "critical",
        "gtitle": "Disk Partitioning",
        "gid": "disk_partitioning",
        "rid": "partition_for_srv"
      },
      "id": "disk_partitioning",
      "title": [
        {
          "#text": "Ensure /srv Located On Separate Partition",
          "@_lang": "en-US"
        }
      ],
      "desc": "If a file server (FTP, TFTP...) is hosted locally, create a separate partition forat installation time (or migrate it later using LVM). Ifwill be mounted from another system such as an NFS server, then creating a separate partition is not necessary at installation time, and the mountpoint can instead be configured later.",
      "impact": 1,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Disk Partitioning",
        "gid": "disk_partitioning",
        "rid": "partition_for_tmp"
      },
      "id": "disk_partitioning",
      "title": [
        {
          "#text": "Ensure /tmp Located On Separate Partition",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thedirectory is a world-writable directory used for temporary file storage. Ensure it has its own partition or logical volume at installation time, or migrate it using LVM.",
      "impact": 0.3,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Disk Partitioning",
        "gid": "disk_partitioning",
        "rid": "partition_for_var"
      },
      "id": "disk_partitioning",
      "title": [
        {
          "#text": "Ensure /var Located On Separate Partition",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thedirectory is used by daemons and other system services to store frequently-changing data. Ensure thathas its own partition or logical volume at installation time, or migrate it using LVM.",
      "impact": 0.3,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Disk Partitioning",
        "gid": "disk_partitioning",
        "rid": "partition_for_var_log"
      },
      "id": "disk_partitioning",
      "title": [
        {
          "#text": "Ensure /var/log Located On Separate Partition",
          "@_lang": "en-US"
        }
      ],
      "desc": "System logs are stored in thedirectory. Ensure thathas its own partition or logical volume at installation time, or migrate it using LVM.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Disk Partitioning",
        "gid": "disk_partitioning",
        "rid": "partition_for_var_log_audit"
      },
      "id": "disk_partitioning",
      "title": [
        {
          "#text": "Ensure /var/log/audit Located On Separate Partition",
          "@_lang": "en-US"
        }
      ],
      "desc": "Audit logs are stored in thedirectory. Ensure thathas its own partition or logical volume at installation time, or migrate it using LVM. Make absolutely certain that it is large enough to store all audit logs that will be created by the auditing daemon.",
      "impact": 0.3,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Disk Partitioning",
        "gid": "disk_partitioning",
        "rid": "partition_for_var_tmp"
      },
      "id": "disk_partitioning",
      "title": [
        {
          "#text": "Ensure /var/tmp Located On Separate Partition",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thedirectory is a world-writable directory used for temporary file storage. Ensure it has its own partition or logical volume at installation time, or migrate it using LVM.",
      "impact": 0.3,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Enable ExecShield",
        "gid": "enable_execshield_settings",
        "rid": "sysctl_kernel_kptr_restrict",
        "fix_id": "sysctl_kernel_kptr_restrict"
      },
      "id": "enable_execshield_settings",
      "title": [
        {
          "#text": "Restrict Exposed Kernel Pointer Addresses Access",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # # Set runtime for kernel.kptr_restrict # /sbin/sysctl -q -n -w kernel.kptr_restrict=\"1\" # # If kernel.kptr_restrict present in /etc/sysctl.conf, change value to \"1\" # else, add \"kernel.kptr_restrict = 1\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^kernel.kptr_restrict\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"1\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^kernel.kptr_restrict\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^kernel.kptr_restrict\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Enable ExecShield",
        "gid": "enable_execshield_settings",
        "rid": "sysctl_kernel_randomize_va_space",
        "fix_id": "sysctl_kernel_randomize_va_space"
      },
      "id": "enable_execshield_settings",
      "title": [
        {
          "#text": "Enable Randomized Layout of Virtual Address Space",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # # Set runtime for kernel.randomize_va_space # /sbin/sysctl -q -n -w kernel.randomize_va_space=\"2\" # # If kernel.randomize_va_space present in /etc/sysctl.conf, change value to \"2\" # else, add \"kernel.randomize_va_space = 2\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^kernel.randomize_va_space\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"2\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^kernel.randomize_va_space\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^kernel.randomize_va_space\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Enable Execute Disable (XD) or No Execute (NX) Support on x86 Systems",
        "gid": "enable_nx",
        "rid": "ensure_xd_nx_support_enabled"
      },
      "id": "enable_nx",
      "title": [
        {
          "#text": "Ensure XD/NX support is enabled",
          "@_lang": "en-US"
        }
      ],
      "desc": "Recent processors in the x86 family support the ability to prevent code execution on a per memory page basis. Generically and on AMD processors, this ability is called No Execute (NX), while on Intel processors it is called Execute Disable (XD). This ability can help prevent exploitation of buffer overflow vulnerabilities and should be activated whenever possible. Extra steps must be taken to ensure that this protection is enabled, particularly on 32-bit x86 systems. Other processors, such as Itanium and POWER, have included such support since inception and the standard kernel for those platforms supports the feature. Note: Ensure your system supports the XD or NX bit and has PAE support before implementing this recommendation as this may prevent it from booting if these are not supported by your hardware.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Endpoint Protection Software",
        "gid": "endpoint_security_software",
        "rid": "configure_user_data_backups"
      },
      "id": "endpoint_security_software",
      "title": [
        {
          "#text": "Configure Backups of User Data",
          "@_lang": "en-US"
        }
      ],
      "desc": "The operating system must conduct backups of user data contained in the operating system. The operating system provides utilities for automating backups of user data. Commercial and open-source products are also available.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Ensure Proper Configuration of Log Files",
        "gid": "ensure_rsyslog_log_file_configuration",
        "rid": "rsyslog_encrypt_offload_actionsendstreamdriverauthmode"
      },
      "id": "ensure_rsyslog_log_file_configuration",
      "title": [
        {
          "#text": "Ensure Rsyslog Authenticates Off-Loaded Audit Records",
          "@_lang": "en-US"
        }
      ],
      "desc": "Rsyslogd is a system utility providing support for message logging. Support for both internet and UNIX domain sockets enables this utility to support both local and remote logging. Couple this utility with(which is a secure communications library implementing the SSL, TLS and DTLS protocols), and you have a method to securely encrypt and off-load auditing. When usingto off-load logs the remote system must be authenticated.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Ensure Proper Configuration of Log Files",
        "gid": "ensure_rsyslog_log_file_configuration",
        "rid": "rsyslog_encrypt_offload_actionsendstreamdrivermode"
      },
      "id": "ensure_rsyslog_log_file_configuration",
      "title": [
        {
          "#text": "Ensure Rsyslog Encrypts Off-Loaded Audit Records",
          "@_lang": "en-US"
        }
      ],
      "desc": "Rsyslogd is a system utility providing support for message logging. Support for both internet and UNIX domain sockets enables this utility to support both local and remote logging. Couple this utility with(which is a secure communications library implementing the SSL, TLS and DTLS protocols), and you have a method to securely encrypt and off-load auditing. When usingto off-load logs off a encrpytion system must be used.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Ensure Proper Configuration of Log Files",
        "gid": "ensure_rsyslog_log_file_configuration",
        "rid": "rsyslog_encrypt_offload_defaultnetstreamdriver"
      },
      "id": "ensure_rsyslog_log_file_configuration",
      "title": [
        {
          "#text": "Ensure Rsyslog Encrypts Off-Loaded Audit Records",
          "@_lang": "en-US"
        }
      ],
      "desc": "Rsyslogd is a system utility providing support for message logging. Support for both internet and UNIX domain sockets enables this utility to support both local and remote logging. Couple this utility with(which is a secure communications library implementing the SSL, TLS and DTLS protocols), and you have a method to securely encrypt and off-load auditing. When usingto off-load logs off a encrpytion system must be used.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Ensure Proper Configuration of Log Files",
        "gid": "ensure_rsyslog_log_file_configuration",
        "rid": "rsyslog_files_groupownership"
      },
      "id": "ensure_rsyslog_log_file_configuration",
      "title": [
        {
          "#text": "Ensure Log Files Are Owned By Appropriate Group",
          "@_lang": "en-US"
        }
      ],
      "desc": "The group-owner of all log files written byshould be. These log files are determined by the second part of each Rule line inand typically all appear in. For each log filereferenced in, run the following command to inspect the file's group owner:If the owner is not, run the following command to correct this:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Ensure Proper Configuration of Log Files",
        "gid": "ensure_rsyslog_log_file_configuration",
        "rid": "rsyslog_files_ownership"
      },
      "id": "ensure_rsyslog_log_file_configuration",
      "title": [
        {
          "#text": "Ensure Log Files Are Owned By Appropriate User",
          "@_lang": "en-US"
        }
      ],
      "desc": "The owner of all log files written byshould be. These log files are determined by the second part of each Rule line inand typically all appear in. For each log filereferenced in, run the following command to inspect the file's owner:If the owner is not, run the following command to correct this:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Ensure Proper Configuration of Log Files",
        "gid": "ensure_rsyslog_log_file_configuration",
        "rid": "rsyslog_files_permissions",
        "fix_id": "rsyslog_files_permissions"
      },
      "id": "ensure_rsyslog_log_file_configuration",
      "title": [
        {
          "#text": "Ensure System Log Files Have Correct Permissions",
          "@_lang": "en-US"
        }
      ],
      "desc": "The file permissions for all log files written byshould be set to 600, or more restrictive. These log files are determined by the second part of each Rule line inand typically all appear in. For each log filereferenced in, run the following command to inspect the file's permissions:If the permissions are not 600 or more restrictive, run the following command to correct this:\"",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # List of log file paths to be inspected for correct permissions # * Primarily inspect log file paths listed in /etc/rsyslog.conf RSYSLOG_ETC_CONFIG=\"/etc/rsyslog.conf\" # * And also the log file paths listed after rsyslog's $IncludeConfig directive # (store the result into array for the case there's shell glob used as value of IncludeConfig) readarray -t RSYSLOG_INCLUDE_CONFIG &lt; &lt;(grep -e \"\\$IncludeConfig[[:space:]]\\+[^[:space:];]\\+\" /etc/rsyslog.conf | cut -d ' ' -f 2) readarray -t RSYSLOG_INCLUDE &lt; &lt;(awk '/)/{f=0} /include\\(/{f=1} f{nf=gensub(\"^(include\\\\(|\\\\s*)file=\\\"(\\\\S+)\\\".*\",\"\\\\2\",1); if($0!=nf){print nf}}' /etc/rsyslog.conf) # Declare an array to hold the final list of different log file paths declare -a LOG_FILE_PATHS # Browse each file selected above as containing paths of log files # ('/etc/rsyslog.conf' and '/etc/rsyslog.d/*.conf' in the default configuration) for LOG_FILE in \"${RSYSLOG_ETC_CONFIG}\" \"${RSYSLOG_INCLUDE_CONFIG[@]}\" \"${RSYSLOG_INCLUDE[@]}\" do  # From each of these files extract just particular log file path(s), thus:  # * Ignore lines starting with space (' '), comment ('#\"), or variable syntax ('$') characters,  # * Ignore empty lines,  # * Strip quotes and closing brackets from paths.  # * Ignore paths that match /dev|/etc.*\\.conf, as those are paths, but likely not log files  # * From the remaining valid rows select only fields constituting a log file path  # Text file column is understood to represent a log file path if and only if all of the following are met:  # * it contains at least one slash '/' character,  # * it is preceded by space  # * it doesn't contain space (' '), colon (':'), and semicolon (';') characters  # Search log file for path(s) only in case it exists!  if [[ -f \"${LOG_FILE}\" ]]  then   NORMALIZED_CONFIG_FILE_LINES=$(sed -e \"/^[[:space:]|#|$]/d\" \"${LOG_FILE}\")   LINES_WITH_PATHS=$(grep '[^/]*\\s\\+\\S*/\\S\\+' &lt;&lt;&lt; \"${NORMALIZED_CONFIG_FILE_LINES}\")   FILTERED_PATHS=$(sed -e 's/[^\\/]*[[:space:]]*\\([^:;[:space:]]*\\)/\\1/g' &lt;&lt;&lt; \"${LINES_WITH_PATHS}\")   CLEANED_PATHS=$(sed -e \"s/[\\\"')]//g; /\\\\/etc.*\\.conf/d; /\\\\/dev\\\\//d\" &lt;&lt;&lt; \"${FILTERED_PATHS}\")   MATCHED_ITEMS=$(sed -e \"/^$/d\" &lt;&lt;&lt; \"${CLEANED_PATHS}\")   # Since above sed command might return more than one item (delimited by newline), split the particular   # matches entries into new array specific for this log file   readarray -t ARRAY_FOR_LOG_FILE &lt;&lt;&lt; \"$MATCHED_ITEMS\"   # Concatenate the two arrays - previous content of $LOG_FILE_PATHS array with   # items from newly created array for this log file   LOG_FILE_PATHS+=(\"${ARRAY_FOR_LOG_FILE[@]}\")   # Delete the temporary array   unset ARRAY_FOR_LOG_FILE  fi done for LOG_FILE_PATH in \"${LOG_FILE_PATHS[@]}\" do  # Sanity check - if particular $LOG_FILE_PATH is empty string, skip it from further processing  if [ -z \"$LOG_FILE_PATH\" ]  then   continue  fi  # Also for each log file check if its permissions differ from 600. If so, correct them  if [ -f \"$LOG_FILE_PATH\" ] &amp;&amp; [ \"$(/usr/bin/stat -c %a \"$LOG_FILE_PATH\")\" -ne 600 ]  then   /bin/chmod 600 \"$LOG_FILE_PATH\"  fi done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Ensure Proper Configuration of Log Files",
        "gid": "ensure_rsyslog_log_file_configuration",
        "rid": "rsyslog_remote_access_monitoring",
        "fix_id": "rsyslog_remote_access_monitoring"
      },
      "id": "ensure_rsyslog_log_file_configuration",
      "title": [
        {
          "#text": "Ensure remote access methods are monitored in Rsyslog",
          "@_lang": "en-US"
        }
      ],
      "desc": "Logging of remote access methods must be implemented to help identify cyber attacks and ensure ongoing compliance with remote access policies are being audited and upheld. An examples of a remote access method is the use of the Remote Desktop Protocol (RDP) from an external, non-organization controlled network. Theorfile should contain a match for the following selectors:,, and. If not, use the following as an example configuration:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then declare -A REMOTE_METHODS=( ['auth.*']='^.*auth\\.\\*.*$' ['authpriv.*']='^.*authpriv\\.\\*.*$' ['daemon.*']='^.*daemon\\.\\*.*$' ) if [[ ! -f /etc/rsyslog.conf ]]; then  # Something is not right, create the file  touch /etc/rsyslog.conf fi APPEND_LINE=$(sed -rn '/^\\S+\\s+\\/var\\/log\\/secure$/p' /etc/rsyslog.conf) # Loop through the remote methods associative array for K in ${!REMOTE_METHODS[@]} do  # Check to see if selector/value exists  if ! grep -rq \"${REMOTE_METHODS[$K]}\" /etc/rsyslog.*; then   # Make sure we have a line to insert after, otherwise append to end   if [[ ! -z ${APPEND_LINE} ]]; then    # Add selector to file    sed -r -i \"0,/^(\\S+\\s+\\/var\\/log\\/secure$)/s//\\1 ${K} \\/var\\/log\\/secure/\" /etc/rsyslog.conf   else    echo \"${K} \\/var\\/log\\/secure/\" &gt;&gt; /etc/rsyslog.conf   fi  fi done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Protect Random-Number Entropy Pool",
        "gid": "entropy",
        "rid": "kernel_disable_entropy_contribution_for_solid_state_drives"
      },
      "id": "entropy",
      "title": [
        {
          "#text": "Ensure Solid State Drives Do Not Contribute To Random-Number Entropy Pool",
          "@_lang": "en-US"
        }
      ],
      "desc": "For each solid-state drive on the system, run:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Important Files and Directories",
        "gid": "files",
        "rid": "dir_perms_world_writable_sticky_bits",
        "fix_id": "dir_perms_world_writable_sticky_bits"
      },
      "id": "files",
      "title": [
        {
          "#text": "Verify that All World-Writable Directories Have Sticky Bits Set",
          "@_lang": "en-US"
        }
      ],
      "desc": "When the so-called 'sticky bit' is set on a directory, only the owner of a given file may remove that file from the directory. Without the sticky bit, any user with write access to a directory may remove any file in the directory. Setting the sticky bit prevents users from removing each other's files. In cases where there is no reason for a directory to be world-writable, a better solution is to remove that permission rather than to set the sticky bit. However, if a directory is used by a particular application, consult that application's documentation instead of blindly changing modes.To set the sticky bit on a world-writable directory, run the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "df --local -P | awk '{if (NR!=1) print $6}' \\ | xargs -I '{}' find '{}' -xdev -type d \\ \\( -perm -0002 -a ! -perm -1000 \\) 2&gt;/dev/null \\ | xargs chmod a+t"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Important Files and Directories",
        "gid": "files",
        "rid": "file_permissions_etc_audit_auditd",
        "fix_id": "file_permissions_etc_audit_auditd"
      },
      "id": "files",
      "title": [
        {
          "#text": "Verify Permissions on /etc/audit/auditd.conf and /etc/audit/audit.rules",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "readarray -t files &lt; &lt;(find /etc/audit/) for file in \"${files[@]}\"; do if basename $file | grep -qE '^audit(\\.rules|d\\.conf)$'; then chmod 0640 $file fi done"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Important Files and Directories",
        "gid": "files",
        "rid": "file_permissions_etc_audit_rulesd",
        "fix_id": "file_permissions_etc_audit_rulesd"
      },
      "id": "files",
      "title": [
        {
          "#text": "Verify Permissions on /etc/audit/rules.d/*.rules",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "readarray -t files &lt; &lt;(find /etc/audit/rules.d/) for file in \"${files[@]}\"; do if basename $file | grep -qE '^.*rules$'; then chmod 0640 $file fi done"
      }
    },
    {
      "tags": {
        "severity": "critical",
        "gtitle": "Verify Permissions on Important Files and Directories",
        "gid": "files",
        "rid": "file_permissions_systemmap"
      },
      "id": "files",
      "title": [
        {
          "#text": "Verify that local System.map file (if exists) is readable only by root",
          "@_lang": "en-US"
        }
      ],
      "desc": "Files containing sensitive informations should be protected by restrictive permissions. Most of the time, there is no need that these files need to be read by any non-root user To properly set the permissions of, run the command:",
      "impact": 1,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Important Files and Directories",
        "gid": "files",
        "rid": "file_permissions_unauthorized_world_writable",
        "fix_id": "file_permissions_unauthorized_world_writable"
      },
      "id": "files",
      "title": [
        {
          "#text": "Ensure No World-Writable Files Exist",
          "@_lang": "en-US"
        }
      ],
      "desc": "It is generally a good idea to remove global (other) write access to a file when it is discovered. However, check with documentation for specific applications before making changes. Also, monitor for recurring world-writable files, as these may be symptoms of a misconfigured application or user account. Finally, this applies to real files and not virtual files that are a part of pseudo file systems such asor.",
      "impact": 0.5,
      "descs": {
        "fix": "find / -xdev -type f -perm -002 -exec chmod o-w {} \\;"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Important Files and Directories",
        "gid": "files",
        "rid": "no_files_unowned_by_user"
      },
      "id": "files",
      "title": [
        {
          "#text": "Ensure All Files Are Owned by a User",
          "@_lang": "en-US"
        }
      ],
      "desc": "If any files are not owned by a user, then the cause of their lack of ownership should be investigated. Following this, the files should be deleted or assigned to an appropriate user. The following command will discover and print any files on local partitions which do not belong to a valid user:To search all filesystems on a system including network mounted filesystems the following command can be run manually for each partition:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Important Files and Directories",
        "gid": "files",
        "rid": "no_ungrouped_files_or_dirs"
      },
      "id": "files",
      "title": [
        {
          "#text": "Ensure no ungrouped files or directories exist",
          "@_lang": "en-US"
        }
      ],
      "desc": "Sometimes when administrators delete users or groups from the system they neglect to remove all files owned by those users or groups. A new user who is assigned the deleted user's user ID or group ID may then end up \"owning\" these files, and thus have more access on the system than was intended.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Important Files and Directories",
        "gid": "files",
        "rid": "permissions_local_var_log",
        "fix_id": "permissions_local_var_log"
      },
      "id": "files",
      "title": [
        {
          "#text": "Verify permissions of log files",
          "@_lang": "en-US"
        }
      ],
      "desc": "Any operating system providing too much information in error messages risks compromising the data and security of the structure, and content of error messages needs to be carefully considered by the organization. Organizations carefully consider the structure/content of error messages. The extent to which information systems are able to identify and handle error conditions is guided by organizational policy and operational requirements. Information that could be exploited by adversaries includes, for example, erroneous logon attempts with passwords entered by mistake as the username, mission/business information that can be derived from (if not stated explicitly by) information recorded, and personal information, such as account numbers, social security numbers, and credit card numbers.",
      "impact": 0.5,
      "descs": {
        "fix": "readarray -t files &lt; &lt;(find /var/log/) for file in \"${files[@]}\"; do if basename $file | grep -qE '^.*$'; then chmod 0640 $file fi done if grep -qE \"^f \\/var\\/log\\/(btmp|wtmp|lastlog)? \" /usr/lib/tmpfiles.d/var.conf; then sed -i --follow-symlinks \"s/\\(^f[[:space:]]\\+\\/var\\/log\\/btmp[[:space:]]\\+\\)\\(\\([[:digit:]]\\+\\)[^ $]*\\)/\\10640/\" /usr/lib/tmpfiles.d/var.conf sed -i --follow-symlinks \"s/\\(^f[[:space:]]\\+\\/var\\/log\\/wtmp[[:space:]]\\+\\)\\(\\([[:digit:]]\\+\\)[^ $]*\\)/\\10640/\" /usr/lib/tmpfiles.d/var.conf sed -i --follow-symlinks \"s/\\(^f[[:space:]]\\+\\/var\\/log\\/lastlog[[:space:]]\\+\\)\\(\\([[:digit:]]\\+\\)[^ $]*\\)/\\10640/\" /usr/lib/tmpfiles.d/var.conf fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Important Files and Directories",
        "gid": "files",
        "rid": "sysctl_fs_protected_hardlinks",
        "fix_id": "sysctl_fs_protected_hardlinks"
      },
      "id": "files",
      "title": [
        {
          "#text": "Enable Kernel Parameter to Enforce DAC on Hardlinks",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # # Set runtime for fs.protected_hardlinks # /sbin/sysctl -q -n -w fs.protected_hardlinks=\"1\" # # If fs.protected_hardlinks present in /etc/sysctl.conf, change value to \"1\" # else, add \"fs.protected_hardlinks = 1\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^fs.protected_hardlinks\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"1\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^fs.protected_hardlinks\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^fs.protected_hardlinks\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Important Files and Directories",
        "gid": "files",
        "rid": "sysctl_fs_protected_symlinks",
        "fix_id": "sysctl_fs_protected_symlinks"
      },
      "id": "files",
      "title": [
        {
          "#text": "Enable Kernel Parameter to Enforce DAC on Symlinks",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # # Set runtime for fs.protected_symlinks # /sbin/sysctl -q -n -w fs.protected_symlinks=\"1\" # # If fs.protected_symlinks present in /etc/sysctl.conf, change value to \"1\" # else, add \"fs.protected_symlinks = 1\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^fs.protected_symlinks\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"1\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^fs.protected_symlinks\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^fs.protected_symlinks\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Federal Information Processing Standard (FIPS)",
        "gid": "fips",
        "rid": "enable_dracut_fips_module"
      },
      "id": "fips",
      "title": [
        {
          "#text": "Enable Dracut FIPS Module",
          "@_lang": "en-US"
        }
      ],
      "desc": "To enable FIPS mode, run the following command:To enable FIPS, the system requires that themodule is added inconfiguration. Check ifcontain",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gtitle": "Federal Information Processing Standard (FIPS)",
        "gid": "fips",
        "rid": "etc_system_fips_exists"
      },
      "id": "fips",
      "title": [
        {
          "#text": "Ensure '/etc/system-fips' exists",
          "@_lang": "en-US"
        }
      ],
      "desc": "On a system where FIPS mode is enabled,must exist. To enable FIPS mode, run the following command:",
      "impact": 0.7,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gtitle": "Federal Information Processing Standard (FIPS)",
        "gid": "fips",
        "rid": "is_fips_mode_enabled"
      },
      "id": "fips",
      "title": [
        {
          "#text": "Verify '/proc/sys/crypto/fips_enabled' exists",
          "@_lang": "en-US"
        }
      ],
      "desc": "On a system where FIPS 140-2 mode is enabled,must exist. To verify FIPS mode, run the following command:",
      "impact": 0.7,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gtitle": "Federal Information Processing Standard (FIPS)",
        "gid": "fips",
        "rid": "sysctl_crypto_fips_enabled"
      },
      "id": "fips",
      "title": [
        {
          "#text": "Set kernel parameter 'crypto.fips_enabled' to 1",
          "@_lang": "en-US"
        }
      ],
      "desc": "System running in FIPS mode is indicated by kernel parameter. This parameter should be set toin FIPS mode. To enable FIPS mode, run the following command:",
      "impact": 0.7,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "critical",
        "gtitle": "Configure vsftpd to Provide FTP Service if Necessary",
        "gid": "ftp_configure_vsftpd",
        "rid": "ftp_configure_firewall"
      },
      "id": "ftp_configure_vsftpd",
      "title": [
        {
          "#text": "Configure Firewalls to Protect the FTP Server",
          "@_lang": "en-US"
        }
      ],
      "desc": "By default,blocks access to the ports used by the web server. To configureto allow port 21 traffic, one must editand(if IPv6 is in use). Add the following line, ensuring that it appears before the final LOG and DROP lines for the INPUT chain:Edit the file. Ensure that the space-separated list of modules contains the FTP connection tracking module:",
      "impact": 1,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "critical",
        "gtitle": "Restrict the Set of Users Allowed to Access FTP",
        "gid": "ftp_restrict_users",
        "rid": "ftp_limit_users"
      },
      "id": "ftp_restrict_users",
      "title": [
        {
          "#text": "Limit Users Allowed FTP Access if Necessary",
          "@_lang": "en-US"
        }
      ],
      "desc": "If there is a mission-critical reason for users to access their accounts via the insecure FTP protocol, limit the set of users who are allowed this access. Edit the vsftpd configuration file. Add or correct the following configuration options:Edit the file. For each user USERNAME who should be allowed to access the system via FTP, add a line containing that user's name:If anonymous access is also required, add the anonymous usernames toas well.",
      "impact": 1,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "GNOME Desktop Environment",
        "gid": "gnome",
        "rid": "package_gdm_removed",
        "fix_id": "package_gdm_removed"
      },
      "id": "gnome",
      "title": [
        {
          "#text": "Remove the GDM Package Group",
          "@_lang": "en-US"
        }
      ],
      "desc": "By removing thepackage, the system no longer has GNOME installed installed. If X Windows is not installed then the system cannot boot into graphical user mode. This prevents the system from being accidentally or maliciously booted into amode. To do so, run the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'gdm3' 2&gt;/dev/null | grep -q installed; then # CAUTION: This remediation script will remove gdm3 #  from the system, and may remove any packages #  that depend on gdm3. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"gdm3\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gtitle": "GNOME Desktop Environment",
        "gid": "gnome",
        "rid": "enable_dconf_user_profile",
        "fix_id": "enable_dconf_user_profile"
      },
      "id": "gnome",
      "title": [
        {
          "#text": "Configure GNOME3 DConf User Profile",
          "@_lang": "en-US"
        }
      ],
      "desc": "By default, DConf provides a standard user profile. This profile contains a list of DConf configuration databases. The user profile and database always take the highest priority. As such the DConf User profile should always exist and be configured correctly.To make sure that the user profile is configured correctly, theshould be set as follows:",
      "impact": 0.7,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'gdm3' 2&gt;/dev/null | grep -q installed &amp;&amp; { [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; }; then echo -e 'user-db:user system-db:gdm' &gt; /etc/dconf/profile/gdm else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure GNOME Login Screen",
        "gid": "gnome_login_screen",
        "rid": "dconf_gnome_disable_user_list",
        "fix_id": "dconf_gnome_disable_user_list"
      },
      "id": "gnome_login_screen",
      "title": [
        {
          "#text": "Disable the GNOME3 Login User List",
          "@_lang": "en-US"
        }
      ],
      "desc": "In the default graphical environment, users logging directly into the system are greeted with a login screen that displays all known users. This functionality should be disabled by settingto.To disable, add or editto. For example:After the settings have been set, run.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'gdm3' 2&gt;/dev/null | grep -q installed &amp;&amp; { [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; }; then # Will do both approach, since we plan to migrate to checks over dconf db. That way, future updates of the tool # will pass the check even if we decide to check only for the dconf db path. if [ -e \"/etc/gdm3/greeter.dconf-defaults\" ] ; then LC_ALL=C sed -i \"/^\\s*disable\\-user\\-list/Id\" \"/etc/gdm3/greeter.dconf-defaults\" else touch \"/etc/gdm3/greeter.dconf-defaults\" fi cp \"/etc/gdm3/greeter.dconf-defaults\" \"/etc/gdm3/greeter.dconf-defaults.bak\" # Insert after the line matching the regex '\\[org/gnome/login-screen\\]' line_number=\"$(LC_ALL=C grep -n \"\\[org/gnome/login-screen\\]\" \"/etc/gdm3/greeter.dconf-defaults.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '\\[org/gnome/login-screen\\]', insert at # the end of the file. printf '%s ' \"disable-user-list=true\" &gt;&gt; \"/etc/gdm3/greeter.dconf-defaults\" else head -n \"$(( line_number ))\" \"/etc/gdm3/greeter.dconf-defaults.bak\" &gt; \"/etc/gdm3/greeter.dconf-defaults\" printf '%s ' \"disable-user-list=true\" &gt;&gt; \"/etc/gdm3/greeter.dconf-defaults\" tail -n \"+$(( line_number + 1 ))\" \"/etc/gdm3/greeter.dconf-defaults.bak\" &gt;&gt; \"/etc/gdm3/greeter.dconf-defaults\" fi # Clean up after ourselves. rm \"/etc/gdm3/greeter.dconf-defaults.bak\" # Check for setting in any of the DConf db directories # If files contain ibus or distro, ignore them. # The assignment assumes that individual filenames don't contain : readarray -t SETTINGSFILES &lt; &lt;(grep -r \"\\\\[org/gnome/login-screen\\\\]\" \"/etc/dconf/db/\" | grep -v 'distro\\|ibus' | cut -d\":\" -f1) DCONFFILE=\"/etc/dconf/db/gdm.d/00-security-settings\" DBDIR=\"/etc/dconf/db/gdm.d\" mkdir -p \"${DBDIR}\" if [ \"${#SETTINGSFILES[@]}\" -eq 0 ] then [ ! -z ${DCONFFILE} ] || echo \"\" &gt;&gt; ${DCONFFILE} printf '%s ' \"[org/gnome/login-screen]\" &gt;&gt; ${DCONFFILE} printf '%s=%s ' \"disable-user-list\" \"true\" &gt;&gt; ${DCONFFILE} else escaped_value=\"$(sed -e 's/\\\\/\\\\\\\\/g' &lt;&lt;&lt; \"true\")\" if grep -q \"^\\\\s*disable-user-list\\\\s*=\" \"${SETTINGSFILES[@]}\" then sed -i \"s/\\\\s*disable-user-list\\\\s*=\\\\s*.*/disable-user-list=${escaped_value}/g\" \"${SETTINGSFILES[@]}\" else sed -i \"\\\\|\\\\[org/gnome/login-screen\\\\]|a\\\\disable-user-list=${escaped_value}\" \"${SETTINGSFILES[@]}\" fi fi dconf update # No need to use dconf update, since bash_dconf_settings does that already else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gtitle": "Configure GNOME Login Screen",
        "gid": "gnome_login_screen",
        "rid": "gnome_gdm_disable_xdmcp",
        "fix_id": "gnome_gdm_disable_xdmcp"
      },
      "id": "gnome_login_screen",
      "title": [
        {
          "#text": "Disable XDMCP in GDM",
          "@_lang": "en-US"
        }
      ],
      "desc": "XDMCP is an unencrypted protocol, and therefore, presents a security risk, see e.g.. To disable XDMCP support in Gnome, settounder theconfiguration section in. For example:",
      "impact": 0.7,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'gdm3' 2&gt;/dev/null | grep -q installed; then # Try find '[xdmcp]' and 'Enable' in '/etc/gdm/custom.conf', if it exists, set # to 'false', if it isn't here, add it, if '[xdmcp]' doesn't exist, add it there if grep -qzosP '[[:space:]]*\\[xdmcp]([^ \\[]* +)+?[[:space:]]*Enable' '/etc/gdm/custom.conf'; then sed -i 's/Enable[^( )]*/Enable=false/' '/etc/gdm/custom.conf' elif grep -qs '[[:space:]]*\\[xdmcp]' '/etc/gdm/custom.conf'; then sed -i '/[[:space:]]*\\[xdmcp]/a Enable=false' '/etc/gdm/custom.conf' else if test -d \"/etc/gdm\"; then printf '%s ' '[xdmcp]' 'Enable=false' &gt;&gt; '/etc/gdm/custom.conf' else echo \"Config file directory '/etc/gdm' doesnt exist, not remediating, assuming non-applicability.\" &gt;&amp;2 fi fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure GNOME Screen Locking",
        "gid": "gnome_screen_locking",
        "rid": "dconf_gnome_screensaver_lock_enabled",
        "fix_id": "dconf_gnome_screensaver_lock_enabled"
      },
      "id": "gnome_screen_locking",
      "title": [
        {
          "#text": "Enable GNOME3 Screensaver Lock After Idle Period",
          "@_lang": "en-US"
        }
      ],
      "desc": "To activate locking of the screensaver in the GNOME3 desktop when it is activated, add or settoin. For example:Once the settings have been added, add a lock toto prevent user modification. For example:After the settings have been set, run.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'gdm3' 2&gt;/dev/null | grep -q installed &amp;&amp; { [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; }; then # Check for setting in any of the DConf db directories # If files contain ibus or distro, ignore them. # The assignment assumes that individual filenames don't contain : readarray -t SETTINGSFILES &lt; &lt;(grep -r \"\\\\[org/gnome/desktop/screensaver\\\\]\" \"/etc/dconf/db/\" | grep -v 'distro\\|ibus' | cut -d\":\" -f1) DCONFFILE=\"/etc/dconf/db/local.d/00-security-settings\" DBDIR=\"/etc/dconf/db/local.d\" mkdir -p \"${DBDIR}\" if [ \"${#SETTINGSFILES[@]}\" -eq 0 ] then [ ! -z ${DCONFFILE} ] || echo \"\" &gt;&gt; ${DCONFFILE} printf '%s ' \"[org/gnome/desktop/screensaver]\" &gt;&gt; ${DCONFFILE} printf '%s=%s ' \"lock-enabled\" \"true\" &gt;&gt; ${DCONFFILE} else escaped_value=\"$(sed -e 's/\\\\/\\\\\\\\/g' &lt;&lt;&lt; \"true\")\" if grep -q \"^\\\\s*lock-enabled\\\\s*=\" \"${SETTINGSFILES[@]}\" then sed -i \"s/\\\\s*lock-enabled\\\\s*=\\\\s*.*/lock-enabled=${escaped_value}/g\" \"${SETTINGSFILES[@]}\" else sed -i \"\\\\|\\\\[org/gnome/desktop/screensaver\\\\]|a\\\\lock-enabled=${escaped_value}\" \"${SETTINGSFILES[@]}\" fi fi dconf update # Check for setting in any of the DConf db directories LOCKFILES=$(grep -r \"^/org/gnome/desktop/screensaver/lock-enabled$\" \"/etc/dconf/db/\" | grep -v 'distro\\|ibus' | cut -d\":\" -f1) LOCKSFOLDER=\"/etc/dconf/db/local.d/locks\" mkdir -p \"${LOCKSFOLDER}\" if [[ -z \"${LOCKFILES}\" ]] then echo \"/org/gnome/desktop/screensaver/lock-enabled\" &gt;&gt; \"/etc/dconf/db/local.d/locks/00-security-settings-lock\" fi dconf update else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gtitle": "GNOME System Settings",
        "gid": "gnome_system_settings",
        "rid": "dconf_gnome_disable_ctrlaltdel_reboot",
        "fix_id": "dconf_gnome_disable_ctrlaltdel_reboot"
      },
      "id": "gnome_system_settings",
      "title": [
        {
          "#text": "Disable Ctrl-Alt-Del Reboot Key Sequence in GNOME3",
          "@_lang": "en-US"
        }
      ],
      "desc": "By default,will reboot the system if thekey sequence is pressed.To configure the system to ignore thekey sequence from the Graphical User Interface (GUI) instead of rebooting the system, add or settoin. For example:Once the settings have been added, add a lock toto prevent user modification. For example:After the settings have been set, run.",
      "impact": 0.7,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'gdm3' 2&gt;/dev/null | grep -q installed &amp;&amp; { [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; }; then # Check for setting in any of the DConf db directories # If files contain ibus or distro, ignore them. # The assignment assumes that individual filenames don't contain : readarray -t SETTINGSFILES &lt; &lt;(grep -r \"\\\\[org/gnome/settings-daemon/plugins/media-keys\\\\]\" \"/etc/dconf/db/\" | grep -v 'distro\\|ibus' | cut -d\":\" -f1) DCONFFILE=\"/etc/dconf/db/local.d/00-security-settings\" DBDIR=\"/etc/dconf/db/local.d\" mkdir -p \"${DBDIR}\" if [ \"${#SETTINGSFILES[@]}\" -eq 0 ] then [ ! -z ${DCONFFILE} ] || echo \"\" &gt;&gt; ${DCONFFILE} printf '%s ' \"[org/gnome/settings-daemon/plugins/media-keys]\" &gt;&gt; ${DCONFFILE} printf '%s=%s ' \"logout\" \"''\" &gt;&gt; ${DCONFFILE} else escaped_value=\"$(sed -e 's/\\\\/\\\\\\\\/g' &lt;&lt;&lt; \"''\")\" if grep -q \"^\\\\s*logout\\\\s*=\" \"${SETTINGSFILES[@]}\" then sed -i \"s/\\\\s*logout\\\\s*=\\\\s*.*/logout=${escaped_value}/g\" \"${SETTINGSFILES[@]}\" else sed -i \"\\\\|\\\\[org/gnome/settings-daemon/plugins/media-keys\\\\]|a\\\\logout=${escaped_value}\" \"${SETTINGSFILES[@]}\" fi fi dconf update # Check for setting in any of the DConf db directories LOCKFILES=$(grep -r \"^/org/gnome/settings-daemon/plugins/media-keys/logout$\" \"/etc/dconf/db/\" | grep -v 'distro\\|ibus' | cut -d\":\" -f1) LOCKSFOLDER=\"/etc/dconf/db/local.d/locks\" mkdir -p \"${LOCKSFOLDER}\" if [[ -z \"${LOCKFILES}\" ]] then echo \"/org/gnome/settings-daemon/plugins/media-keys/logout\" &gt;&gt; \"/etc/dconf/db/local.d/locks/00-security-settings-lock\" fi dconf update else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Implement a GUI Warning Banner",
        "gid": "gui_login_banner",
        "rid": "dconf_gnome_banner_enabled",
        "fix_id": "dconf_gnome_banner_enabled"
      },
      "id": "gui_login_banner",
      "title": [
        {
          "#text": "Enable GNOME3 Login Warning Banner",
          "@_lang": "en-US"
        }
      ],
      "desc": "In the default graphical environment, displaying a login warning banner in the GNOME Display Manager's login screen can be enabled on the login screen by settingto.To enable, add or editto. For example:After the settings have been set, run. The banner text must also be set.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'gdm3' 2&gt;/dev/null | grep -q installed; then # Will do both approach, since we plan to migrate to checks over dconf db. That way, future updates of the tool # will pass the check even if we decide to check only for the dconf db path. if [ -e \"/etc/gdm3/greeter.dconf-defaults\" ] ; then LC_ALL=C sed -i \"/^\\s*banner\\-message\\-enable/Id\" \"/etc/gdm3/greeter.dconf-defaults\" else touch \"/etc/gdm3/greeter.dconf-defaults\" fi cp \"/etc/gdm3/greeter.dconf-defaults\" \"/etc/gdm3/greeter.dconf-defaults.bak\" # Insert after the line matching the regex '\\[org/gnome/login-screen\\]' line_number=\"$(LC_ALL=C grep -n \"\\[org/gnome/login-screen\\]\" \"/etc/gdm3/greeter.dconf-defaults.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '\\[org/gnome/login-screen\\]', insert at # the end of the file. printf '%s ' \"banner-message-enable=true\" &gt;&gt; \"/etc/gdm3/greeter.dconf-defaults\" else head -n \"$(( line_number ))\" \"/etc/gdm3/greeter.dconf-defaults.bak\" &gt; \"/etc/gdm3/greeter.dconf-defaults\" printf '%s ' \"banner-message-enable=true\" &gt;&gt; \"/etc/gdm3/greeter.dconf-defaults\" tail -n \"+$(( line_number + 1 ))\" \"/etc/gdm3/greeter.dconf-defaults.bak\" &gt;&gt; \"/etc/gdm3/greeter.dconf-defaults\" fi # Clean up after ourselves. rm \"/etc/gdm3/greeter.dconf-defaults.bak\" # Check for setting in any of the DConf db directories # If files contain ibus or distro, ignore them. # The assignment assumes that individual filenames don't contain : readarray -t SETTINGSFILES &lt; &lt;(grep -r \"\\\\[org/gnome/login-screen\\\\]\" \"/etc/dconf/db/\" | grep -v 'distro\\|ibus' | cut -d\":\" -f1) DCONFFILE=\"/etc/dconf/db/gdm.d/00-security-settings\" DBDIR=\"/etc/dconf/db/gdm.d\" mkdir -p \"${DBDIR}\" if [ \"${#SETTINGSFILES[@]}\" -eq 0 ] then [ ! -z ${DCONFFILE} ] || echo \"\" &gt;&gt; ${DCONFFILE} printf '%s ' \"[org/gnome/login-screen]\" &gt;&gt; ${DCONFFILE} printf '%s=%s ' \"banner-message-enable\" \"true\" &gt;&gt; ${DCONFFILE} else escaped_value=\"$(sed -e 's/\\\\/\\\\\\\\/g' &lt;&lt;&lt; \"true\")\" if grep -q \"^\\\\s*banner-message-enable\\\\s*=\" \"${SETTINGSFILES[@]}\" then sed -i \"s/\\\\s*banner-message-enable\\\\s*=\\\\s*.*/banner-message-enable=${escaped_value}/g\" \"${SETTINGSFILES[@]}\" else sed -i \"\\\\|\\\\[org/gnome/login-screen\\\\]|a\\\\banner-message-enable=${escaped_value}\" \"${SETTINGSFILES[@]}\" fi fi dconf update # No need to use dconf update, since bash_dconf_settings does that already else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Implement a GUI Warning Banner",
        "gid": "gui_login_banner",
        "rid": "dconf_gnome_login_banner_text",
        "fix_id": "dconf_gnome_login_banner_text"
      },
      "id": "gui_login_banner",
      "title": [
        {
          "#text": "Set the GNOME3 Login Warning Banner Text",
          "@_lang": "en-US"
        }
      ],
      "desc": "In the default graphical environment, configuring the login warning banner text in the GNOME Display Manager's login screen can be configured on the login screen by settingtowhereis the approved banner for your environment.To enable, add or editto. For example:After the settings have been set, run. When entering a warning banner that spans several lines, remember to begin and end the string withand usefor new lines.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'gdm3' 2&gt;/dev/null | grep -q installed; then login_banner_text='' # Multiple regexes transform the banner regex into a usable banner # 0 - Remove anchors around the banner text login_banner_text=$(echo \"$login_banner_text\" | sed 's/^\\^\\(.*\\)\\$$/\\1/g') # 1 - Keep only the first banners if there are multiple # (dod_banners contains the long and short banner) login_banner_text=$(echo \"$login_banner_text\" | sed 's/^(\\(.*\\)|.*)$/\\1/g') # 2 - Add spaces ' '. (Transforms regex for \"space or newline\" into a \" \") login_banner_text=$(echo \"$login_banner_text\" | sed 's/\\[\\\\s\\ \\]+/ /g') # 3 - Adds newline \"tokens\". (Transforms \"(?:\\[\\ \\]+|(?:\\ )+)\" into \"(n)*\") login_banner_text=$(echo \"$login_banner_text\" | sed 's/(?:\\[\\ \\]+|(?:\\\\\\ )+)/(n)*/g') # 4 - Remove any leftover backslash. (From any parethesis in the banner, for example). login_banner_text=$(echo \"$login_banner_text\" | sed 's/\\\\//g') # 5 - Removes the newline \"token.\" (Transforms them into newline escape sequences \" \"). # ( Needs to be done after 4, otherwise the escapce sequence will become just \"n\". login_banner_text=$(echo \"$login_banner_text\" | sed 's/(n)\\*/\\ /g') # Will do both approach, since we plan to migrate to checks over dconf db. That way, future updates of the tool # will pass the check even if we decide to check only for the dconf db path. if [ -e \"/etc/gdm3/greeter.dconf-defaults\" ] ; then LC_ALL=C sed -i \"/^\\s*banner\\-message\\-text/Id\" \"/etc/gdm3/greeter.dconf-defaults\" else touch \"/etc/gdm3/greeter.dconf-defaults\" fi cp \"/etc/gdm3/greeter.dconf-defaults\" \"/etc/gdm3/greeter.dconf-defaults.bak\" # Insert after the line matching the regex '\\[org/gnome/login-screen\\]' line_number=\"$(LC_ALL=C grep -n \"\\[org/gnome/login-screen\\]\" \"/etc/gdm3/greeter.dconf-defaults.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '\\[org/gnome/login-screen\\]', insert at # the end of the file. printf '%s ' \"banner-message-text='${login_banner_text}'\" &gt;&gt; \"/etc/gdm3/greeter.dconf-defaults\" else head -n \"$(( line_number ))\" \"/etc/gdm3/greeter.dconf-defaults.bak\" &gt; \"/etc/gdm3/greeter.dconf-defaults\" printf '%s ' \"banner-message-text='${login_banner_text}'\" &gt;&gt; \"/etc/gdm3/greeter.dconf-defaults\" tail -n \"+$(( line_number + 1 ))\" \"/etc/gdm3/greeter.dconf-defaults.bak\" &gt;&gt; \"/etc/gdm3/greeter.dconf-defaults\" fi # Clean up after ourselves. rm \"/etc/gdm3/greeter.dconf-defaults.bak\" # Check for setting in any of the DConf db directories # If files contain ibus or distro, ignore them. # The assignment assumes that individual filenames don't contain : readarray -t SETTINGSFILES &lt; &lt;(grep -r \"\\\\[org/gnome/login-screen\\\\]\" \"/etc/dconf/db/\" | grep -v 'distro\\|ibus' | cut -d\":\" -f1) DCONFFILE=\"/etc/dconf/db/gdm.d/00-security-settings\" DBDIR=\"/etc/dconf/db/gdm.d\" mkdir -p \"${DBDIR}\" if [ \"${#SETTINGSFILES[@]}\" -eq 0 ] then [ ! -z ${DCONFFILE} ] || echo \"\" &gt;&gt; ${DCONFFILE} printf '%s ' \"[org/gnome/login-screen]\" &gt;&gt; ${DCONFFILE} printf '%s=%s ' \"banner-message-text\" \"'${login_banner_text}'\" &gt;&gt; ${DCONFFILE} else escaped_value=\"$(sed -e 's/\\\\/\\\\\\\\/g' &lt;&lt;&lt; \"'${login_banner_text}'\")\" if grep -q \"^\\\\s*banner-message-text\\\\s*=\" \"${SETTINGSFILES[@]}\" then sed -i \"s/\\\\s*banner-message-text\\\\s*=\\\\s*.*/banner-message-text=${escaped_value}/g\" \"${SETTINGSFILES[@]}\" else sed -i \"\\\\|\\\\[org/gnome/login-screen\\\\]|a\\\\banner-message-text=${escaped_value}\" \"${SETTINGSFILES[@]}\" fi fi dconf update # No need to use dconf update, since bash_dconf_settings does that already else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Harden Local EXIM4 MTA Configuration",
        "gid": "harden_exim4_config",
        "rid": "exim4_configtype_local",
        "fix_id": "exim4_configtype_local"
      },
      "id": "harden_exim4_config",
      "title": [
        {
          "#text": "Ensure EXIM4 is configured for local-only mode",
          "@_lang": "en-US"
        }
      ],
      "desc": "Mail Transfer Agents (MTA), such as sendmail and Postfix, are used to listen for incoming mail and transfer the messages to the appropriate user or mail server. If the system is not intended to be a mail server, it is recommended that the MTA be configured to only process local mail.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { dpkg-query --show --showformat='${db:Status-Status} ' 'exim4' 2&gt;/dev/null | grep -q installed; }; then if [ -e \"/etc/exim4/update-exim4.conf.conf\" ] ; then LC_ALL=C sed -i \"/^dc_eximconfig_configtype=/d\" \"/etc/exim4/update-exim4.conf.conf\" else touch \"/etc/exim4/update-exim4.conf.conf\" fi cp \"/etc/exim4/update-exim4.conf.conf\" \"/etc/exim4/update-exim4.conf.conf.bak\" # Insert at the end of the file printf '%s ' \"dc_eximconfig_configtype=local\" &gt;&gt; \"/etc/exim4/update-exim4.conf.conf\" # Clean up after ourselves. rm \"/etc/exim4/update-exim4.conf.conf.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Harden Local EXIM4 MTA Configuration",
        "gid": "harden_exim4_config",
        "rid": "exim4_hide_mailname",
        "fix_id": "exim4_hide_mailname"
      },
      "id": "harden_exim4_config",
      "title": [
        {
          "#text": "Ensure EXIM4 is configured to not hide mailname",
          "@_lang": "en-US"
        }
      ],
      "desc": "Mail Transfer Agents (MTA), such as sendmail and Postfix, are used to listen for incoming mail and transfer the messages to the appropriate user or mail server. If the system is not intended to be a mail server, it is recommended that the MTA be configured to only process local mail.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { dpkg-query --show --showformat='${db:Status-Status} ' 'exim4' 2&gt;/dev/null | grep -q installed; }; then if [ -e \"/etc/exim4/update-exim4.conf.conf\" ] ; then LC_ALL=C sed -i \"/^dc_hide_mailname=/d\" \"/etc/exim4/update-exim4.conf.conf\" else touch \"/etc/exim4/update-exim4.conf.conf\" fi cp \"/etc/exim4/update-exim4.conf.conf\" \"/etc/exim4/update-exim4.conf.conf.bak\" # Insert at the end of the file printf '%s ' \"dc_hide_mailname=\" &gt;&gt; \"/etc/exim4/update-exim4.conf.conf\" # Clean up after ourselves. rm \"/etc/exim4/update-exim4.conf.conf.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Harden Local EXIM4 MTA Configuration",
        "gid": "harden_exim4_config",
        "rid": "exim4_local_interfaces",
        "fix_id": "exim4_local_interfaces"
      },
      "id": "harden_exim4_config",
      "title": [
        {
          "#text": "Ensure EXIM4 is configured to use local interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "Mail Transfer Agents (MTA), such as sendmail and Postfix, are used to listen for incoming mail and transfer the messages to the appropriate user or mail server. If the system is not intended to be a mail server, it is recommended that the MTA be configured to only process local mail.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { dpkg-query --show --showformat='${db:Status-Status} ' 'exim4' 2&gt;/dev/null | grep -q installed; }; then if [ -e \"/etc/exim4/update-exim4.conf.conf\" ] ; then LC_ALL=C sed -i \"/^dc_local_interfaces=/d\" \"/etc/exim4/update-exim4.conf.conf\" else touch \"/etc/exim4/update-exim4.conf.conf\" fi cp \"/etc/exim4/update-exim4.conf.conf\" \"/etc/exim4/update-exim4.conf.conf.bak\" # Insert at the end of the file printf '%s ' \"dc_local_interfaces=127.0.0.1 ; ::1\" &gt;&gt; \"/etc/exim4/update-exim4.conf.conf\" # Clean up after ourselves. rm \"/etc/exim4/update-exim4.conf.conf.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Harden Local EXIM4 MTA Configuration",
        "gid": "harden_exim4_config",
        "rid": "exim4_localdelivery",
        "fix_id": "exim4_localdelivery"
      },
      "id": "harden_exim4_config",
      "title": [
        {
          "#text": "Ensure EXIM4 is configured to use mail_spool for local delivery",
          "@_lang": "en-US"
        }
      ],
      "desc": "Mail Transfer Agents (MTA), such as sendmail and Postfix, are used to listen for incoming mail and transfer the messages to the appropriate user or mail server. If the system is not intended to be a mail server, it is recommended that the MTA be configured to only process local mail.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { dpkg-query --show --showformat='${db:Status-Status} ' 'exim4' 2&gt;/dev/null | grep -q installed; }; then if [ -e \"/etc/exim4/update-exim4.conf.conf\" ] ; then LC_ALL=C sed -i \"/^dc_localdelivery=/d\" \"/etc/exim4/update-exim4.conf.conf\" else touch \"/etc/exim4/update-exim4.conf.conf\" fi cp \"/etc/exim4/update-exim4.conf.conf\" \"/etc/exim4/update-exim4.conf.conf.bak\" # Insert at the end of the file printf '%s ' \"dc_localdelivery=mail_spool\" &gt;&gt; \"/etc/exim4/update-exim4.conf.conf\" # Clean up after ourselves. rm \"/etc/exim4/update-exim4.conf.conf.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Harden Local EXIM4 MTA Configuration",
        "gid": "harden_exim4_config",
        "rid": "exim4_mailname_in_oh",
        "fix_id": "exim4_mailname_in_oh"
      },
      "id": "harden_exim4_config",
      "title": [
        {
          "#text": "Ensure EXIM4 is configured for mailname in other_hostnames",
          "@_lang": "en-US"
        }
      ],
      "desc": "Mail Transfer Agents (MTA), such as sendmail and Postfix, are used to listen for incoming mail and transfer the messages to the appropriate user or mail server. If the system is not intended to be a mail server, it is recommended that the MTA be configured to only process local mail.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { dpkg-query --show --showformat='${db:Status-Status} ' 'exim4' 2&gt;/dev/null | grep -q installed; }; then if [ -e \"/etc/exim4/update-exim4.conf.conf\" ] ; then LC_ALL=C sed -i \"/^dc_mailname_in_oh=/d\" \"/etc/exim4/update-exim4.conf.conf\" else touch \"/etc/exim4/update-exim4.conf.conf\" fi cp \"/etc/exim4/update-exim4.conf.conf\" \"/etc/exim4/update-exim4.conf.conf.bak\" # Insert at the end of the file printf '%s ' \"dc_mailname_in_oh=true\" &gt;&gt; \"/etc/exim4/update-exim4.conf.conf\" # Clean up after ourselves. rm \"/etc/exim4/update-exim4.conf.conf.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Harden Local EXIM4 MTA Configuration",
        "gid": "harden_exim4_config",
        "rid": "exim4_minimaldns",
        "fix_id": "exim4_minimaldns"
      },
      "id": "harden_exim4_config",
      "title": [
        {
          "#text": "Ensure EXIM4 is configured for full DNS",
          "@_lang": "en-US"
        }
      ],
      "desc": "Mail Transfer Agents (MTA), such as sendmail and Postfix, are used to listen for incoming mail and transfer the messages to the appropriate user or mail server. If the system is not intended to be a mail server, it is recommended that the MTA be configured to only process local mail.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { dpkg-query --show --showformat='${db:Status-Status} ' 'exim4' 2&gt;/dev/null | grep -q installed; }; then if [ -e \"/etc/exim4/update-exim4.conf.conf\" ] ; then LC_ALL=C sed -i \"/^dc_minimaldns=/d\" \"/etc/exim4/update-exim4.conf.conf\" else touch \"/etc/exim4/update-exim4.conf.conf\" fi cp \"/etc/exim4/update-exim4.conf.conf\" \"/etc/exim4/update-exim4.conf.conf.bak\" # Insert at the end of the file printf '%s ' \"dc_minimaldns=false\" &gt;&gt; \"/etc/exim4/update-exim4.conf.conf\" # Clean up after ourselves. rm \"/etc/exim4/update-exim4.conf.conf.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Harden Local EXIM4 MTA Configuration",
        "gid": "harden_exim4_config",
        "rid": "exim4_readhost",
        "fix_id": "exim4_readhost"
      },
      "id": "harden_exim4_config",
      "title": [
        {
          "#text": "Ensure EXIM4 is configured for no read-host",
          "@_lang": "en-US"
        }
      ],
      "desc": "Mail Transfer Agents (MTA), such as sendmail and Postfix, are used to listen for incoming mail and transfer the messages to the appropriate user or mail server. If the system is not intended to be a mail server, it is recommended that the MTA be configured to only process local mail.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { dpkg-query --show --showformat='${db:Status-Status} ' 'exim4' 2&gt;/dev/null | grep -q installed; }; then if [ -e \"/etc/exim4/update-exim4.conf.conf\" ] ; then LC_ALL=C sed -i \"/^dc_readhost=/d\" \"/etc/exim4/update-exim4.conf.conf\" else touch \"/etc/exim4/update-exim4.conf.conf\" fi cp \"/etc/exim4/update-exim4.conf.conf\" \"/etc/exim4/update-exim4.conf.conf.bak\" # Insert at the end of the file printf '%s ' \"dc_readhost=\" &gt;&gt; \"/etc/exim4/update-exim4.conf.conf\" # Clean up after ourselves. rm \"/etc/exim4/update-exim4.conf.conf.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Harden Local EXIM4 MTA Configuration",
        "gid": "harden_exim4_config",
        "rid": "exim4_relay_domains",
        "fix_id": "exim4_relay_domains"
      },
      "id": "harden_exim4_config",
      "title": [
        {
          "#text": "Ensure EXIM4 is configured for not relaying mail",
          "@_lang": "en-US"
        }
      ],
      "desc": "Mail Transfer Agents (MTA), such as sendmail and Postfix, are used to listen for incoming mail and transfer the messages to the appropriate user or mail server. If the system is not intended to be a mail server, it is recommended that the MTA be configured to only process local mail.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { dpkg-query --show --showformat='${db:Status-Status} ' 'exim4' 2&gt;/dev/null | grep -q installed; }; then if [ -e \"/etc/exim4/update-exim4.conf.conf\" ] ; then LC_ALL=C sed -i \"/^dc_relay_domains=/d\" \"/etc/exim4/update-exim4.conf.conf\" else touch \"/etc/exim4/update-exim4.conf.conf\" fi cp \"/etc/exim4/update-exim4.conf.conf\" \"/etc/exim4/update-exim4.conf.conf.bak\" # Insert at the end of the file printf '%s ' \"dc_relay_domains=\" &gt;&gt; \"/etc/exim4/update-exim4.conf.conf\" # Clean up after ourselves. rm \"/etc/exim4/update-exim4.conf.conf.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Harden Local EXIM4 MTA Configuration",
        "gid": "harden_exim4_config",
        "rid": "exim4_relay_nets",
        "fix_id": "exim4_relay_nets"
      },
      "id": "harden_exim4_config",
      "title": [
        {
          "#text": "Ensure EXIM4 is configured for no relay networks",
          "@_lang": "en-US"
        }
      ],
      "desc": "Mail Transfer Agents (MTA), such as sendmail and Postfix, are used to listen for incoming mail and transfer the messages to the appropriate user or mail server. If the system is not intended to be a mail server, it is recommended that the MTA be configured to only process local mail.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { dpkg-query --show --showformat='${db:Status-Status} ' 'exim4' 2&gt;/dev/null | grep -q installed; }; then if [ -e \"/etc/exim4/update-exim4.conf.conf\" ] ; then LC_ALL=C sed -i \"/^dc_relay_nets=/d\" \"/etc/exim4/update-exim4.conf.conf\" else touch \"/etc/exim4/update-exim4.conf.conf\" fi cp \"/etc/exim4/update-exim4.conf.conf\" \"/etc/exim4/update-exim4.conf.conf.bak\" # Insert at the end of the file printf '%s ' \"dc_relay_nets=\" &gt;&gt; \"/etc/exim4/update-exim4.conf.conf\" # Clean up after ourselves. rm \"/etc/exim4/update-exim4.conf.conf.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Harden Local EXIM4 MTA Configuration",
        "gid": "harden_exim4_config",
        "rid": "exim4_smarthosts",
        "fix_id": "exim4_smarthosts"
      },
      "id": "harden_exim4_config",
      "title": [
        {
          "#text": "Ensure EXIM4 is configured for no smart hosts",
          "@_lang": "en-US"
        }
      ],
      "desc": "Mail Transfer Agents (MTA), such as sendmail and Postfix, are used to listen for incoming mail and transfer the messages to the appropriate user or mail server. If the system is not intended to be a mail server, it is recommended that the MTA be configured to only process local mail.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { dpkg-query --show --showformat='${db:Status-Status} ' 'exim4' 2&gt;/dev/null | grep -q installed; }; then if [ -e \"/etc/exim4/update-exim4.conf.conf\" ] ; then LC_ALL=C sed -i \"/^dc_smarthost=/d\" \"/etc/exim4/update-exim4.conf.conf\" else touch \"/etc/exim4/update-exim4.conf.conf\" fi cp \"/etc/exim4/update-exim4.conf.conf\" \"/etc/exim4/update-exim4.conf.conf.bak\" # Insert at the end of the file printf '%s ' \"dc_smarthost=\" &gt;&gt; \"/etc/exim4/update-exim4.conf.conf\" # Clean up after ourselves. rm \"/etc/exim4/update-exim4.conf.conf.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Harden Local EXIM4 MTA Configuration",
        "gid": "harden_exim4_config",
        "rid": "exim4_use_split_config",
        "fix_id": "exim4_use_split_config"
      },
      "id": "harden_exim4_config",
      "title": [
        {
          "#text": "Ensure EXIM4 is configured to not use split config",
          "@_lang": "en-US"
        }
      ],
      "desc": "Mail Transfer Agents (MTA), such as sendmail and Postfix, are used to listen for incoming mail and transfer the messages to the appropriate user or mail server. If the system is not intended to be a mail server, it is recommended that the MTA be configured to only process local mail.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { dpkg-query --show --showformat='${db:Status-Status} ' 'exim4' 2&gt;/dev/null | grep -q installed; }; then if [ -e \"/etc/exim4/update-exim4.conf.conf\" ] ; then LC_ALL=C sed -i \"/^dc_use_split_config=/d\" \"/etc/exim4/update-exim4.conf.conf\" else touch \"/etc/exim4/update-exim4.conf.conf\" fi cp \"/etc/exim4/update-exim4.conf.conf\" \"/etc/exim4/update-exim4.conf.conf.bak\" # Insert at the end of the file printf '%s ' \"dc_use_split_config=false\" &gt;&gt; \"/etc/exim4/update-exim4.conf.conf\" # Clean up after ourselves. rm \"/etc/exim4/update-exim4.conf.conf.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Xinetd",
        "gid": "inetd_and_xinetd",
        "rid": "package_openbsd-inetd_removed",
        "fix_id": "package_openbsd-inetd_removed"
      },
      "id": "inetd_and_xinetd",
      "title": [
        {
          "#text": "Uninstall openbsd-inetd Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be removed with the following command:",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # CAUTION: This remediation script will remove openbsd-inetd #  from the system, and may remove any packages #  that depend on openbsd-inetd. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"openbsd-inetd\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Xinetd",
        "gid": "inetd_and_xinetd",
        "rid": "package_xinetd_removed",
        "fix_id": "package_xinetd_removed"
      },
      "id": "inetd_and_xinetd",
      "title": [
        {
          "#text": "Uninstall xinetd Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be removed with the following command:",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # CAUTION: This remediation script will remove xinetd #  from the system, and may remove any packages #  that depend on xinetd. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"xinetd\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "System and Software Integrity",
        "gid": "integrity",
        "rid": "package_prelink_removed",
        "fix_id": "package_prelink_removed"
      },
      "id": "integrity",
      "title": [
        {
          "#text": "Disable Prelinking via removing prelink package",
          "@_lang": "en-US"
        }
      ],
      "desc": "The prelinking feature changes binaries in an attempt to decrease their startup time. In order to disable it, run the following command to return binaries to a normal, non-prelinked state:Then remove thepackage.",
      "impact": 0.5,
      "descs": {
        "fix": "if command -v prelink 2&gt;/dev/null &gt;/dev/null; then prelink -ua fi DEBIAN_FRONTEND=noninteractive apt-get remove -y \"prelink\""
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "System and Software Integrity",
        "gid": "integrity",
        "rid": "disable_prelink",
        "fix_id": "disable_prelink"
      },
      "id": "integrity",
      "title": [
        {
          "#text": "Disable Prelinking",
          "@_lang": "en-US"
        }
      ],
      "desc": "The prelinking feature changes binaries in an attempt to decrease their startup time. In order to disable it, change or add the following line inside the file:Next, run the following command to return binaries to a normal, non-prelinked state:",
      "impact": 0.5,
      "descs": {
        "fix": "# prelink not installed if test -e /etc/sysconfig/prelink -o -e /usr/sbin/prelink; then if grep -q ^PRELINKING /etc/sysconfig/prelink then sed -i 's/^PRELINKING[:blank:]*=[:blank:]*[:alpha:]*/PRELINKING=no/' /etc/sysconfig/prelink else printf ' ' &gt;&gt; /etc/sysconfig/prelink printf '%s ' '# Set PRELINKING=no per security requirements' 'PRELINKING=no' &gt;&gt; /etc/sysconfig/prelink fi # Undo previous prelink changes to binaries if prelink is available. if test -x /usr/sbin/prelink; then /usr/sbin/prelink -ua fi fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Inspect and Activate Default Rules",
        "gid": "iptables_activation",
        "rid": "service_ip6tables_enabled",
        "fix_id": "service_ip6tables_enabled"
      },
      "id": "iptables_activation",
      "title": [
        {
          "#text": "Verify ip6tables Enabled if Using IPv6",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice can be enabled with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms var_firewall_package='' if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] || [ \"$var_firewall_package\" == \"iptables\" ]; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" unmask 'ip6tables.service' \"$SYSTEMCTL_EXEC\" start 'ip6tables.service' \"$SYSTEMCTL_EXEC\" enable 'ip6tables.service' else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Inspect and Activate Default Rules",
        "gid": "iptables_activation",
        "rid": "service_iptables_enabled",
        "fix_id": "service_iptables_enabled"
      },
      "id": "iptables_activation",
      "title": [
        {
          "#text": "Verify iptables Enabled",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice can be enabled with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms var_firewall_package='' if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] || [ \"$var_firewall_package\" == \"iptables\" ]; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" unmask 'iptables.service' \"$SYSTEMCTL_EXEC\" start 'iptables.service' \"$SYSTEMCTL_EXEC\" enable 'iptables.service' else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Inspect and Activate Default Rules",
        "gid": "iptables_activation",
        "rid": "set_ip6tables_default_rule",
        "fix_id": "set_ip6tables_default_rule"
      },
      "id": "iptables_activation",
      "title": [
        {
          "#text": "Set Default ip6tables Policy for Incoming Packets",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the default policy to DROP (instead of ACCEPT) for the built-in INPUT chain which processes incoming packets, add or correct the following line in:If changes were required, reload the ip6tables rules:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms var_firewall_package='' if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] || [ \"$var_firewall_package\" == \"iptables\" ]; then sed -i 's/^:INPUT ACCEPT.*/:INPUT DROP [0:0]/g' /etc/sysconfig/ip6tables else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Ensure loopback traffic is configured",
        "gid": "iptables_ensure_loopback_configured",
        "rid": "ip6tables_allow_in_lo",
        "fix_id": "ip6tables_allow_in_lo"
      },
      "id": "iptables_ensure_loopback_configured",
      "title": [
        {
          "#text": "Trafic in on lo is allowed",
          "@_lang": "en-US"
        }
      ],
      "desc": "ip6tables should be configured to allow all inbound traffic on the loopback interface.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms var_firewall_package='' if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { [ \"$var_firewall_package\" == \"iptables\" ]; }; then if ! dpkg-query --show --showformat='${db:Status-Status} ' \"iptables\" 2&gt;/dev/null | grep -q installed; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"iptables\" fi if ! dpkg-query --show --showformat='${db:Status-Status} ' \"iptables-persistent\" 2&gt;/dev/null | grep -q installed; then debconf-set-selections &lt;&lt;&lt; \"iptables-persistent iptables-persistent/autosave_v4 boolean true\" debconf-set-selections &lt;&lt;&lt; \"iptables-persistent iptables-persistent/autosave_v6 boolean true\" DEBIAN_FRONTEND=noninteractive apt-get install -y \"iptables-persistent\" fi ip6tables -C INPUT -i lo -j ACCEPT 2&gt;/dev/null || ip6tables -A INPUT -i lo -j ACCEPT ip6tables-save -t filter &gt; /etc/iptables/rules.v6 else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Ensure loopback traffic is configured",
        "gid": "iptables_ensure_loopback_configured",
        "rid": "ip6tables_allow_out_lo",
        "fix_id": "ip6tables_allow_out_lo"
      },
      "id": "iptables_ensure_loopback_configured",
      "title": [
        {
          "#text": "Traffic out on lo is allowed",
          "@_lang": "en-US"
        }
      ],
      "desc": "ip6tables should be configured to allow all outbound traffic on the loopback interface.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms var_firewall_package='' if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { [ \"$var_firewall_package\" == \"iptables\" ]; }; then if ! dpkg-query --show --showformat='${db:Status-Status} ' \"iptables\" 2&gt;/dev/null | grep -q installed; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"iptables\" fi if ! dpkg-query --show --showformat='${db:Status-Status} ' \"iptables-persistent\" 2&gt;/dev/null | grep -q installed; then debconf-set-selections &lt;&lt;&lt; \"iptables-persistent iptables-persistent/autosave_v4 boolean true\" debconf-set-selections &lt;&lt;&lt; \"iptables-persistent iptables-persistent/autosave_v6 boolean true\" DEBIAN_FRONTEND=noninteractive apt-get install -y \"iptables-persistent\" fi ip6tables -C OUTPUT -o lo -j ACCEPT 2&gt;/dev/null || ip6tables -A OUTPUT -o lo -j ACCEPT ip6tables-save -t filter &gt; /etc/iptables/rules.v6 else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Ensure loopback traffic is configured",
        "gid": "iptables_ensure_loopback_configured",
        "rid": "ip6tables_deny_in_other_for_localhost6",
        "fix_id": "ip6tables_deny_in_other_for_localhost6"
      },
      "id": "iptables_ensure_loopback_configured",
      "title": [
        {
          "#text": "Inbound traffic for ::1/128 on any other interface is denied.",
          "@_lang": "en-US"
        }
      ],
      "desc": "iptables6 should be configured to forbid all traffic for the localhost6 addresses (::1/128) on interfaces other than the designated lo interface.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms var_firewall_package='' if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { [ \"$var_firewall_package\" == \"iptables\" ]; }; then if ! dpkg-query --show --showformat='${db:Status-Status} ' \"iptables\" 2&gt;/dev/null | grep -q installed; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"iptables\" fi if ! dpkg-query --show --showformat='${db:Status-Status} ' \"iptables-persistent\" 2&gt;/dev/null | grep -q installed; then debconf-set-selections &lt;&lt;&lt; \"iptables-persistent iptables-persistent/autosave_v4 boolean true\" debconf-set-selections &lt;&lt;&lt; \"iptables-persistent iptables-persistent/autosave_v6 boolean true\" DEBIAN_FRONTEND=noninteractive apt-get install -y \"iptables-persistent\" fi ip6tables -C INPUT -s ::1 -j DROP 2&gt;/dev/null || ip6tables -A INPUT -s ::1 -j DROP ip6tables-save -t filter &gt; /etc/iptables/rules.v6 else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Ensure loopback traffic is configured",
        "gid": "iptables_ensure_loopback_configured",
        "rid": "iptables_allow_in_lo",
        "fix_id": "iptables_allow_in_lo"
      },
      "id": "iptables_ensure_loopback_configured",
      "title": [
        {
          "#text": "Trafic in on lo is allowed",
          "@_lang": "en-US"
        }
      ],
      "desc": "iptables should be configured to allow all inbound traffic on the loopback interface.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms var_firewall_package='' if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { [ \"$var_firewall_package\" == \"iptables\" ]; }; then if ! dpkg-query --show --showformat='${db:Status-Status} ' \"iptables\" 2&gt;/dev/null | grep -q installed; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"iptables\" fi if ! dpkg-query --show --showformat='${db:Status-Status} ' \"iptables-persistent\" 2&gt;/dev/null | grep -q installed; then debconf-set-selections &lt;&lt;&lt; \"iptables-persistent iptables-persistent/autosave_v4 boolean true\" debconf-set-selections &lt;&lt;&lt; \"iptables-persistent iptables-persistent/autosave_v6 boolean true\" DEBIAN_FRONTEND=noninteractive apt-get install -y \"iptables-persistent\" fi iptables -C INPUT -i lo -j ACCEPT 2&gt;/dev/null || iptables -A INPUT -i lo -j ACCEPT iptables-save -t filter &gt; /etc/iptables/rules.v4 else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Ensure loopback traffic is configured",
        "gid": "iptables_ensure_loopback_configured",
        "rid": "iptables_allow_out_lo",
        "fix_id": "iptables_allow_out_lo"
      },
      "id": "iptables_ensure_loopback_configured",
      "title": [
        {
          "#text": "Traffic out on lo is allowed",
          "@_lang": "en-US"
        }
      ],
      "desc": "iptables should be configured to allow all outbound traffic on the loopback interface.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms var_firewall_package='' if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { [ \"$var_firewall_package\" == \"iptables\" ]; }; then if ! dpkg-query --show --showformat='${db:Status-Status} ' \"iptables\" 2&gt;/dev/null | grep -q installed; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"iptables\" fi if ! dpkg-query --show --showformat='${db:Status-Status} ' \"iptables-persistent\" 2&gt;/dev/null | grep -q installed; then debconf-set-selections &lt;&lt;&lt; \"iptables-persistent iptables-persistent/autosave_v4 boolean true\" debconf-set-selections &lt;&lt;&lt; \"iptables-persistent iptables-persistent/autosave_v6 boolean true\" DEBIAN_FRONTEND=noninteractive apt-get install -y \"iptables-persistent\" fi iptables -C OUTPUT -o lo -j ACCEPT 2&gt;/dev/null || iptables -A OUTPUT -o lo -j ACCEPT iptables-save -t filter &gt; /etc/iptables/rules.v4 else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Ensure loopback traffic is configured",
        "gid": "iptables_ensure_loopback_configured",
        "rid": "iptables_deny_in_other_for_localhost",
        "fix_id": "iptables_deny_in_other_for_localhost"
      },
      "id": "iptables_ensure_loopback_configured",
      "title": [
        {
          "#text": "Inbound traffic for 127.0.0.0/8 on any other interface is denied.",
          "@_lang": "en-US"
        }
      ],
      "desc": "iptables should be configured to forbid all traffic for the localhost addresses (127.0.0.0/8) on interfaces other than the designated lo interface.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms var_firewall_package='' if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { [ \"$var_firewall_package\" == \"iptables\" ]; }; then if ! dpkg-query --show --showformat='${db:Status-Status} ' \"iptables\" 2&gt;/dev/null | grep -q installed; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"iptables\" fi if ! dpkg-query --show --showformat='${db:Status-Status} ' \"iptables-persistent\" 2&gt;/dev/null | grep -q installed; then debconf-set-selections &lt;&lt;&lt; \"iptables-persistent iptables-persistent/autosave_v4 boolean true\" debconf-set-selections &lt;&lt;&lt; \"iptables-persistent iptables-persistent/autosave_v6 boolean true\" DEBIAN_FRONTEND=noninteractive apt-get install -y \"iptables-persistent\" fi iptables -C INPUT -s 127.0.0.0/8 -j DROP 2&gt;/dev/null || iptables -A INPUT -s 127.0.0.0/8 -j DROP iptables-save -t filter &gt; /etc/iptables/rules.v4 else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Strengthen the Default Ruleset",
        "gid": "iptables_ruleset_modifications",
        "rid": "ip6tables_default_deny"
      },
      "id": "iptables_ruleset_modifications",
      "title": [
        {
          "#text": "Ensure default deny firewall policy - iptables6",
          "@_lang": "en-US"
        }
      ],
      "desc": "With a default accept policy the firewall will accept any packet that is not configured to be denied. It is easier to white list acceptable usage than to black list unacceptable usage. Notes:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Strengthen the Default Ruleset",
        "gid": "iptables_ruleset_modifications",
        "rid": "iptables_default_deny"
      },
      "id": "iptables_ruleset_modifications",
      "title": [
        {
          "#text": "Ensure default deny firewall policy",
          "@_lang": "en-US"
        }
      ],
      "desc": "With a default accept policy the firewall will accept any packet that is not configured to be denied. It is easier to white list acceptable usage than to black list unacceptable usage. Notes:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Strengthen the Default Ruleset",
        "gid": "iptables_ruleset_modifications",
        "rid": "set_iptables_default_rule",
        "fix_id": "set_iptables_default_rule"
      },
      "id": "iptables_ruleset_modifications",
      "title": [
        {
          "#text": "Set Default iptables Policy for Incoming Packets",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the default policy to DROP (instead of ACCEPT) for the built-in INPUT chain which processes incoming packets, add or correct the following line in:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms var_firewall_package='' if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] || [ \"$var_firewall_package\" == \"iptables\" ]; then sed -i 's/^:INPUT ACCEPT.*/:INPUT DROP [0:0]/g' /etc/sysconfig/iptables else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Strengthen the Default Ruleset",
        "gid": "iptables_ruleset_modifications",
        "rid": "set_iptables_default_rule_forward",
        "fix_id": "set_iptables_default_rule_forward"
      },
      "id": "iptables_ruleset_modifications",
      "title": [
        {
          "#text": "Set Default iptables Policy for Forwarded Packets",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the default policy to DROP (instead of ACCEPT) for the built-in FORWARD chain which processes packets that will be forwarded from one interface to another, add or correct the following line in:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms var_firewall_package='' if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] || [ \"$var_firewall_package\" == \"iptables\" ]; then sed -i 's/^:FORWARD ACCEPT.*/:FORWARD DROP [0:0]/g' /etc/sysconfig/iptables else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure journald",
        "gid": "journald",
        "rid": "compress_large_logs",
        "fix_id": "compress_large_logs"
      },
      "id": "journald",
      "title": [
        {
          "#text": "Ensure journald is configured to compress large log files",
          "@_lang": "en-US"
        }
      ],
      "desc": "The journald system includes the capability of compressing overly large files to avoid filling up the system with logs or making the logs unmanageably large. Note: The main configuration file /etc/systemd/journald.conf is read before any of the custom *.conf files. If there are custom configs present, they override the main configuration parameters.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/systemd/journald.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*Compress=yes/Id\" \"/etc/systemd/journald.conf\" else touch \"/etc/systemd/journald.conf\" fi cp \"/etc/systemd/journald.conf\" \"/etc/systemd/journald.conf.bak\" # Insert at the end of the file printf '%s ' \"Compress=yes\" &gt;&gt; \"/etc/systemd/journald.conf\" # Clean up after ourselves. rm \"/etc/systemd/journald.conf.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure journald",
        "gid": "journald",
        "rid": "forward_to_syslog",
        "fix_id": "forward_to_syslog"
      },
      "id": "journald",
      "title": [
        {
          "#text": "Ensure journald is configured to send logs to rsyslog",
          "@_lang": "en-US"
        }
      ],
      "desc": "Data from journald may be stored in volatile memory or persisted locally on the server. Utilities exist to accept remote export of journald logs, however, use of the rsyslog service provides a consistent means of log collection and export. Notes: - This recommendation assumes that recommendation 4.2.1.5, \"Ensure rsyslog is configured to send logs to a remote log host\" has been implemented. - As noted in the journald man pages, journald logs may be exported to rsyslog either through the process mentioned here, or through a facility like systemd- journald.service . There are trade-offs involved in each implementation, where ForwardToSyslog will immediately capture all events (and forward to an external log server, if properly configured), but may not capture all boot-up activities. Mechanisms such as systemd-journald.service , on the other hand, will record bootup events, but may delay sending the information to rsyslog, leading to the potential for log manipulation prior to export. Be aware of the limitations of all tools employed to secure a system. - The main configuration file /etc/systemd/journald.conf is read before any of the custom *.conf files. If there are custom configs present, they override the main configuration parameters.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/systemd/journald.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*ForwardToSyslog=yes/Id\" \"/etc/systemd/journald.conf\" else touch \"/etc/systemd/journald.conf\" fi cp \"/etc/systemd/journald.conf\" \"/etc/systemd/journald.conf.bak\" # Insert at the end of the file printf '%s ' \"ForwardToSyslog=yes\" &gt;&gt; \"/etc/systemd/journald.conf\" # Clean up after ourselves. rm \"/etc/systemd/journald.conf.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure journald",
        "gid": "journald",
        "rid": "persistent_storage",
        "fix_id": "persistent_storage"
      },
      "id": "journald",
      "title": [
        {
          "#text": "Ensure journald is configured to write logfiles to persistent disk",
          "@_lang": "en-US"
        }
      ],
      "desc": "Data from journald may be stored in volatile memory or persisted locally on the server. Logs in memory will be lost upon a system reboot. By persisting logs to local disk on the server they are protected from loss. Note: The main configuration file /etc/systemd/journald.conf is read before any of the custom *.conf files. If there are custom configs present, they override the main configuration parameters.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/systemd/journald.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*Storage=persistent/Id\" \"/etc/systemd/journald.conf\" else touch \"/etc/systemd/journald.conf\" fi cp \"/etc/systemd/journald.conf\" \"/etc/systemd/journald.conf.bak\" # Insert at the end of the file printf '%s ' \"Storage=persistent\" &gt;&gt; \"/etc/systemd/journald.conf\" # Clean up after ourselves. rm \"/etc/systemd/journald.conf.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Kerberos",
        "gid": "kerberos",
        "rid": "kerberos_disable_no_keytab",
        "fix_id": "kerberos_disable_no_keytab"
      },
      "id": "kerberos",
      "title": [
        {
          "#text": "Disable Kerberos by removing host keytab",
          "@_lang": "en-US"
        }
      ],
      "desc": "Kerberos is not an approved key distribution method for Common Criteria. To prevent using Kerberos by system daemons, remove the Kerberos keytab files, especially.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then rm -f /etc/*.keytab else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Set Lockouts for Failed Password Attempts",
        "gid": "locking_out_password_attempts",
        "rid": "accounts_password_pam_pwhistory_remember",
        "fix_id": "accounts_password_pam_pwhistory_remember"
      },
      "id": "locking_out_password_attempts",
      "title": [
        {
          "#text": "Limit Password Reuse",
          "@_lang": "en-US"
        }
      ],
      "desc": "Do not allow users to reuse recent passwords. This can be accomplished by using theoption for thePAM modules.In the file, make sure the parametersis present, and that the value for theparameter isor greater. For example:The DoD STIG requirement is 5 passwords.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'libpam-runtime' 2&gt;/dev/null | grep -q installed; then var_password_pam_remember='' pamstr=$(egrep '^password\\s+required\\s+pam_pwhistory\\.so\\b.*\\bremember=' /etc/pam.d/common-password) if [ -z \"$pamstr\" ]; then echo \"password required pam_pwhistory.so remember=${var_password_pam_remember}\" &gt;&gt; /etc/pam.d/common-password else rememb_val=$(echo -n \"$pamstr\" | egrep -o '\\bremember=[0-9]+' | cut -d '=' -f 2) if [ -z \"${rememb_val}\" ] || [ ${rememb_val} -lt ${var_password_pam_remember} ]; then sed -E -i \"s/(^password\\s+required\\s+pam_pwhistory.so\\b.*\\bremember=)[0-9]*/\\1${var_password_pam_remember}/\" /etc/pam.d/common-password fi fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Set Lockouts for Failed Password Attempts",
        "gid": "locking_out_password_attempts",
        "rid": "accounts_password_pam_unix_remember",
        "fix_id": "accounts_password_pam_unix_remember"
      },
      "id": "locking_out_password_attempts",
      "title": [
        {
          "#text": "Limit Password Reuse",
          "@_lang": "en-US"
        }
      ],
      "desc": "Do not allow users to reuse recent passwords. This can be accomplished by using theoption for theorPAM modules.In the file, appendto the line which refers to theormodule, as shown below:The DoD STIG requirement is 5 passwords.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'libpam-runtime' 2&gt;/dev/null | grep -q installed; then var_password_pam_unix_remember=''ensure_pam_module_options '/etc/pam.d/common-password' 'password' '[success=1 default=ignore]' 'pam_unix.so' 'obscure sha512 shadow remember' $var_password_pam_unix_remember $var_password_pam_unix_remember else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Set Lockouts for Failed Password Attempts",
        "gid": "locking_out_password_attempts",
        "rid": "accounts_passwords_pam_faildelay_delay",
        "fix_id": "accounts_passwords_pam_faildelay_delay"
      },
      "id": "locking_out_password_attempts",
      "title": [
        {
          "#text": "Enforce Delay After Failed Logon Attempts",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure the system to introduce a delay after failed logon attempts, add or correct thesettings into make sure itsparameter is at leastor greater. For example:",
      "impact": 0.5,
      "descs": {
        "fix": "var_password_pam_delay=''ensure_pam_module_options '/etc/pam.d/common-auth' 'auth' 'required' 'pam_faildelay.so' 'delay' $var_password_pam_delay $var_password_pam_delay"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Set Lockouts for Failed Password Attempts",
        "gid": "locking_out_password_attempts",
        "rid": "accounts_passwords_pam_tally2",
        "fix_id": "accounts_passwords_pam_tally2"
      },
      "id": "locking_out_password_attempts",
      "title": [
        {
          "#text": "Set Deny For Failed Password Attempts",
          "@_lang": "en-US"
        }
      ],
      "desc": "The Ubuntu 20.04 operating system must lock an account after - at most -consecutive invalid access attempts.",
      "impact": 0.5,
      "descs": {
        "fix": "var_accounts_passwords_pam_tally2_deny='' # Use a non-number regexp to force update of the value of the deny optionensure_pam_module_options '/etc/pam.d/common-auth' 'auth' 'required' 'pam_tally2.so' 'deny' '' \"${var_accounts_passwords_pam_tally2_deny}\" ensure_pam_module_options '/etc/pam.d/common-auth' 'auth' 'required' 'pam_tally2.so' 'onerr' '(fail)' 'fail'ensure_pam_module_options '/etc/pam.d/common-account' 'account' 'required' 'pam_tally2.so' '' '' ''"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Ensure All Logs are Rotated by logrotate",
        "gid": "log_rotation",
        "rid": "ensure_logrotate_activated",
        "fix_id": "ensure_logrotate_activated"
      },
      "id": "log_rotation",
      "title": [
        {
          "#text": "Ensure Logrotate Runs Periodically",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theutility allows for the automatic rotation of log files. The frequency of rotation is specified in, which triggers a cron task. To configure logrotate to run daily, add or correct the following line in:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then LOGROTATE_CONF_FILE=\"/etc/logrotate.conf\" CRON_DAILY_LOGROTATE_FILE=\"/etc/cron.daily/logrotate\" # daily rotation is configured grep -q \"^daily$\" $LOGROTATE_CONF_FILE|| echo \"daily\" &gt;&gt; $LOGROTATE_CONF_FILE # remove any line configuring weekly, monthly or yearly rotation sed -i '/^\\s*\\(weekly\\|monthly\\|yearly\\).*$/d' $LOGROTATE_CONF_FILE # configure cron.daily if not already if ! grep -q \"^[[:space:]]*/usr/sbin/logrotate[[:alnum:][:blank:][:punct:]]*$LOGROTATE_CONF_FILE$\" $CRON_DAILY_LOGROTATE_FILE; then  echo \"#!/bin/sh\" &gt; $CRON_DAILY_LOGROTATE_FILE  echo \"/usr/sbin/logrotate $LOGROTATE_CONF_FILE\" &gt;&gt; $CRON_DAILY_LOGROTATE_FILE fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Ensure All Logs are Rotated by logrotate",
        "gid": "log_rotation",
        "rid": "ensure_logrotate_permissions"
      },
      "id": "log_rotation",
      "title": [
        {
          "#text": "Ensure logrotate assigns appropriate permissions",
          "@_lang": "en-US"
        }
      ],
      "desc": "Log files contain logged information from many services on the system, or on log hosts others as well.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure Syslog",
        "gid": "logging",
        "rid": "package_rsyslog_installed",
        "fix_id": "package_rsyslog_installed"
      },
      "id": "logging",
      "title": [
        {
          "#text": "Ensure rsyslog is Installed",
          "@_lang": "en-US"
        }
      ],
      "desc": "Rsyslog is installed by default. Thepackage can be installed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"rsyslog\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure Syslog",
        "gid": "logging",
        "rid": "service_rsyslog_enabled",
        "fix_id": "service_rsyslog_enabled"
      },
      "id": "logging",
      "title": [
        {
          "#text": "Enable rsyslog Service",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice provides syslog-style logging by default on Ubuntu 20.04. Theservice can be enabled with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" unmask 'rsyslog.service' \"$SYSTEMCTL_EXEC\" start 'rsyslog.service' \"$SYSTEMCTL_EXEC\" enable 'rsyslog.service' else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure Syslog",
        "gid": "logging",
        "rid": "all_logfile_permissions"
      },
      "id": "logging",
      "title": [
        {
          "#text": "Ensure permissions on all logfiles are configured",
          "@_lang": "en-US"
        }
      ],
      "desc": "Log files stored in /var/log/ contain logged information from many services on the system, or on log hosts others as well. Note: You may also need to change the configuration for your logging software or services for any logs that had incorrect permissions.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gtitle": "Configure Syslog",
        "gid": "logging",
        "rid": "ensure_rtc_utc_configuration",
        "fix_id": "ensure_rtc_utc_configuration"
      },
      "id": "logging",
      "title": [
        {
          "#text": "Ensure real-time clock is set to UTC",
          "@_lang": "en-US"
        }
      ],
      "desc": "Ensure that the system real-time clock (RTC) is set to Coordinated Universal Time (UTC).",
      "impact": 0.7,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if timedatectl status | grep -i \"time zone\" | grep -iv 'UTC\\|GMT'; then timedatectl set-timezone UTC fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure Syslog",
        "gid": "logging",
        "rid": "rsyslog_filecreatemode",
        "fix_id": "rsyslog_filecreatemode"
      },
      "id": "logging",
      "title": [
        {
          "#text": "Ensure rsyslog default file permissions configured",
          "@_lang": "en-US"
        }
      ],
      "desc": "rsyslog will create logfiles that do not already exist on the system. This setting controls what permissions will be applied to these newly created files.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sed -i '/^\\s*$FileCreateMode/d' /etc/rsyslog.conf /etc/rsyslog.d/* echo '$FileCreateMode 0640' &gt; /etc/rsyslog.d/99-rsyslog_filecreatemode.conf else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "critical",
        "gtitle": "Mail Server Software",
        "gid": "mail",
        "rid": "service_postfix_enabled",
        "fix_id": "service_postfix_enabled"
      },
      "id": "mail",
      "title": [
        {
          "#text": "Enable Postfix Service",
          "@_lang": "en-US"
        }
      ],
      "desc": "The Postfix mail transfer agent is used for local mail delivery within the system. The default configuration only listens for connections to the default SMTP port (port 25) on the loopback interface (127.0.0.1). It is recommended to leave this service enabled for local mail delivery. Theservice can be enabled with the following command:",
      "impact": 1,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" unmask 'postfix.service' \"$SYSTEMCTL_EXEC\" start 'postfix.service' \"$SYSTEMCTL_EXEC\" enable 'postfix.service' else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Mail Server Software",
        "gid": "mail",
        "rid": "has_nonlocal_mta"
      },
      "id": "mail",
      "title": [
        {
          "#text": "Ensure mail transfer agent is configured for local-only mode",
          "@_lang": "en-US"
        }
      ],
      "desc": "Mail Transfer Agents (MTA), such as sendmail and Postfix, are used to listen for incoming mail and transfer the messages to the appropriate user or mail server. If the system is not intended to be a mail server, it is recommended that the MTA be configured to only process local mail.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "McAfee Host-Based Intrusion Detection Software (HBSS)",
        "gid": "mcafee_hbss_software",
        "rid": "package_MFEhiplsm_installed",
        "fix_id": "package_MFEhiplsm_installed"
      },
      "id": "mcafee_hbss_software",
      "title": [
        {
          "#text": "Install the Host Intrusion Prevention System (HIPS) Module",
          "@_lang": "en-US"
        }
      ],
      "desc": "Install the McAfee Host Intrusion Prevention System (HIPS) Module if it is absolutely necessary. If SELinux is enabled, do not install or enable this module.",
      "impact": 0.5,
      "descs": {
        "fix": "[[packages]] name = \"MFEhiplsm\" version = \"*\""
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "McAfee Endpoint Security Software",
        "gid": "mcafee_security_software",
        "rid": "package_mfetp_installed",
        "fix_id": "package_mfetp_installed"
      },
      "id": "mcafee_security_software",
      "title": [
        {
          "#text": "Install Endpoint Security for Linux Threat Prevention",
          "@_lang": "en-US"
        }
      ],
      "desc": "The operating system must deploy Endpoint Security for Linux Threat Prevention (ENSLTP).",
      "impact": 0.5,
      "descs": {
        "fix": "DEBIAN_FRONTEND=noninteractive apt-get install -y \"mfetp\""
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Restrict Dynamic Mounting and Unmounting of Filesystems",
        "gid": "mounting",
        "rid": "service_autofs_disabled",
        "fix_id": "service_autofs_disabled"
      },
      "id": "mounting",
      "title": [
        {
          "#text": "Disable the Automounter",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thedaemon mounts and unmounts filesystems, such as user home directories shared via NFS, on demand. In addition, autofs can be used to handle removable media, and the default configuration provides the cdrom device as. However, this method of providing access to removable media is not common, so autofs can almost always be disabled if NFS is not in use. Even if NFS is required, it may be possible to configure filesystem mounts statically by editingrather than relying on the automounter.Theservice can be disabled with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" stop 'autofs.service' \"$SYSTEMCTL_EXEC\" disable 'autofs.service' \"$SYSTEMCTL_EXEC\" mask 'autofs.service' # Disable socket activation if we have a unit file for it if \"$SYSTEMCTL_EXEC\" list-unit-files | grep -q '^autofs.socket'; then \"$SYSTEMCTL_EXEC\" stop 'autofs.socket' \"$SYSTEMCTL_EXEC\" mask 'autofs.socket' fi # The service may not be running because it has been started and failed, # so let's reset the state so OVAL checks pass. # Service should be 'inactive', not 'failed' after reboot though. \"$SYSTEMCTL_EXEC\" reset-failed 'autofs.service' || true else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Restrict Dynamic Mounting and Unmounting of Filesystems",
        "gid": "mounting",
        "rid": "kernel_module_cramfs_disabled",
        "fix_id": "kernel_module_cramfs_disabled"
      },
      "id": "mounting",
      "title": [
        {
          "#text": "Disable Mounting of cramfs",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure the system to prevent thekernel module from being loaded, add the following line to a file in the directory:This effectively prevents usage of this uncommon filesystem. Thefilesystem type is a compressed read-only Linux filesystem embedded in small footprint systems. Aimage can be used without having to first decompress the image.",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if LC_ALL=C grep -q -m 1 \"^install cramfs\" /etc/modprobe.d/cramfs.conf ; then    sed -i 's#^install cramfs.*#install cramfs /bin/true#g' /etc/modprobe.d/cramfs.conf else  echo -e \" # Disable per security requirements\" &gt;&gt; /etc/modprobe.d/cramfs.conf  echo \"install cramfs /bin/true\" &gt;&gt; /etc/modprobe.d/cramfs.conf fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Restrict Dynamic Mounting and Unmounting of Filesystems",
        "gid": "mounting",
        "rid": "kernel_module_freevxfs_disabled",
        "fix_id": "kernel_module_freevxfs_disabled"
      },
      "id": "mounting",
      "title": [
        {
          "#text": "Disable Mounting of freevxfs",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure the system to prevent thekernel module from being loaded, add the following line to a file in the directory:This effectively prevents usage of this uncommon filesystem.",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if LC_ALL=C grep -q -m 1 \"^install freevxfs\" /etc/modprobe.d/freevxfs.conf ; then    sed -i 's#^install freevxfs.*#install freevxfs /bin/true#g' /etc/modprobe.d/freevxfs.conf else  echo -e \" # Disable per security requirements\" &gt;&gt; /etc/modprobe.d/freevxfs.conf  echo \"install freevxfs /bin/true\" &gt;&gt; /etc/modprobe.d/freevxfs.conf fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Restrict Dynamic Mounting and Unmounting of Filesystems",
        "gid": "mounting",
        "rid": "kernel_module_hfs_disabled",
        "fix_id": "kernel_module_hfs_disabled"
      },
      "id": "mounting",
      "title": [
        {
          "#text": "Disable Mounting of hfs",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure the system to prevent thekernel module from being loaded, add the following line to a file in the directory:This effectively prevents usage of this uncommon filesystem.",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if LC_ALL=C grep -q -m 1 \"^install hfs\" /etc/modprobe.d/hfs.conf ; then    sed -i 's#^install hfs.*#install hfs /bin/true#g' /etc/modprobe.d/hfs.conf else  echo -e \" # Disable per security requirements\" &gt;&gt; /etc/modprobe.d/hfs.conf  echo \"install hfs /bin/true\" &gt;&gt; /etc/modprobe.d/hfs.conf fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Restrict Dynamic Mounting and Unmounting of Filesystems",
        "gid": "mounting",
        "rid": "kernel_module_hfsplus_disabled",
        "fix_id": "kernel_module_hfsplus_disabled"
      },
      "id": "mounting",
      "title": [
        {
          "#text": "Disable Mounting of hfsplus",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure the system to prevent thekernel module from being loaded, add the following line to a file in the directory:This effectively prevents usage of this uncommon filesystem.",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if LC_ALL=C grep -q -m 1 \"^install hfsplus\" /etc/modprobe.d/hfsplus.conf ; then    sed -i 's#^install hfsplus.*#install hfsplus /bin/true#g' /etc/modprobe.d/hfsplus.conf else  echo -e \" # Disable per security requirements\" &gt;&gt; /etc/modprobe.d/hfsplus.conf  echo \"install hfsplus /bin/true\" &gt;&gt; /etc/modprobe.d/hfsplus.conf fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Restrict Dynamic Mounting and Unmounting of Filesystems",
        "gid": "mounting",
        "rid": "kernel_module_jffs2_disabled",
        "fix_id": "kernel_module_jffs2_disabled"
      },
      "id": "mounting",
      "title": [
        {
          "#text": "Disable Mounting of jffs2",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure the system to prevent thekernel module from being loaded, add the following line to a file in the directory:This effectively prevents usage of this uncommon filesystem.",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if LC_ALL=C grep -q -m 1 \"^install jffs2\" /etc/modprobe.d/jffs2.conf ; then    sed -i 's#^install jffs2.*#install jffs2 /bin/true#g' /etc/modprobe.d/jffs2.conf else  echo -e \" # Disable per security requirements\" &gt;&gt; /etc/modprobe.d/jffs2.conf  echo \"install jffs2 /bin/true\" &gt;&gt; /etc/modprobe.d/jffs2.conf fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Restrict Dynamic Mounting and Unmounting of Filesystems",
        "gid": "mounting",
        "rid": "kernel_module_udf_disabled",
        "fix_id": "kernel_module_udf_disabled"
      },
      "id": "mounting",
      "title": [
        {
          "#text": "Disable Mounting of udf",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure the system to prevent thekernel module from being loaded, add the following line to a file in the directory:This effectively prevents usage of this uncommon filesystem. Thefilesystem type is the universal disk format used to implement the ISO/IEC 13346 and ECMA-167 specifications. This is an open vendor filesystem type for data storage on a broad range of media. This filesystem type is neccessary to support writing DVDs and newer optical disc formats.",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if LC_ALL=C grep -q -m 1 \"^install udf\" /etc/modprobe.d/udf.conf ; then    sed -i 's#^install udf.*#install udf /bin/true#g' /etc/modprobe.d/udf.conf else  echo -e \" # Disable per security requirements\" &gt;&gt; /etc/modprobe.d/udf.conf  echo \"install udf /bin/true\" &gt;&gt; /etc/modprobe.d/udf.conf fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Restrict Dynamic Mounting and Unmounting of Filesystems",
        "gid": "mounting",
        "rid": "kernel_module_usb-storage_disabled",
        "fix_id": "kernel_module_usb-storage_disabled"
      },
      "id": "mounting",
      "title": [
        {
          "#text": "Disable Modprobe Loading of USB Storage Driver",
          "@_lang": "en-US"
        }
      ],
      "desc": "To prevent USB storage devices from being used, configure the kernel module loading system to prevent automatic loading of the USB storage driver. To configure the system to prevent thekernel module from being loaded, add the following line to a file in the directory:This will prevent theprogram from loading themodule, but will not prevent an administrator (or another program) from using theprogram to load the module manually.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if LC_ALL=C grep -q -m 1 \"^install usb-storage\" /etc/modprobe.d/usb-storage.conf ; then    sed -i 's#^install usb-storage.*#install usb-storage /bin/true#g' /etc/modprobe.d/usb-storage.conf else  echo -e \" # Disable per security requirements\" &gt;&gt; /etc/modprobe.d/usb-storage.conf  echo \"install usb-storage /bin/true\" &gt;&gt; /etc/modprobe.d/usb-storage.conf fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "iptables and ip6tables",
        "gid": "network-iptables",
        "rid": "package_iptables-persistent_installed",
        "fix_id": "package_iptables-persistent_installed"
      },
      "id": "network-iptables",
      "title": [
        {
          "#text": "Install iptables-persistent Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be installed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms var_firewall_package='' if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] || [ \"$var_firewall_package\" == \"iptables\" ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"iptables-persistent\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "iptables and ip6tables",
        "gid": "network-iptables",
        "rid": "package_iptables_installed",
        "fix_id": "package_iptables_installed"
      },
      "id": "network-iptables",
      "title": [
        {
          "#text": "Install iptables Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be installed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms var_firewall_package='' if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] || [ \"$var_firewall_package\" == \"iptables\" ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"iptables\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "iptables and ip6tables",
        "gid": "network-iptables",
        "rid": "package_iptables-persistent_removed",
        "fix_id": "package_iptables-persistent_removed"
      },
      "id": "network-iptables",
      "title": [
        {
          "#text": "Remove iptables-persistent Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "The iptables-persistent is a boot-time loader for netfilter rules, iptables plugin. Thepackage can be removed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms var_firewall_package='' if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] || { [ -n \"$var_firewall_package\" ] &amp;&amp; [ \"$var_firewall_package\" != \"iptables\" ] ; }; then # CAUTION: This remediation script will remove iptables-persistent #  from the system, and may remove any packages #  that depend on iptables-persistent. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"iptables-persistent\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "nftables",
        "gid": "network-nftables",
        "rid": "package_nftables_installed",
        "fix_id": "package_nftables_installed"
      },
      "id": "network-nftables",
      "title": [
        {
          "#text": "Install nftables Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be installed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms var_firewall_package='' if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { [ \"$var_firewall_package\" == \"nftables\" ]; }; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"nftables\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "nftables",
        "gid": "network-nftables",
        "rid": "package_nftables_removed",
        "fix_id": "package_nftables_removed"
      },
      "id": "network-nftables",
      "title": [
        {
          "#text": "Remove nftables Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be removed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms var_firewall_package='' if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { { [ -n \"$var_firewall_package\" ] &amp;&amp; [ \"$var_firewall_package\" != \"nftables\" ] ; }; }; then # CAUTION: This remediation script will remove nftables #  from the system, and may remove any packages #  that depend on nftables. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"nftables\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "nftables",
        "gid": "network-nftables",
        "rid": "service_nftables_enabled",
        "fix_id": "service_nftables_enabled"
      },
      "id": "network-nftables",
      "title": [
        {
          "#text": "Verify nftables Enabled",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice can be enabled with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms var_firewall_package='' if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { [ \"$var_firewall_package\" == \"nftables\" ]; }; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" unmask 'nftables.service' \"$SYSTEMCTL_EXEC\" start 'nftables.service' \"$SYSTEMCTL_EXEC\" enable 'nftables.service' else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "nftables",
        "gid": "network-nftables",
        "rid": "nftables_default_deny"
      },
      "id": "network-nftables",
      "title": [
        {
          "#text": "Ensure default deny firewall policy",
          "@_lang": "en-US"
        }
      ],
      "desc": "Base chain policy is the default verdict that will be applied to packets reaching the end of the chain.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "nftables",
        "gid": "network-nftables",
        "rid": "nftables_ensure_base_chain_exist"
      },
      "id": "network-nftables",
      "title": [
        {
          "#text": "Ensure base chains exist",
          "@_lang": "en-US"
        }
      ],
      "desc": "Chains are containers for rules. They exist in two kinds, base chains and regular chains. A base chain is an entry point for packets from the networking stack, a regular chain may be used as jump target and is used for better rule organization.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "nftables",
        "gid": "network-nftables",
        "rid": "nftables_ensure_table_exists"
      },
      "id": "network-nftables",
      "title": [
        {
          "#text": "Ensure a table exists",
          "@_lang": "en-US"
        }
      ],
      "desc": "Tables hold chains. Each table only has one address family and only applies to packets of this family. Tables can have one of five families.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "nftables",
        "gid": "network-nftables",
        "rid": "nftables_permanent_rules"
      },
      "id": "network-nftables",
      "title": [
        {
          "#text": "Ensure nftables rules are permanent",
          "@_lang": "en-US"
        }
      ],
      "desc": "nftables is a subsystem of the Linux kernel providing filtering and classification of network packets/datagrams/frames. The nftables service reads the /etc/nftables.conf file for a nftables file or files to include in the nftables ruleset. A nftables ruleset containing the input, forward, and output base chains allow network traffic to be filtered.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Uncomplicated Firewall (ufw)",
        "gid": "network-ufw",
        "rid": "package_ufw_installed",
        "fix_id": "package_ufw_installed"
      },
      "id": "network-ufw",
      "title": [
        {
          "#text": "Install ufw Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be installed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms var_firewall_package='' if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { [ \"$var_firewall_package\" == \"ufw\" ]; }; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"ufw\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Uncomplicated Firewall (ufw)",
        "gid": "network-ufw",
        "rid": "package_ufw_removed",
        "fix_id": "package_ufw_removed"
      },
      "id": "network-ufw",
      "title": [
        {
          "#text": "Remove ufw Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be removed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms var_firewall_package='' if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { { [ -n \"$var_firewall_package\" ] &amp;&amp; [ \"$var_firewall_package\" != \"ufw\" ] ; }; }; then # CAUTION: This remediation script will remove ufw #  from the system, and may remove any packages #  that depend on ufw. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"ufw\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Uncomplicated Firewall (ufw)",
        "gid": "network-ufw",
        "rid": "service_ufw_enabled",
        "fix_id": "service_ufw_enabled"
      },
      "id": "network-ufw",
      "title": [
        {
          "#text": "Verify ufw Enabled",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice can be enabled with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms var_firewall_package='' if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { [ \"$var_firewall_package\" == \"ufw\" ]; }; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" unmask 'ufw.service' \"$SYSTEMCTL_EXEC\" start 'ufw.service' \"$SYSTEMCTL_EXEC\" enable 'ufw.service' else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Uncomplicated Firewall (ufw)",
        "gid": "network-ufw",
        "rid": "ufw_default_deny"
      },
      "id": "network-ufw",
      "title": [
        {
          "#text": "Ensure default deny firewall policy",
          "@_lang": "en-US"
        }
      ],
      "desc": "A default deny policy on connections ensures that any unconfigured network usage will be rejected. Note: Any port or protocol without a explicit allow before the default deny will be blocked.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Uncomplicated Firewall (ufw)",
        "gid": "network-ufw",
        "rid": "ufw_only_required_services"
      },
      "id": "network-ufw",
      "title": [
        {
          "#text": "Only Allow Authorized Network Services in ufw",
          "@_lang": "en-US"
        }
      ],
      "desc": "Check the firewall configuration for any unnecessary or prohibited functions, ports, protocols, and/or services by running the following command:Ask the System Administrator for the site or program PPSM CLSA. Verify the services allowed by the firewall match the PPSM CLSA.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Uncomplicated Firewall (ufw)",
        "gid": "network-ufw",
        "rid": "ufw_rate_limit"
      },
      "id": "network-ufw",
      "title": [
        {
          "#text": "ufw Must rate-limit network interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "The operating system must configure the uncomplicated firewall to rate-limit impacted network interfaces.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Uncommon Network Protocols",
        "gid": "network-uncommon",
        "rid": "kernel_module_dccp_disabled",
        "fix_id": "kernel_module_dccp_disabled"
      },
      "id": "network-uncommon",
      "title": [
        {
          "#text": "Disable DCCP Support",
          "@_lang": "en-US"
        }
      ],
      "desc": "The Datagram Congestion Control Protocol (DCCP) is a relatively new transport layer protocol, designed to support streaming media and telephony. To configure the system to prevent thekernel module from being loaded, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if LC_ALL=C grep -q -m 1 \"^install dccp\" /etc/modprobe.d/dccp.conf ; then    sed -i 's#^install dccp.*#install dccp /bin/true#g' /etc/modprobe.d/dccp.conf else  echo -e \" # Disable per security requirements\" &gt;&gt; /etc/modprobe.d/dccp.conf  echo \"install dccp /bin/true\" &gt;&gt; /etc/modprobe.d/dccp.conf fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Uncommon Network Protocols",
        "gid": "network-uncommon",
        "rid": "kernel_module_rds_disabled",
        "fix_id": "kernel_module_rds_disabled"
      },
      "id": "network-uncommon",
      "title": [
        {
          "#text": "Disable RDS Support",
          "@_lang": "en-US"
        }
      ],
      "desc": "The Reliable Datagram Sockets (RDS) protocol is a transport layer protocol designed to provide reliable high-bandwidth, low-latency communications between nodes in a cluster. To configure the system to prevent thekernel module from being loaded, add the following line to a file in the directory:",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if LC_ALL=C grep -q -m 1 \"^install rds\" /etc/modprobe.d/rds.conf ; then    sed -i 's#^install rds.*#install rds /bin/true#g' /etc/modprobe.d/rds.conf else  echo -e \" # Disable per security requirements\" &gt;&gt; /etc/modprobe.d/rds.conf  echo \"install rds /bin/true\" &gt;&gt; /etc/modprobe.d/rds.conf fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Uncommon Network Protocols",
        "gid": "network-uncommon",
        "rid": "kernel_module_sctp_disabled",
        "fix_id": "kernel_module_sctp_disabled"
      },
      "id": "network-uncommon",
      "title": [
        {
          "#text": "Disable SCTP Support",
          "@_lang": "en-US"
        }
      ],
      "desc": "The Stream Control Transmission Protocol (SCTP) is a transport layer protocol, designed to support the idea of message-oriented communication, with several streams of messages within one connection. To configure the system to prevent thekernel module from being loaded, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if LC_ALL=C grep -q -m 1 \"^install sctp\" /etc/modprobe.d/sctp.conf ; then    sed -i 's#^install sctp.*#install sctp /bin/true#g' /etc/modprobe.d/sctp.conf else  echo -e \" # Disable per security requirements\" &gt;&gt; /etc/modprobe.d/sctp.conf  echo \"install sctp /bin/true\" &gt;&gt; /etc/modprobe.d/sctp.conf fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Uncommon Network Protocols",
        "gid": "network-uncommon",
        "rid": "kernel_module_tipc_disabled",
        "fix_id": "kernel_module_tipc_disabled"
      },
      "id": "network-uncommon",
      "title": [
        {
          "#text": "Disable TIPC Support",
          "@_lang": "en-US"
        }
      ],
      "desc": "The Transparent Inter-Process Communication (TIPC) protocol is designed to provide communications between nodes in a cluster. To configure the system to prevent thekernel module from being loaded, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if LC_ALL=C grep -q -m 1 \"^install tipc\" /etc/modprobe.d/tipc.conf ; then    sed -i 's#^install tipc.*#install tipc /bin/true#g' /etc/modprobe.d/tipc.conf else  echo -e \" # Disable per security requirements\" &gt;&gt; /etc/modprobe.d/tipc.conf  echo \"install tipc /bin/true\" &gt;&gt; /etc/modprobe.d/tipc.conf fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Network Related Kernel Runtime Parameters for Hosts and Routers",
        "gid": "network_host_and_router_parameters",
        "rid": "sysctl_net_ipv4_conf_all_accept_redirects",
        "fix_id": "sysctl_net_ipv4_conf_all_accept_redirects"
      },
      "id": "network_host_and_router_parameters",
      "title": [
        {
          "#text": "Disable Accepting ICMP Redirects for All IPv4 Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv4_conf_all_accept_redirects_value='' # # Set runtime for net.ipv4.conf.all.accept_redirects # /sbin/sysctl -q -n -w net.ipv4.conf.all.accept_redirects=\"$sysctl_net_ipv4_conf_all_accept_redirects_value\" # # If net.ipv4.conf.all.accept_redirects present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv4.conf.all.accept_redirects = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv4.conf.all.accept_redirects\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv4_conf_all_accept_redirects_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.conf.all.accept_redirects\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv4.conf.all.accept_redirects\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Network Related Kernel Runtime Parameters for Hosts and Routers",
        "gid": "network_host_and_router_parameters",
        "rid": "sysctl_net_ipv4_conf_all_accept_source_route",
        "fix_id": "sysctl_net_ipv4_conf_all_accept_source_route"
      },
      "id": "network_host_and_router_parameters",
      "title": [
        {
          "#text": "Disable Kernel Parameter for Accepting Source-Routed Packets on all IPv4 Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv4_conf_all_accept_source_route_value='' # # Set runtime for net.ipv4.conf.all.accept_source_route # /sbin/sysctl -q -n -w net.ipv4.conf.all.accept_source_route=\"$sysctl_net_ipv4_conf_all_accept_source_route_value\" # # If net.ipv4.conf.all.accept_source_route present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv4.conf.all.accept_source_route = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv4.conf.all.accept_source_route\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv4_conf_all_accept_source_route_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.conf.all.accept_source_route\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv4.conf.all.accept_source_route\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "critical",
        "gtitle": "Network Related Kernel Runtime Parameters for Hosts and Routers",
        "gid": "network_host_and_router_parameters",
        "rid": "sysctl_net_ipv4_conf_all_log_martians",
        "fix_id": "sysctl_net_ipv4_conf_all_log_martians"
      },
      "id": "network_host_and_router_parameters",
      "title": [
        {
          "#text": "Enable Kernel Parameter to Log Martian Packets on all IPv4 Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 1,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv4_conf_all_log_martians_value='' # # Set runtime for net.ipv4.conf.all.log_martians # /sbin/sysctl -q -n -w net.ipv4.conf.all.log_martians=\"$sysctl_net_ipv4_conf_all_log_martians_value\" # # If net.ipv4.conf.all.log_martians present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv4.conf.all.log_martians = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv4.conf.all.log_martians\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv4_conf_all_log_martians_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.conf.all.log_martians\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv4.conf.all.log_martians\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Network Related Kernel Runtime Parameters for Hosts and Routers",
        "gid": "network_host_and_router_parameters",
        "rid": "sysctl_net_ipv4_conf_all_rp_filter",
        "fix_id": "sysctl_net_ipv4_conf_all_rp_filter"
      },
      "id": "network_host_and_router_parameters",
      "title": [
        {
          "#text": "Enable Kernel Parameter to Use Reverse Path Filtering on all IPv4 Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv4_conf_all_rp_filter_value='' # # Set runtime for net.ipv4.conf.all.rp_filter # /sbin/sysctl -q -n -w net.ipv4.conf.all.rp_filter=\"$sysctl_net_ipv4_conf_all_rp_filter_value\" # # If net.ipv4.conf.all.rp_filter present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv4.conf.all.rp_filter = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv4.conf.all.rp_filter\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv4_conf_all_rp_filter_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.conf.all.rp_filter\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv4.conf.all.rp_filter\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Network Related Kernel Runtime Parameters for Hosts and Routers",
        "gid": "network_host_and_router_parameters",
        "rid": "sysctl_net_ipv4_conf_all_secure_redirects",
        "fix_id": "sysctl_net_ipv4_conf_all_secure_redirects"
      },
      "id": "network_host_and_router_parameters",
      "title": [
        {
          "#text": "Disable Kernel Parameter for Accepting Secure ICMP Redirects on all IPv4 Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv4_conf_all_secure_redirects_value='' # # Set runtime for net.ipv4.conf.all.secure_redirects # /sbin/sysctl -q -n -w net.ipv4.conf.all.secure_redirects=\"$sysctl_net_ipv4_conf_all_secure_redirects_value\" # # If net.ipv4.conf.all.secure_redirects present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv4.conf.all.secure_redirects = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv4.conf.all.secure_redirects\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv4_conf_all_secure_redirects_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.conf.all.secure_redirects\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv4.conf.all.secure_redirects\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Network Related Kernel Runtime Parameters for Hosts and Routers",
        "gid": "network_host_and_router_parameters",
        "rid": "sysctl_net_ipv4_conf_default_accept_redirects",
        "fix_id": "sysctl_net_ipv4_conf_default_accept_redirects"
      },
      "id": "network_host_and_router_parameters",
      "title": [
        {
          "#text": "Disable Kernel Parameter for Accepting ICMP Redirects by Default on IPv4 Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv4_conf_default_accept_redirects_value='' # # Set runtime for net.ipv4.conf.default.accept_redirects # /sbin/sysctl -q -n -w net.ipv4.conf.default.accept_redirects=\"$sysctl_net_ipv4_conf_default_accept_redirects_value\" # # If net.ipv4.conf.default.accept_redirects present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv4.conf.default.accept_redirects = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv4.conf.default.accept_redirects\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv4_conf_default_accept_redirects_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.conf.default.accept_redirects\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv4.conf.default.accept_redirects\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Network Related Kernel Runtime Parameters for Hosts and Routers",
        "gid": "network_host_and_router_parameters",
        "rid": "sysctl_net_ipv4_conf_default_accept_source_route",
        "fix_id": "sysctl_net_ipv4_conf_default_accept_source_route"
      },
      "id": "network_host_and_router_parameters",
      "title": [
        {
          "#text": "Disable Kernel Parameter for Accepting Source-Routed Packets on IPv4 Interfaces by Default",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv4_conf_default_accept_source_route_value='' # # Set runtime for net.ipv4.conf.default.accept_source_route # /sbin/sysctl -q -n -w net.ipv4.conf.default.accept_source_route=\"$sysctl_net_ipv4_conf_default_accept_source_route_value\" # # If net.ipv4.conf.default.accept_source_route present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv4.conf.default.accept_source_route = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv4.conf.default.accept_source_route\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv4_conf_default_accept_source_route_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.conf.default.accept_source_route\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv4.conf.default.accept_source_route\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "critical",
        "gtitle": "Network Related Kernel Runtime Parameters for Hosts and Routers",
        "gid": "network_host_and_router_parameters",
        "rid": "sysctl_net_ipv4_conf_default_log_martians",
        "fix_id": "sysctl_net_ipv4_conf_default_log_martians"
      },
      "id": "network_host_and_router_parameters",
      "title": [
        {
          "#text": "Enable Kernel Paremeter to Log Martian Packets on all IPv4 Interfaces by Default",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 1,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv4_conf_default_log_martians_value='' # # Set runtime for net.ipv4.conf.default.log_martians # /sbin/sysctl -q -n -w net.ipv4.conf.default.log_martians=\"$sysctl_net_ipv4_conf_default_log_martians_value\" # # If net.ipv4.conf.default.log_martians present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv4.conf.default.log_martians = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv4.conf.default.log_martians\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv4_conf_default_log_martians_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.conf.default.log_martians\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv4.conf.default.log_martians\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Network Related Kernel Runtime Parameters for Hosts and Routers",
        "gid": "network_host_and_router_parameters",
        "rid": "sysctl_net_ipv4_conf_default_rp_filter",
        "fix_id": "sysctl_net_ipv4_conf_default_rp_filter"
      },
      "id": "network_host_and_router_parameters",
      "title": [
        {
          "#text": "Enable Kernel Parameter to Use Reverse Path Filtering on all IPv4 Interfaces by Default",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv4_conf_default_rp_filter_value='' # # Set runtime for net.ipv4.conf.default.rp_filter # /sbin/sysctl -q -n -w net.ipv4.conf.default.rp_filter=\"$sysctl_net_ipv4_conf_default_rp_filter_value\" # # If net.ipv4.conf.default.rp_filter present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv4.conf.default.rp_filter = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv4.conf.default.rp_filter\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv4_conf_default_rp_filter_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.conf.default.rp_filter\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv4.conf.default.rp_filter\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Network Related Kernel Runtime Parameters for Hosts and Routers",
        "gid": "network_host_and_router_parameters",
        "rid": "sysctl_net_ipv4_conf_default_secure_redirects",
        "fix_id": "sysctl_net_ipv4_conf_default_secure_redirects"
      },
      "id": "network_host_and_router_parameters",
      "title": [
        {
          "#text": "Configure Kernel Parameter for Accepting Secure Redirects By Default",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv4_conf_default_secure_redirects_value='' # # Set runtime for net.ipv4.conf.default.secure_redirects # /sbin/sysctl -q -n -w net.ipv4.conf.default.secure_redirects=\"$sysctl_net_ipv4_conf_default_secure_redirects_value\" # # If net.ipv4.conf.default.secure_redirects present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv4.conf.default.secure_redirects = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv4.conf.default.secure_redirects\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv4_conf_default_secure_redirects_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.conf.default.secure_redirects\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv4.conf.default.secure_redirects\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Network Related Kernel Runtime Parameters for Hosts and Routers",
        "gid": "network_host_and_router_parameters",
        "rid": "sysctl_net_ipv4_icmp_echo_ignore_broadcasts",
        "fix_id": "sysctl_net_ipv4_icmp_echo_ignore_broadcasts"
      },
      "id": "network_host_and_router_parameters",
      "title": [
        {
          "#text": "Enable Kernel Parameter to Ignore ICMP Broadcast Echo Requests on IPv4 Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv4_icmp_echo_ignore_broadcasts_value='' # # Set runtime for net.ipv4.icmp_echo_ignore_broadcasts # /sbin/sysctl -q -n -w net.ipv4.icmp_echo_ignore_broadcasts=\"$sysctl_net_ipv4_icmp_echo_ignore_broadcasts_value\" # # If net.ipv4.icmp_echo_ignore_broadcasts present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv4.icmp_echo_ignore_broadcasts = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv4.icmp_echo_ignore_broadcasts\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv4_icmp_echo_ignore_broadcasts_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.icmp_echo_ignore_broadcasts\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv4.icmp_echo_ignore_broadcasts\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "critical",
        "gtitle": "Network Related Kernel Runtime Parameters for Hosts and Routers",
        "gid": "network_host_and_router_parameters",
        "rid": "sysctl_net_ipv4_icmp_ignore_bogus_error_responses",
        "fix_id": "sysctl_net_ipv4_icmp_ignore_bogus_error_responses"
      },
      "id": "network_host_and_router_parameters",
      "title": [
        {
          "#text": "Enable Kernel Parameter to Ignore Bogus ICMP Error Responses on IPv4 Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 1,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv4_icmp_ignore_bogus_error_responses_value='' # # Set runtime for net.ipv4.icmp_ignore_bogus_error_responses # /sbin/sysctl -q -n -w net.ipv4.icmp_ignore_bogus_error_responses=\"$sysctl_net_ipv4_icmp_ignore_bogus_error_responses_value\" # # If net.ipv4.icmp_ignore_bogus_error_responses present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv4.icmp_ignore_bogus_error_responses = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv4.icmp_ignore_bogus_error_responses\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv4_icmp_ignore_bogus_error_responses_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.icmp_ignore_bogus_error_responses\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv4.icmp_ignore_bogus_error_responses\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Network Related Kernel Runtime Parameters for Hosts and Routers",
        "gid": "network_host_and_router_parameters",
        "rid": "sysctl_net_ipv4_tcp_syncookies",
        "fix_id": "sysctl_net_ipv4_tcp_syncookies"
      },
      "id": "network_host_and_router_parameters",
      "title": [
        {
          "#text": "Enable Kernel Parameter to Use TCP Syncookies on IPv4 Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sysctl_net_ipv4_tcp_syncookies_value='' # # Set runtime for net.ipv4.tcp_syncookies # /sbin/sysctl -q -n -w net.ipv4.tcp_syncookies=\"$sysctl_net_ipv4_tcp_syncookies_value\" # # If net.ipv4.tcp_syncookies present in /etc/sysctl.conf, change value to appropriate value # else, add \"net.ipv4.tcp_syncookies = value\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv4.tcp_syncookies\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$sysctl_net_ipv4_tcp_syncookies_value\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.tcp_syncookies\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv4.tcp_syncookies\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Network Parameters for Hosts Only",
        "gid": "network_host_parameters",
        "rid": "sysctl_net_ipv4_conf_all_send_redirects",
        "fix_id": "sysctl_net_ipv4_conf_all_send_redirects"
      },
      "id": "network_host_parameters",
      "title": [
        {
          "#text": "Disable Kernel Parameter for Sending ICMP Redirects on all IPv4 Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # # Set runtime for net.ipv4.conf.all.send_redirects # /sbin/sysctl -q -n -w net.ipv4.conf.all.send_redirects=\"0\" # # If net.ipv4.conf.all.send_redirects present in /etc/sysctl.conf, change value to \"0\" # else, add \"net.ipv4.conf.all.send_redirects = 0\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv4.conf.all.send_redirects\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"0\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.conf.all.send_redirects\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv4.conf.all.send_redirects\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Network Parameters for Hosts Only",
        "gid": "network_host_parameters",
        "rid": "sysctl_net_ipv4_conf_default_send_redirects",
        "fix_id": "sysctl_net_ipv4_conf_default_send_redirects"
      },
      "id": "network_host_parameters",
      "title": [
        {
          "#text": "Disable Kernel Parameter for Sending ICMP Redirects on all IPv4 Interfaces by Default",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # # Set runtime for net.ipv4.conf.default.send_redirects # /sbin/sysctl -q -n -w net.ipv4.conf.default.send_redirects=\"0\" # # If net.ipv4.conf.default.send_redirects present in /etc/sysctl.conf, change value to \"0\" # else, add \"net.ipv4.conf.default.send_redirects = 0\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv4.conf.default.send_redirects\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"0\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.conf.default.send_redirects\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv4.conf.default.send_redirects\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Network Parameters for Hosts Only",
        "gid": "network_host_parameters",
        "rid": "sysctl_net_ipv4_ip_forward",
        "fix_id": "sysctl_net_ipv4_ip_forward"
      },
      "id": "network_host_parameters",
      "title": [
        {
          "#text": "Disable Kernel Parameter for IP Forwarding on IPv4 Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "To set the runtime status of thekernel parameter, run the following command:To make sure that the setting is persistent, add the following line to a file in the directory:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # # Set runtime for net.ipv4.ip_forward # /sbin/sysctl -q -n -w net.ipv4.ip_forward=\"0\" # # If net.ipv4.ip_forward present in /etc/sysctl.conf, change value to \"0\" # else, add \"net.ipv4.ip_forward = 0\" to /etc/sysctl.conf # # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/sysctl.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^net.ipv4.ip_forward\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"0\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^net.ipv4.ip_forward\\\\&gt;\" \"/etc/sysctl.conf\"; then \"${sed_command[@]}\" \"s/^net.ipv4.ip_forward\\\\&gt;.*/$formatted_output/gi\" \"/etc/sysctl.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/sysctl.conf\" &gt;&gt; \"/etc/sysctl.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/sysctl.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Transport Layer Security Support",
        "gid": "network_ssl",
        "rid": "only_allow_dod_certs"
      },
      "id": "network_ssl",
      "title": [
        {
          "#text": "Only Allow DoD PKI-established CAs",
          "@_lang": "en-US"
        }
      ],
      "desc": "The operating system must only allow the use of DoD PKI-established certificate authorities for verification of the establishment of protected sessions.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Configure NFS Servers",
        "gid": "nfs_configuring_servers",
        "rid": "no_all_squash_exports"
      },
      "id": "nfs_configuring_servers",
      "title": [
        {
          "#text": "Ensure All-Squashing Disabled On All Exports",
          "@_lang": "en-US"
        }
      ],
      "desc": "Themaps all uids and gids to an anonymous user. This should be disabled by removing any instances of theoption from the file.",
      "impact": 0.3,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Ensure loopback traffic is configured",
        "gid": "nftables_ensure_loopback_configured",
        "rid": "nftables_allow_in_lo"
      },
      "id": "nftables_ensure_loopback_configured",
      "title": [
        {
          "#text": "Trafic in on lo is allowed",
          "@_lang": "en-US"
        }
      ],
      "desc": "nftables should be configured to allow all inbound traffic on the loopback interface.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Ensure loopback traffic is configured",
        "gid": "nftables_ensure_loopback_configured",
        "rid": "nftables_deny_in_other_for_localhost"
      },
      "id": "nftables_ensure_loopback_configured",
      "title": [
        {
          "#text": "Inbound traffic for 127.0.0.0/8 on any other interface is denied.",
          "@_lang": "en-US"
        }
      ],
      "desc": "nftables should be configured to forbid all traffic for the localhost addresses (127.0.0.0/8) on interfaces other than the designated lo interface.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Ensure loopback traffic is configured",
        "gid": "nftables_ensure_loopback_configured",
        "rid": "nftables_deny_in_other_for_localhost6"
      },
      "id": "nftables_ensure_loopback_configured",
      "title": [
        {
          "#text": "Inbound traffic for ::1/128 on any other interface is denied.",
          "@_lang": "en-US"
        }
      ],
      "desc": "nftables should be configured to forbid all traffic for the localhost6 addresses (::1/128) on interfaces other than the designated lo interface.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Non-UEFI GRUB2 bootloader configuration",
        "gid": "non-uefi",
        "rid": "file_owner_grub2_cfg",
        "fix_id": "file_owner_grub2_cfg"
      },
      "id": "non-uefi",
      "title": [
        {
          "#text": "Verify /boot/grub/grub.cfg User Ownership",
          "@_lang": "en-US"
        }
      ],
      "desc": "The fileshould be owned by theuser to prevent destruction or modification of the file. To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chown 0 /boot/grub/grub.cfg else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Non-UEFI GRUB2 bootloader configuration",
        "gid": "non-uefi",
        "rid": "file_permissions_grub2_cfg",
        "fix_id": "file_permissions_grub2_cfg"
      },
      "id": "non-uefi",
      "title": [
        {
          "#text": "Verify /boot/grub/grub.cfg Permissions",
          "@_lang": "en-US"
        }
      ],
      "desc": "File permissions forshould be set to 600. To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chmod 0600 /boot/grub/grub.cfg else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gtitle": "Non-UEFI GRUB2 bootloader configuration",
        "gid": "non-uefi",
        "rid": "grub2_password",
        "fix_id": "grub2_password"
      },
      "id": "non-uefi",
      "title": [
        {
          "#text": "Set Boot Loader Password in grub2",
          "@_lang": "en-US"
        }
      ],
      "desc": "The grub2 boot loader should have a superuser account and password protection enabled to protect boot-time settings.Since plaintext passwords are a security risk, generate a hash for the password by running the following command:When prompted, enter the password that was selected.Using the hash from the output, modify thefile with the following content:NOTE: the bootloader superuser account and password MUST differ from the root account and password.Once the superuser password has been added, update thefile by running:",
      "impact": 0.7,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then var_grub2_passwd_hash='' var_grub2_user='' hdrconf=/etc/grub.d/00_header linuxconf=/etc/grub.d/10_linux # This removes all grub lines related to the bootloader password rule # script remove_grub_password_lines() { local file=\"$1\" if [ -z \"${file}\" ]; then return fi local num_lines_file=$(($(wc -l ${file} | cut -d' ' -f1) + 1)) local termtor=\"\" local cat_line_num=0 # We grab the lines in the reverse order so we can remove them and not have # to regenerate the list. for pw_line_num in $(egrep -n \"^password_pbkdf2 \\w+ grub\\.pbkdf2\\.\" \"${file}\" | cut -d: -f1 | tac); do termtor=\"\" # scan line by line up until you find a cat &lt;&lt;*TERMINATOR* pattern (or get to line 1) cat_line_num=$((pw_line_num-1)) while [ ${cat_line_num} -gt 0 ]; do termtor=$(sed -n \"${cat_line_num}\"p ${file} | grep -Po \"(?&lt;=^cat &lt;&lt;)\\s*[^ ]+$\" | sed -E 's/^\\s+//') if [ -n \"${termtor}\" ]; then break fi cat_line_num=$((cat_line_num-1)) done # if no cat id found, we just leave without deleting anything. This format is incorrect. if [ -z \"${termtor}\" ]; then return fi # now scan line by line down until you find a line containing only the *TERMINATOR* (or get to the last line) local term_line_num=$((pw_line_num+1)) while [ ${term_line_num} -le ${num_lines_file} ]; do if [ $(sed -n \"${term_line_num}\"p ${file}) == \"${termtor}\" ]; then break fi term_line_num=$((term_line_num+1)) done # If no terminator found at the end, we just leave without deleting anything. This format is incorrect. if [ ${term_line_num} -gt ${num_lines_file} ]; then return fi # Otherwise we found the first line and the last line to be deleted, so we delete them. sed -i \"${cat_line_num}\",\"${term_line_num}\"d ${file} done } if [ -n \"${var_grub2_passwd_hash/+([[:blank:]])/}\" ] &amp;&amp; [ \"${var_grub2_passwd_hash}\" != \"*\" ]; then tagname=\"USG_GRUB2_PASSWD\" # --unrestricted flag to allow boot without password # Note this still protects against unauthorized entry editing egrep '^CLASS=\".* --unrestricted( .*)?\"' ${linuxconf} if [ $? -ne 0 ]; then sed -i -E 's/^(CLASS=\"[^\"]*)/\\1 --unrestricted/' ${linuxconf} fi remove_grub_password_lines ${hdrconf} # Check if line to append is empty. Otherwise, add to next line. if [ -n \"$(tail -n1 ${hdrconf})\" ]; then echo \"\" &gt;&gt; ${hdrconf} fi echo \"cat &lt;&lt; ${tagname}\" &gt;&gt; ${hdrconf} echo \"set superusers=\\\"${var_grub2_user}\\\"\" &gt;&gt; ${hdrconf} echo \"password_pbkdf2 ${var_grub2_user} ${var_grub2_passwd_hash}\" &gt;&gt; ${hdrconf} echo -n \"${tagname}\" &gt;&gt; ${hdrconf} #cfg=\"/boot/grub/grub.cfg\" update-grub #chown root:root $cfg #chmod og-rwx $cfg fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Network Time Protocol",
        "gid": "ntp",
        "rid": "package_chrony_installed",
        "fix_id": "package_chrony_installed"
      },
      "id": "ntp",
      "title": [
        {
          "#text": "The Chrony package is installed",
          "@_lang": "en-US"
        }
      ],
      "desc": "System time should be synchronized between all systems in an environment. This is typically done by establishing an authoritative time server or set of servers and having all systems synchronize their clocks to them. Thepackage can be installed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms var_time_synchronization_daemon='' if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { [ \"$var_time_synchronization_daemon\" == \"chrony\" ]; }; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"chrony\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gtitle": "Network Time Protocol",
        "gid": "ntp",
        "rid": "package_ntp_installed",
        "fix_id": "package_ntp_installed"
      },
      "id": "ntp",
      "title": [
        {
          "#text": "Install the ntp service",
          "@_lang": "en-US"
        }
      ],
      "desc": "The ntpd service should be installed.",
      "impact": 0.7,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms var_time_synchronization_daemon='' if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { [ \"$var_time_synchronization_daemon\" == \"ntp\" ]; }; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"ntp\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gtitle": "Network Time Protocol",
        "gid": "ntp",
        "rid": "package_timesyncd_installed",
        "fix_id": "package_timesyncd_installed"
      },
      "id": "ntp",
      "title": [
        {
          "#text": "Install the systemd_timesyncd Service",
          "@_lang": "en-US"
        }
      ],
      "desc": "The systemd_timesyncd service should be installed.",
      "impact": 0.7,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"systemd-timesyncd\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Network Time Protocol",
        "gid": "ntp",
        "rid": "package_chrony_removed",
        "fix_id": "package_chrony_removed"
      },
      "id": "ntp",
      "title": [
        {
          "#text": "The Chrony package is removed",
          "@_lang": "en-US"
        }
      ],
      "desc": "System time should be synchronized between all systems in an environment. This is typically done by establishing an authoritative time server or set of servers and having all systems synchronize their clocks to them. Thepackage can be removed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms var_time_synchronization_daemon='' if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { { [ -n \"$var_time_synchronization_daemon\" ] &amp;&amp; [ \"$var_time_synchronization_daemon\" != \"chrony\" ] ; }; }; then # CAUTION: This remediation script will remove chrony #  from the system, and may remove any packages #  that depend on chrony. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"chrony\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gtitle": "Network Time Protocol",
        "gid": "ntp",
        "rid": "package_ntp_removed",
        "fix_id": "package_ntp_removed"
      },
      "id": "ntp",
      "title": [
        {
          "#text": "Remove the ntp package",
          "@_lang": "en-US"
        }
      ],
      "desc": "The ntpd service should be removed.",
      "impact": 0.7,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms var_time_synchronization_daemon='' if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { { [ -n \"$var_time_synchronization_daemon\" ] &amp;&amp; [ \"$var_time_synchronization_daemon\" != \"ntp\" ] ; }; }; then # CAUTION: This remediation script will remove ntp #  from the system, and may remove any packages #  that depend on ntp. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"ntp\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Network Time Protocol",
        "gid": "ntp",
        "rid": "service_chrony_enabled",
        "fix_id": "service_chrony_enabled"
      },
      "id": "ntp",
      "title": [
        {
          "#text": "Enable the Chrony Daemon",
          "@_lang": "en-US"
        }
      ],
      "desc": "chrony is a daemon which implements the Network Time Protocol (NTP) is designed to synchronize system clocks across a variety of systems and use a source that is highly accurate. More information on chrony can be found at. Chrony can be configured to be a client and/or a server. To enable Chronyd service, you can run:This recommendation only applies if chrony is in use on the system.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms var_time_synchronization_daemon='' if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { [ \"$var_time_synchronization_daemon\" == \"chrony\" ]; }; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" unmask 'chrony.service' \"$SYSTEMCTL_EXEC\" start 'chrony.service' \"$SYSTEMCTL_EXEC\" enable 'chrony.service' else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Network Time Protocol",
        "gid": "ntp",
        "rid": "service_chronyd_enabled",
        "fix_id": "service_chronyd_enabled"
      },
      "id": "ntp",
      "title": [
        {
          "#text": "The Chronyd service is enabled",
          "@_lang": "en-US"
        }
      ],
      "desc": "chrony is a daemon which implements the Network Time Protocol (NTP) is designed to synchronize system clocks across a variety of systems and use a source that is highly accurate. More information on chrony can be found at. Chrony can be configured to be a client and/or a server. To enable Chronyd service, you can run:This recommendation only applies if chrony is in use on the system.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" unmask 'chronyd.service' \"$SYSTEMCTL_EXEC\" start 'chronyd.service' \"$SYSTEMCTL_EXEC\" enable 'chronyd.service' else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Network Time Protocol",
        "gid": "ntp",
        "rid": "service_chronyd_or_ntpd_enabled",
        "fix_id": "service_chronyd_or_ntpd_enabled"
      },
      "id": "ntp",
      "title": [
        {
          "#text": "Enable the NTP Daemon",
          "@_lang": "en-US"
        }
      ],
      "desc": "Run the following command to determine the current status of theservice:If the service is running, it should return the following:Note: Thedaemon is enabled by default.Run the following command to determine the current status of theservice:If the service is running, it should return the following:Note: Thedaemon is not enabled by default. Though as mentioned in the previous sections in certain environments thedaemon might be preferred to be used rather than theone. Refer to:for guidance which NTP daemon to choose depending on the environment used.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if dpkg-query --show --showformat='${db:Status-Status} ' \"chrony\" 2&gt;/dev/null | grep -q installed ; then if ! /usr/sbin/pidof ntpd ; then /usr/bin/systemctl enable \"chronyd\" /usr/bin/systemctl start \"chronyd\" # The service may not be running because it has been started and failed, # so let's reset the state so OVAL checks pass. # Service should be 'inactive', not 'failed' after reboot though. /usr/bin/systemctl reset-failed \"chronyd\" fi elif dpkg-query --show --showformat='${db:Status-Status} ' \"ntp\" 2&gt;/dev/null | grep -q installed ; then /usr/bin/systemctl enable \"ntpd\" /usr/bin/systemctl start \"ntpd\" # The service may not be running because it has been started and failed, # so let's reset the state so OVAL checks pass. # Service should be 'inactive', not 'failed' after reboot though. /usr/bin/systemctl reset-failed \"ntpd\" else DEBIAN_FRONTEND=noninteractive apt-get install -y \"chrony\" /usr/bin/systemctl enable \"chronyd\" /usr/bin/systemctl start \"chronyd\" # The service may not be running because it has been started and failed, # so let's reset the state so OVAL checks pass. # Service should be 'inactive', not 'failed' after reboot though. /usr/bin/systemctl reset-failed \"chronyd\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gtitle": "Network Time Protocol",
        "gid": "ntp",
        "rid": "service_ntp_enabled",
        "fix_id": "service_ntp_enabled"
      },
      "id": "ntp",
      "title": [
        {
          "#text": "Enable the NTP Daemon",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice can be enabled with the following command:",
      "impact": 0.7,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms var_time_synchronization_daemon='' if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { [ \"$var_time_synchronization_daemon\" == \"ntp\" ]; }; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" unmask 'ntp.service' \"$SYSTEMCTL_EXEC\" start 'ntp.service' \"$SYSTEMCTL_EXEC\" enable 'ntp.service' else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Network Time Protocol",
        "gid": "ntp",
        "rid": "service_ntpd_enabled",
        "fix_id": "service_ntpd_enabled"
      },
      "id": "ntp",
      "title": [
        {
          "#text": "Enable the NTP Daemon",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice can be enabled with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { dpkg-query --show --showformat='${db:Status-Status} ' 'ntp' 2&gt;/dev/null | grep -q installed; }; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" unmask 'ntpd.service' \"$SYSTEMCTL_EXEC\" start 'ntpd.service' \"$SYSTEMCTL_EXEC\" enable 'ntpd.service' else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gtitle": "Network Time Protocol",
        "gid": "ntp",
        "rid": "service_timesyncd_enabled",
        "fix_id": "service_timesyncd_enabled"
      },
      "id": "ntp",
      "title": [
        {
          "#text": "Enable systemd_timesyncd Service",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice can be enabled with the following command:",
      "impact": 0.7,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" unmask 'systemd-timesyncd.service' \"$SYSTEMCTL_EXEC\" start 'systemd-timesyncd.service' \"$SYSTEMCTL_EXEC\" enable 'systemd-timesyncd.service' else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Network Time Protocol",
        "gid": "ntp",
        "rid": "chronyd_or_ntpd_set_maxpoll",
        "fix_id": "chronyd_or_ntpd_set_maxpoll"
      },
      "id": "ntp",
      "title": [
        {
          "#text": "Configure Time Service Maxpoll Interval",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theshould be configured toinorto continuously poll time servers. To configureinoradd the following after each `server` entry:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { dpkg-query --show --showformat='${db:Status-Status} ' 'chrony' 2&gt;/dev/null | grep -q installed || dpkg-query --show --showformat='${db:Status-Status} ' 'ntp' 2&gt;/dev/null | grep -q installed; }; then var_time_service_set_maxpoll='' pof=\"/bin/pidof\" config_file=\"/etc/ntp.conf\" $pof ntpd || config_file=\"/etc/chrony/chrony.conf\" # Set maxpoll values to var_time_service_set_maxpoll sed -i \"s/^\\(server.*maxpoll\\) [0-9][0-9]*\\(.*\\)$/\\1 $var_time_service_set_maxpoll \\2/\" \"$config_file\" # Add maxpoll to server entries without maxpoll grep \"^server\" \"$config_file\" | grep -v maxpoll | while read -r line ; do sed -i \"s/$line/&amp; maxpoll $var_time_service_set_maxpoll/\" \"$config_file\" done # Add maxpoll to peer entries without maxpoll grep \"^peer\" \"$config_file\" | grep -v maxpoll | while read -r line ; do sed -i \"s/$line/&amp; maxpoll $var_time_service_set_maxpoll/\" \"$config_file\" done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Network Time Protocol",
        "gid": "ntp",
        "rid": "chronyd_run_as_chrony_user",
        "fix_id": "chronyd_run_as_chrony_user"
      },
      "id": "ntp",
      "title": [
        {
          "#text": "Ensure that chronyd is running under chrony user account",
          "@_lang": "en-US"
        }
      ],
      "desc": "chrony is a daemon which implements the Network Time Protocol (NTP). It is designed to synchronize system clocks across a variety of systems and use a source that is highly accurate. More information on chrony can be found at. Chrony can be configured to be a client and/or a server. To ensure that chronyd is running under chrony user account, Add or edit thevariable inis set toor is absent:This recommendation only applies if chrony is in use on the system.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms var_time_synchronization_daemon='' if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { [ \"$var_time_synchronization_daemon\" == \"chrony\" ]; }; then CHRONY_CONF=/etc/chrony/chrony.conf # Include source function library. . /usr/share/scap-security-guide/remediation_functions # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"${CHRONY_CONF}\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^user\") # shellcheck disable=SC2059 printf -v formatted_output \"%s %s\" \"$stripped_key\" \"_chrony\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^user\\\\&gt;\" \"${CHRONY_CONF}\"; then \"${sed_command[@]}\" \"s/^user\\\\&gt;.*/$formatted_output/gi\" \"${CHRONY_CONF}\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"${CHRONY_CONF}\" &gt;&gt; \"${CHRONY_CONF}\" printf '%s ' \"$formatted_output\" &gt;&gt; \"${CHRONY_CONF}\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Network Time Protocol",
        "gid": "ntp",
        "rid": "chronyd_specify_remote_server",
        "fix_id": "chronyd_specify_remote_server"
      },
      "id": "ntp",
      "title": [
        {
          "#text": "A remote time server for Chrony is configured",
          "@_lang": "en-US"
        }
      ],
      "desc": "is a daemon which implements the Network Time Protocol (NTP). It is designed to synchronize system clocks across a variety of systems and use a source that is highly accurate. More information oncan be found at.can be configured to be a client and/or a server. Add or edit server or pool lines toas appropriate:Multiple servers may be configured.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms var_time_synchronization_daemon='' if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ] &amp;&amp; { [ \"$var_time_synchronization_daemon\" == \"chrony\" ]; }; then . /usr/share/scap-security-guide/remediation_functions var_multiple_time_servers='' config_file=\"/etc/chrony/chrony.conf\" if ! grep -q '^[\\s]*(?:server|pool)[\\s]+[\\w]+' \"$config_file\" ; then if ! grep -q '#[[:space:]]*server' \"$config_file\" ; then for server in $(echo \"$var_multiple_time_servers\" | tr ',' ' ') ; do printf ' server %s' \"$server\" &gt;&gt; \"$config_file\" done else sed -i 's/#[ \\t]*server/server/g' \"$config_file\" fi fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Network Time Protocol",
        "gid": "ntp",
        "rid": "chronyd_sync_clock",
        "fix_id": "chronyd_sync_clock"
      },
      "id": "ntp",
      "title": [
        {
          "#text": "Synchronize internal information system clocks",
          "@_lang": "en-US"
        }
      ],
      "desc": "Synchronizing internal information system clocks provides uniformity of time stamps for information systems with multiple system clocks and systems connected over a network.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/chrony/chrony.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*makestep 1 \\-1/Id\" \"/etc/chrony/chrony.conf\" else touch \"/etc/chrony/chrony.conf\" fi cp \"/etc/chrony/chrony.conf\" \"/etc/chrony/chrony.conf.bak\" # Insert at the end of the file printf '%s ' \"makestep 1 -1\" &gt;&gt; \"/etc/chrony/chrony.conf\" # Clean up after ourselves. rm \"/etc/chrony/chrony.conf.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "critical",
        "gtitle": "Network Time Protocol",
        "gid": "ntp",
        "rid": "ntpd_specify_multiple_servers"
      },
      "id": "ntp",
      "title": [
        {
          "#text": "Specify Additional Remote NTP Servers",
          "@_lang": "en-US"
        }
      ],
      "desc": "Additional NTP servers can be specified for time synchronization in the file. To do so, add additional lines of the following form, substituting the IP address or hostname of a remote NTP server for:",
      "impact": 1,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Network Time Protocol",
        "gid": "ntp",
        "rid": "ntpd_specify_remote_server"
      },
      "id": "ntp",
      "title": [
        {
          "#text": "Specify a Remote NTP Server",
          "@_lang": "en-US"
        }
      ],
      "desc": "To specify a remote NTP server for time synchronization, edit the file. Add or correct the following lines, substituting the IP or hostname of a remote NTP server for:This instructs the NTP software to contact that remote server to obtain time data.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Obsolete Services",
        "gid": "obsolete",
        "rid": "package_rsync_removed",
        "fix_id": "package_rsync_removed"
      },
      "id": "obsolete",
      "title": [
        {
          "#text": "Uninstall rsync Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be removed with the following command:",
      "impact": 0.3,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove rsync #  from the system, and may remove any packages #  that depend on rsync. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"rsync\""
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Configure OpenLDAP Clients",
        "gid": "openldap_client",
        "rid": "package_openldap-clients_removed",
        "fix_id": "package_openldap-clients_removed"
      },
      "id": "openldap_client",
      "title": [
        {
          "#text": "Ensure LDAP client is not installed",
          "@_lang": "en-US"
        }
      ],
      "desc": "The Lightweight Directory Access Protocol (LDAP) is a service that provides a method for looking up information from a central database. Thepackage can be removed with the following command:",
      "impact": 0.3,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove ldap-utils #  from the system, and may remove any packages #  that depend on ldap-utils. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"ldap-utils\""
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Configure OpenLDAP Server",
        "gid": "openldap_server",
        "rid": "package_openldap-servers_removed",
        "fix_id": "package_openldap-servers_removed"
      },
      "id": "openldap_server",
      "title": [
        {
          "#text": "Uninstall openldap-servers Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "The slapd package is not installed by default on a Ubuntu 20.04 system. It is needed only by the OpenLDAP server, not by the clients which use LDAP for authentication. If the system is not intended for use as an LDAP Server it should be removed.",
      "impact": 0.3,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove slapd #  from the system, and may remove any packages #  that depend on slapd. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"slapd\""
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Restrict Partition Mount Options",
        "gid": "partitions",
        "rid": "mount_option_dev_shm_nodev",
        "fix_id": "mount_option_dev_shm_nodev"
      },
      "id": "partitions",
      "title": [
        {
          "#text": "Add nodev Option to /dev/shm",
          "@_lang": "en-US"
        }
      ],
      "desc": "Themount option can be used to prevent creation of device files in. Legitimate character and block devices should not exist within temporary directories like. Add theoption to the fourth column offor the line which controls mounting of.",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; theninclude_mount_options_functions function perform_remediation {  # test \"$mount_has_to_exist\" != 'no'  if test \"no\" != 'no'; then   assert_mount_point_in_fstab /dev/shm || { echo \"Not remediating, because there is no record of /dev/shm in /etc/fstab\" &gt;&amp;2; return 1; }  fi  ensure_mount_option_in_fstab \"/dev/shm\" \"nodev\" \"tmpfs\" \"tmpfs\"  ensure_partition_is_mounted \"/dev/shm\" } perform_remediation else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Restrict Partition Mount Options",
        "gid": "partitions",
        "rid": "mount_option_dev_shm_noexec",
        "fix_id": "mount_option_dev_shm_noexec"
      },
      "id": "partitions",
      "title": [
        {
          "#text": "Add noexec Option to /dev/shm",
          "@_lang": "en-US"
        }
      ],
      "desc": "Themount option can be used to prevent binaries from being executed out of. It can be dangerous to allow the execution of binaries from world-writable temporary storage directories such as. Add theoption to the fourth column offor the line which controls mounting of.",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; theninclude_mount_options_functions function perform_remediation {  # test \"$mount_has_to_exist\" != 'no'  if test \"no\" != 'no'; then   assert_mount_point_in_fstab /dev/shm || { echo \"Not remediating, because there is no record of /dev/shm in /etc/fstab\" &gt;&amp;2; return 1; }  fi  ensure_mount_option_in_fstab \"/dev/shm\" \"noexec\" \"tmpfs\" \"tmpfs\"  ensure_partition_is_mounted \"/dev/shm\" } perform_remediation else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Restrict Partition Mount Options",
        "gid": "partitions",
        "rid": "mount_option_dev_shm_nosuid",
        "fix_id": "mount_option_dev_shm_nosuid"
      },
      "id": "partitions",
      "title": [
        {
          "#text": "Add nosuid Option to /dev/shm",
          "@_lang": "en-US"
        }
      ],
      "desc": "Themount option can be used to prevent execution of setuid programs in. The SUID and SGID permissions should not be required in these world-writable directories. Add theoption to the fourth column offor the line which controls mounting of.",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; theninclude_mount_options_functions function perform_remediation {  # test \"$mount_has_to_exist\" != 'no'  if test \"no\" != 'no'; then   assert_mount_point_in_fstab /dev/shm || { echo \"Not remediating, because there is no record of /dev/shm in /etc/fstab\" &gt;&amp;2; return 1; }  fi  ensure_mount_option_in_fstab \"/dev/shm\" \"nosuid\" \"tmpfs\" \"tmpfs\"  ensure_partition_is_mounted \"/dev/shm\" } perform_remediation else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "critical",
        "gtitle": "Restrict Partition Mount Options",
        "gid": "partitions",
        "rid": "mount_option_home_nodev_optional",
        "fix_id": "mount_option_home_nodev_optional"
      },
      "id": "partitions",
      "title": [
        {
          "#text": "Add nodev Option to /home if it exists",
          "@_lang": "en-US"
        }
      ],
      "desc": "Themount option can be used to prevent device files from being created in. Legitimate character and block devices should exist only in thedirectory on the root partition or within chroot jails built for system services. Add theoption to the fourth column offor the line which controls mounting of.",
      "impact": 1,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; theninclude_mount_options_functions function perform_remediation {  # test \"$mount_has_to_exist\" != 'no'  if test \"no\" != 'no'; then   assert_mount_point_in_fstab /home || { echo \"Not remediating, because there is no record of /home in /etc/fstab\" &gt;&amp;2; return 1; }  fi  ensure_mount_option_in_fstab \"/home\" \"nodev\" \"\" \"\"  ensure_partition_is_mounted \"/home\" } perform_remediation else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Restrict Partition Mount Options",
        "gid": "partitions",
        "rid": "mount_option_tmp_nodev_optional",
        "fix_id": "mount_option_tmp_nodev_optional"
      },
      "id": "partitions",
      "title": [
        {
          "#text": "Add nodev Option to /tmp if it exists",
          "@_lang": "en-US"
        }
      ],
      "desc": "Themount option can be used to prevent device files from being created in. Legitimate character and block devices should not exist within temporary directories like. Add theoption to the fourth column offor the line which controls mounting of.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; theninclude_mount_options_functions function perform_remediation {  # test \"$mount_has_to_exist\" != 'no'  if test \"no\" != 'no'; then   assert_mount_point_in_fstab /tmp || { echo \"Not remediating, because there is no record of /tmp in /etc/fstab\" &gt;&amp;2; return 1; }  fi  ensure_mount_option_in_fstab \"/tmp\" \"nodev\" \"\" \"\"  ensure_partition_is_mounted \"/tmp\" } perform_remediation else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Restrict Partition Mount Options",
        "gid": "partitions",
        "rid": "mount_option_tmp_noexec_optional",
        "fix_id": "mount_option_tmp_noexec_optional"
      },
      "id": "partitions",
      "title": [
        {
          "#text": "Add noexec Option to /tmp if it exists",
          "@_lang": "en-US"
        }
      ],
      "desc": "Themount option can be used to prevent binaries from being executed out of. Add theoption to the fourth column offor the line which controls mounting of.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; theninclude_mount_options_functions function perform_remediation {  # test \"$mount_has_to_exist\" != 'no'  if test \"no\" != 'no'; then   assert_mount_point_in_fstab /tmp || { echo \"Not remediating, because there is no record of /tmp in /etc/fstab\" &gt;&amp;2; return 1; }  fi  ensure_mount_option_in_fstab \"/tmp\" \"noexec\" \"\" \"\"  ensure_partition_is_mounted \"/tmp\" } perform_remediation else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Restrict Partition Mount Options",
        "gid": "partitions",
        "rid": "mount_option_tmp_nosuid_optional",
        "fix_id": "mount_option_tmp_nosuid_optional"
      },
      "id": "partitions",
      "title": [
        {
          "#text": "Add nosuid Option to /tmp if it exists",
          "@_lang": "en-US"
        }
      ],
      "desc": "Themount option can be used to prevent execution of setuid programs in. The SUID and SGID permissions should not be required in these world-writable directories. Add theoption to the fourth column offor the line which controls mounting of.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; theninclude_mount_options_functions function perform_remediation {  # test \"$mount_has_to_exist\" != 'no'  if test \"no\" != 'no'; then   assert_mount_point_in_fstab /tmp || { echo \"Not remediating, because there is no record of /tmp in /etc/fstab\" &gt;&amp;2; return 1; }  fi  ensure_mount_option_in_fstab \"/tmp\" \"nosuid\" \"\" \"\"  ensure_partition_is_mounted \"/tmp\" } perform_remediation else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Restrict Partition Mount Options",
        "gid": "partitions",
        "rid": "mount_option_var_tmp_nodev_optional",
        "fix_id": "mount_option_var_tmp_nodev_optional"
      },
      "id": "partitions",
      "title": [
        {
          "#text": "Add nodev Option to /var/tmp if it exists",
          "@_lang": "en-US"
        }
      ],
      "desc": "Themount option can be used to prevent device files from being created in. Legitimate character and block devices should not exist within temporary directories like. Add theoption to the fourth column offor the line which controls mounting of.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; theninclude_mount_options_functions function perform_remediation {  # test \"$mount_has_to_exist\" != 'no'  if test \"no\" != 'no'; then   assert_mount_point_in_fstab /var/tmp || { echo \"Not remediating, because there is no record of /var/tmp in /etc/fstab\" &gt;&amp;2; return 1; }  fi  ensure_mount_option_in_fstab \"/var/tmp\" \"nodev\" \"\" \"\"  ensure_partition_is_mounted \"/var/tmp\" } perform_remediation else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Restrict Partition Mount Options",
        "gid": "partitions",
        "rid": "mount_option_var_tmp_noexec_optional",
        "fix_id": "mount_option_var_tmp_noexec_optional"
      },
      "id": "partitions",
      "title": [
        {
          "#text": "Add noexec Option to /var/tmp if it exists",
          "@_lang": "en-US"
        }
      ],
      "desc": "Themount option can be used to prevent binaries from being executed out of. Add theoption to the fourth column offor the line which controls mounting of.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; theninclude_mount_options_functions function perform_remediation {  # test \"$mount_has_to_exist\" != 'no'  if test \"no\" != 'no'; then   assert_mount_point_in_fstab /var/tmp || { echo \"Not remediating, because there is no record of /var/tmp in /etc/fstab\" &gt;&amp;2; return 1; }  fi  ensure_mount_option_in_fstab \"/var/tmp\" \"noexec\" \"\" \"\"  ensure_partition_is_mounted \"/var/tmp\" } perform_remediation else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Restrict Partition Mount Options",
        "gid": "partitions",
        "rid": "mount_option_var_tmp_nosuid_optional",
        "fix_id": "mount_option_var_tmp_nosuid_optional"
      },
      "id": "partitions",
      "title": [
        {
          "#text": "Add nosuid Option to /var/tmp if it exists",
          "@_lang": "en-US"
        }
      ],
      "desc": "Themount option can be used to prevent execution of setuid programs in. The SUID and SGID permissions should not be required in these world-writable directories. Add theoption to the fourth column offor the line which controls mounting of.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; theninclude_mount_options_functions function perform_remediation {  # test \"$mount_has_to_exist\" != 'no'  if test \"no\" != 'no'; then   assert_mount_point_in_fstab /var/tmp || { echo \"Not remediating, because there is no record of /var/tmp in /etc/fstab\" &gt;&amp;2; return 1; }  fi  ensure_mount_option_in_fstab \"/var/tmp\" \"nosuid\" \"\" \"\"  ensure_partition_is_mounted \"/var/tmp\" } perform_remediation else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Set Password Expiration Parameters",
        "gid": "password_expiration",
        "rid": "accounts_maximum_age_login_defs",
        "fix_id": "accounts_maximum_age_login_defs"
      },
      "id": "password_expiration",
      "title": [
        {
          "#text": "Set Password Maximum Age",
          "@_lang": "en-US"
        }
      ],
      "desc": "To specify password maximum age for new accounts, edit the fileand add or correct the following line:A value of 180 days is sufficient for many environments. The DoD requirement is 60. The profile requirement is.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'login' 2&gt;/dev/null | grep -q installed; then var_accounts_maximum_age_login_defs='' grep -q ^PASS_MAX_DAYS /etc/login.defs &amp;&amp; \\ sed -i \"s/PASS_MAX_DAYS.*/PASS_MAX_DAYS $var_accounts_maximum_age_login_defs/g\" /etc/login.defs if ! [ $? -eq 0 ]; then echo \"PASS_MAX_DAYS $var_accounts_maximum_age_login_defs\" &gt;&gt; /etc/login.defs fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Set Password Expiration Parameters",
        "gid": "password_expiration",
        "rid": "accounts_minimum_age_login_defs",
        "fix_id": "accounts_minimum_age_login_defs"
      },
      "id": "password_expiration",
      "title": [
        {
          "#text": "Set Password Minimum Age",
          "@_lang": "en-US"
        }
      ],
      "desc": "To specify password minimum age for new accounts, edit the fileand add or correct the following line:A value of 1 day is considered sufficient for many environments. The DoD requirement is 1. The profile requirement is.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'login' 2&gt;/dev/null | grep -q installed; then var_accounts_minimum_age_login_defs='' grep -q ^PASS_MIN_DAYS /etc/login.defs &amp;&amp; \\ sed -i \"s/PASS_MIN_DAYS.*/PASS_MIN_DAYS $var_accounts_minimum_age_login_defs/g\" /etc/login.defs if ! [ $? -eq 0 ]; then echo \"PASS_MIN_DAYS $var_accounts_minimum_age_login_defs\" &gt;&gt; /etc/login.defs fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Set Password Expiration Parameters",
        "gid": "password_expiration",
        "rid": "accounts_password_minlen_login_defs"
      },
      "id": "password_expiration",
      "title": [
        {
          "#text": "Set Password Minimum Length in login.defs",
          "@_lang": "en-US"
        }
      ],
      "desc": "To specify password length requirements for new accounts, edit the fileand add or correct the following line:The DoD requirement is. The FISMA requirement is. The profile requirement is. If a program consultsand also another PAM module (such as) during a password change operation, then the most restrictive must be satisfied. See PAM section for more information about enforcing password quality requirements.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Set Password Expiration Parameters",
        "gid": "password_expiration",
        "rid": "accounts_password_set_max_life_existing",
        "fix_id": "accounts_password_set_max_life_existing"
      },
      "id": "password_expiration",
      "title": [
        {
          "#text": "Set Existing Passwords Maximum Age",
          "@_lang": "en-US"
        }
      ],
      "desc": "Configure non-compliant accounts to enforce a 60-day maximum password lifetime restriction by running the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "var_accounts_password_set_max_life_existing='' for usr in $(egrep ^[^:]+:[^\\!*] /etc/shadow | cut -d: -f1); do chage --maxdays \"${var_accounts_password_set_max_life_existing}\" \"${usr}\" done"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Set Password Expiration Parameters",
        "gid": "password_expiration",
        "rid": "accounts_password_set_min_life_existing",
        "fix_id": "accounts_password_set_min_life_existing"
      },
      "id": "password_expiration",
      "title": [
        {
          "#text": "Set Existing Passwords Minimum Age",
          "@_lang": "en-US"
        }
      ],
      "desc": "Configure non-compliant accounts to enforce a 24 hours/1 day minimum password lifetime by running the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "var_accounts_password_set_min_life_existing='' for usr in $(egrep ^[^:]+:[^\\!*] /etc/shadow | cut -d: -f1); do chage --mindays \"${var_accounts_password_set_min_life_existing}\" \"${usr}\" done"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Set Password Expiration Parameters",
        "gid": "password_expiration",
        "rid": "accounts_password_warn_age_login_defs",
        "fix_id": "accounts_password_warn_age_login_defs"
      },
      "id": "password_expiration",
      "title": [
        {
          "#text": "Set Password Warning Age",
          "@_lang": "en-US"
        }
      ],
      "desc": "To specify how many days prior to password expiration that a warning will be issued to users, edit the fileand add or correct the following line:The DoD requirement is 7. The profile requirement is.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'login' 2&gt;/dev/null | grep -q installed; then var_accounts_password_warn_age_login_defs='' grep -q ^PASS_WARN_AGE /etc/login.defs &amp;&amp; \\ sed -i \"s/PASS_WARN_AGE.*/PASS_WARN_AGE\\t$var_accounts_password_warn_age_login_defs/g\" /etc/login.defs if ! [ $? -eq 0 ] then echo -e \"PASS_WARN_AGE\\t$var_accounts_password_warn_age_login_defs\" &gt;&gt; /etc/login.defs fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Set Password Expiration Parameters",
        "gid": "password_expiration",
        "rid": "last_change_date_in_past"
      },
      "id": "password_expiration",
      "title": [
        {
          "#text": "Ensure all users last password change date is in the past",
          "@_lang": "en-US"
        }
      ],
      "desc": "All users should have a password change date in the past.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Set Password Quality Requirements with pam_pwquality",
        "gid": "password_quality_pwquality",
        "rid": "accounts_password_pam_dcredit",
        "fix_id": "accounts_password_pam_dcredit"
      },
      "id": "password_quality_pwquality",
      "title": [
        {
          "#text": "Ensure PAM Enforces Password Requirements - Minimum Digit Characters",
          "@_lang": "en-US"
        }
      ],
      "desc": "The pam_pwquality module'sparameter controls requirements for usage of digits in a password. When set to a negative number, any password will be required to contain that many digits. When set to a positive number, pam_pwquality will grant +1 additional length credit for each digit. Modify thesetting into require the use of a digit in passwords.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'libpam-runtime' 2&gt;/dev/null | grep -q installed; then var_password_pam_dcredit='' # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/security/pwquality.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^dcredit\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_dcredit\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^dcredit\\\\&gt;\" \"/etc/security/pwquality.conf\"; then \"${sed_command[@]}\" \"s/^dcredit\\\\&gt;.*/$formatted_output/gi\" \"/etc/security/pwquality.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/security/pwquality.conf\" &gt;&gt; \"/etc/security/pwquality.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/security/pwquality.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Set Password Quality Requirements with pam_pwquality",
        "gid": "password_quality_pwquality",
        "rid": "accounts_password_pam_dictcheck",
        "fix_id": "accounts_password_pam_dictcheck"
      },
      "id": "password_quality_pwquality",
      "title": [
        {
          "#text": "Ensure PAM Enforces Password Requirements - Prevent the Use of Dictionary Words",
          "@_lang": "en-US"
        }
      ],
      "desc": "The pam_pwquality module'scheck if passwords contains dictionary words. Whenis set topasswords will be checked for dictionary words.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'libpam-runtime' 2&gt;/dev/null | grep -q installed; then var_password_pam_dictcheck='' # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/security/pwquality.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^dictcheck\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_dictcheck\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^dictcheck\\\\&gt;\" \"/etc/security/pwquality.conf\"; then \"${sed_command[@]}\" \"s/^dictcheck\\\\&gt;.*/$formatted_output/gi\" \"/etc/security/pwquality.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/security/pwquality.conf\" &gt;&gt; \"/etc/security/pwquality.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/security/pwquality.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Set Password Quality Requirements with pam_pwquality",
        "gid": "password_quality_pwquality",
        "rid": "accounts_password_pam_difok",
        "fix_id": "accounts_password_pam_difok"
      },
      "id": "password_quality_pwquality",
      "title": [
        {
          "#text": "Ensure PAM Enforces Password Requirements - Minimum Different Characters",
          "@_lang": "en-US"
        }
      ],
      "desc": "The pam_pwquality module'sparameter sets the number of characters in a password that must not be present in and old password during a password change.Modify thesetting into equalto require differing characters when changing passwords.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'libpam-runtime' 2&gt;/dev/null | grep -q installed; then var_password_pam_difok='' # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/security/pwquality.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^difok\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_difok\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^difok\\\\&gt;\" \"/etc/security/pwquality.conf\"; then \"${sed_command[@]}\" \"s/^difok\\\\&gt;.*/$formatted_output/gi\" \"/etc/security/pwquality.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/security/pwquality.conf\" &gt;&gt; \"/etc/security/pwquality.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/security/pwquality.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Set Password Quality Requirements with pam_pwquality",
        "gid": "password_quality_pwquality",
        "rid": "accounts_password_pam_enforcing",
        "fix_id": "accounts_password_pam_enforcing"
      },
      "id": "password_quality_pwquality",
      "title": [
        {
          "#text": "Ensure PAM Enforces Password Requirements - Enforcing",
          "@_lang": "en-US"
        }
      ],
      "desc": "Verify that the operating system uses \"pwquality\" to enforce the password complexity rules. Verify the pwquality module is being enforced by operating system by running the following command:If the value of \"enforcing\" is not \"1\" or the line is commented out, this is a finding.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'libpam-runtime' 2&gt;/dev/null | grep -q installed; then if [ -e \"/etc/security/pwquality.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*enforcing = 1/Id\" \"/etc/security/pwquality.conf\" else touch \"/etc/security/pwquality.conf\" fi cp \"/etc/security/pwquality.conf\" \"/etc/security/pwquality.conf.bak\" # Insert at the end of the file printf '%s ' \"enforcing = 1\" &gt;&gt; \"/etc/security/pwquality.conf\" # Clean up after ourselves. rm \"/etc/security/pwquality.conf.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Set Password Quality Requirements with pam_pwquality",
        "gid": "password_quality_pwquality",
        "rid": "accounts_password_pam_lcredit",
        "fix_id": "accounts_password_pam_lcredit"
      },
      "id": "password_quality_pwquality",
      "title": [
        {
          "#text": "Ensure PAM Enforces Password Requirements - Minimum Lowercase Characters",
          "@_lang": "en-US"
        }
      ],
      "desc": "The pam_pwquality module'sparameter controls requirements for usage of lowercase letters in a password. When set to a negative number, any password will be required to contain that many lowercase characters. When set to a positive number, pam_pwquality will grant +1 additional length credit for each lowercase character. Modify thesetting into require the use of a lowercase character in passwords.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'libpam-runtime' 2&gt;/dev/null | grep -q installed; then var_password_pam_lcredit='' # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/security/pwquality.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^lcredit\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_lcredit\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^lcredit\\\\&gt;\" \"/etc/security/pwquality.conf\"; then \"${sed_command[@]}\" \"s/^lcredit\\\\&gt;.*/$formatted_output/gi\" \"/etc/security/pwquality.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/security/pwquality.conf\" &gt;&gt; \"/etc/security/pwquality.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/security/pwquality.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Set Password Quality Requirements with pam_pwquality",
        "gid": "password_quality_pwquality",
        "rid": "accounts_password_pam_minclass",
        "fix_id": "accounts_password_pam_minclass"
      },
      "id": "password_quality_pwquality",
      "title": [
        {
          "#text": "Ensure PAM Enforces Password Requirements - Minimum Different Categories",
          "@_lang": "en-US"
        }
      ],
      "desc": "The pam_pwquality module'sparameter controls requirements for usage of different character classes, or types, of character that must exist in a password before it is considered valid. For example, setting this value to three (3) requires that any password must have characters from at least three different categories in order to be approved. The default value is zero (0), meaning there are no required classes. There are four categories available:Modify thesetting inentry to requirediffering categories of characters when changing passwords.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'libpam-runtime' 2&gt;/dev/null | grep -q installed; then var_password_pam_minclass='' # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/security/pwquality.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^minclass\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_minclass\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^minclass\\\\&gt;\" \"/etc/security/pwquality.conf\"; then \"${sed_command[@]}\" \"s/^minclass\\\\&gt;.*/$formatted_output/gi\" \"/etc/security/pwquality.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/security/pwquality.conf\" &gt;&gt; \"/etc/security/pwquality.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/security/pwquality.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Set Password Quality Requirements with pam_pwquality",
        "gid": "password_quality_pwquality",
        "rid": "accounts_password_pam_minlen",
        "fix_id": "accounts_password_pam_minlen"
      },
      "id": "password_quality_pwquality",
      "title": [
        {
          "#text": "Ensure PAM Enforces Password Requirements - Minimum Length",
          "@_lang": "en-US"
        }
      ],
      "desc": "The pam_pwquality module'sparameter controls requirements for minimum characters required in a password. Addafter pam_pwquality to set minimum password length requirements.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'libpam-runtime' 2&gt;/dev/null | grep -q installed; then var_password_pam_minlen='' # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/security/pwquality.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^minlen\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_minlen\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^minlen\\\\&gt;\" \"/etc/security/pwquality.conf\"; then \"${sed_command[@]}\" \"s/^minlen\\\\&gt;.*/$formatted_output/gi\" \"/etc/security/pwquality.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/security/pwquality.conf\" &gt;&gt; \"/etc/security/pwquality.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/security/pwquality.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Set Password Quality Requirements with pam_pwquality",
        "gid": "password_quality_pwquality",
        "rid": "accounts_password_pam_ocredit",
        "fix_id": "accounts_password_pam_ocredit"
      },
      "id": "password_quality_pwquality",
      "title": [
        {
          "#text": "Ensure PAM Enforces Password Requirements - Minimum Special Characters",
          "@_lang": "en-US"
        }
      ],
      "desc": "The pam_pwquality module'sparameter controls requirements for usage of special (or \"other\") characters in a password. When set to a negative number, any password will be required to contain that many special characters. When set to a positive number, pam_pwquality will grant +1 additional length credit for each special character. Modify thesetting into equalto require use of a special character in passwords.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'libpam-runtime' 2&gt;/dev/null | grep -q installed; then var_password_pam_ocredit='' # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/security/pwquality.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^ocredit\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_ocredit\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^ocredit\\\\&gt;\" \"/etc/security/pwquality.conf\"; then \"${sed_command[@]}\" \"s/^ocredit\\\\&gt;.*/$formatted_output/gi\" \"/etc/security/pwquality.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/security/pwquality.conf\" &gt;&gt; \"/etc/security/pwquality.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/security/pwquality.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Set Password Quality Requirements with pam_pwquality",
        "gid": "password_quality_pwquality",
        "rid": "accounts_password_pam_retry",
        "fix_id": "accounts_password_pam_retry"
      },
      "id": "password_quality_pwquality",
      "title": [
        {
          "#text": "Ensure PAM Enforces Password Requirements - Authentication Retry Prompts Permitted Per-Session",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure the number of retry prompts that are permitted per-session: Edit thestatement into show, or a lower value if site policy is more restrictive. The DoD requirement is a maximum of 3 prompts per session.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'libpam-runtime' 2&gt;/dev/null | grep -q installed; then var_password_pam_retry=''ensure_pam_module_options '/etc/pam.d/common-password' 'password' 'requisite' 'pam_pwquality.so' 'retry' $var_password_pam_retry $var_password_pam_retry else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Set Password Quality Requirements with pam_pwquality",
        "gid": "password_quality_pwquality",
        "rid": "accounts_password_pam_ucredit",
        "fix_id": "accounts_password_pam_ucredit"
      },
      "id": "password_quality_pwquality",
      "title": [
        {
          "#text": "Ensure PAM Enforces Password Requirements - Minimum Uppercase Characters",
          "@_lang": "en-US"
        }
      ],
      "desc": "The pam_pwquality module'sparameter controls requirements for usage of uppercase letters in a password. When set to a negative number, any password will be required to contain that many uppercase characters. When set to a positive number, pam_pwquality will grant +1 additional length credit for each uppercase character. Modify thesetting into require the use of an uppercase character in passwords.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'libpam-runtime' 2&gt;/dev/null | grep -q installed; then var_password_pam_ucredit='' # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/security/pwquality.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^ucredit\") # shellcheck disable=SC2059 printf -v formatted_output \"%s = %s\" \"$stripped_key\" \"$var_password_pam_ucredit\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^ucredit\\\\&gt;\" \"/etc/security/pwquality.conf\"; then \"${sed_command[@]}\" \"s/^ucredit\\\\&gt;.*/$formatted_output/gi\" \"/etc/security/pwquality.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/security/pwquality.conf\" &gt;&gt; \"/etc/security/pwquality.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/security/pwquality.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Proper Storage and Existence of Password Hashes",
        "gid": "password_storage",
        "rid": "accounts_password_all_shadowed"
      },
      "id": "password_storage",
      "title": [
        {
          "#text": "Verify All Account Password Hashes are Shadowed",
          "@_lang": "en-US"
        }
      ],
      "desc": "If any password hashes are stored in(in the second field, instead of anor), the cause of this misconfiguration should be investigated. The account should have its password reset and the hash should be properly stored, or the account should be deleted entirely.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Proper Storage and Existence of Password Hashes",
        "gid": "password_storage",
        "rid": "accounts_password_all_shadowed_sha512",
        "fix_id": "accounts_password_all_shadowed_sha512"
      },
      "id": "password_storage",
      "title": [
        {
          "#text": "Verify All Account Password Hashes are Shadowed with SHA512",
          "@_lang": "en-US"
        }
      ],
      "desc": "Verify the operating system requires the shadow password suite configuration be set to encrypt interactive user passwords using a strong cryptographic hash. Check that the interactive user account passwords are using a strong password hash with the following command:Password hashesorindicate inactive accounts not available for logon and are not evaluated. If any interactive user password hash does not begin with, this is a finding.",
      "impact": 0.5,
      "descs": {
        "fix": "if ! grep '^password\\s\\+.*\\bpam_unix\\.so\\b.*\\bsha512\\b' /etc/pam.d/common-password; then sed -i 's/\\(password\\b.*\\bpam_unix\\.so\\b.*\\)$/\\1 sha512/' /etc/pam.d/common-password fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Proper Storage and Existence of Password Hashes",
        "gid": "password_storage",
        "rid": "all_etc_passwd_groups_exist_in_etc_group",
        "fix_id": "all_etc_passwd_groups_exist_in_etc_group"
      },
      "id": "password_storage",
      "title": [
        {
          "#text": "Ensure all groups in /etc/passwd exist in /etc/group",
          "@_lang": "en-US"
        }
      ],
      "desc": "Over time, system administration errors and changes can lead to groups being defined in /etc/passwd but not in /etc/group . Groups defined in the /etc/passwd file but not in the /etc/group file pose a threat to system security since group permissions are not properly managed.",
      "impact": 0.5,
      "descs": {
        "fix": "for i in $(cut -s -d: -f4 /etc/passwd | sort -u ); do grep -q -P \"^.*?:[^:]*:$i:\" /etc/group if [ $? -ne 0 ]; then groupadd \"$i\" fi done"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Proper Storage and Existence of Password Hashes",
        "gid": "password_storage",
        "rid": "ensure_shadow_group_empty"
      },
      "id": "password_storage",
      "title": [
        {
          "#text": "Ensure shadow group is empty",
          "@_lang": "en-US"
        }
      ],
      "desc": "The shadow group allows system programs which require access the ability to read the /etc/shadow file. No users should be assigned to the shadow group. Any users assigned to the shadow group would be granted read access to the /etc/shadow file. If attackers can gain read access to the /etc/shadow file, they can easily run a password cracking program against the hashed passwords to break them. Other security information that is stored in the /etc/shadow file (such as expiration) could also be useful to subvert additional user accounts.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Proper Storage and Existence of Password Hashes",
        "gid": "password_storage",
        "rid": "ensure_sudo_group_restricted"
      },
      "id": "password_storage",
      "title": [
        {
          "#text": "Ensure sudo group has only necessary members",
          "@_lang": "en-US"
        }
      ],
      "desc": "Developers and implementers can increase the assurance in security functions by employing well-defined security policy models; structured, disciplined, and rigorous hardware and software development techniques; and sound system/security engineering principles. Implementation may include isolation of memory space and libraries. The Ubuntu operating system restricts access to security functions through the use of access control mechanisms and by implementing least privilege capabilities.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Verify Proper Storage and Existence of Password Hashes",
        "gid": "password_storage",
        "rid": "gid_passwd_group_same"
      },
      "id": "password_storage",
      "title": [
        {
          "#text": "All GIDs referenced in /etc/passwd must be defined in /etc/group",
          "@_lang": "en-US"
        }
      ],
      "desc": "Add a group to the system for each GID referenced without a corresponding group.",
      "impact": 0.3,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Proper Storage and Existence of Password Hashes",
        "gid": "password_storage",
        "rid": "no_duplicate_gids"
      },
      "id": "password_storage",
      "title": [
        {
          "#text": "Ensure no duplicate GIDs exist",
          "@_lang": "en-US"
        }
      ],
      "desc": "Although the groupadd program will not let you create a duplicate Group ID (GID), it is possible for an administrator to manually edit the /etc/group file and change the GID field. User groups must be assigned unique GIDs for accountability and to ensure appropriate access protections.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Proper Storage and Existence of Password Hashes",
        "gid": "password_storage",
        "rid": "no_duplicate_group_names"
      },
      "id": "password_storage",
      "title": [
        {
          "#text": "Ensure no duplicate group names exist",
          "@_lang": "en-US"
        }
      ],
      "desc": "Although the groupadd program will not let you create a duplicate group name, it is possible for an administrator to manually edit the /etc/group file and change the group name. If a group is assigned a duplicate group name, it will create and have access to files with the first GID for that group in /etc/group . Effectively, the GID is shared, which is a security problem.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Proper Storage and Existence of Password Hashes",
        "gid": "password_storage",
        "rid": "no_duplicate_uids"
      },
      "id": "password_storage",
      "title": [
        {
          "#text": "Ensure no duplicate UIDs exist",
          "@_lang": "en-US"
        }
      ],
      "desc": "Although the useradd program will not let you create a duplicate User ID (UID), it is possible for an administrator to manually edit the /etc/passwd file and change the UID field. Users must be assigned unique UIDs for accountability and to ensure appropriate access protections.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Proper Storage and Existence of Password Hashes",
        "gid": "password_storage",
        "rid": "no_duplicate_user_names"
      },
      "id": "password_storage",
      "title": [
        {
          "#text": "Ensure no duplicate user names exist",
          "@_lang": "en-US"
        }
      ],
      "desc": "Although the useradd program will not let you create a duplicate user name, it is possible for an administrator to manually edit the /etc/passwd file and change the user name. If a user is assigned a duplicate user name, it will create and have access to files with the first UID for that username in /etc/passwd . For example, if \"test4\" has a UID of 1000 and a subsequent \"test4\" entry has a UID of 2000, logging in as \"test4\" will use UID 1000. Effectively, the UID is shared, which is a security problem.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gtitle": "Verify Proper Storage and Existence of Password Hashes",
        "gid": "password_storage",
        "rid": "no_empty_password_field",
        "fix_id": "no_empty_password_field"
      },
      "id": "password_storage",
      "title": [
        {
          "#text": "Lock Accounts With Empty Password Field",
          "@_lang": "en-US"
        }
      ],
      "desc": "If an account is configured for password authentication but does not have an assigned password, it may be possible to log into the account without authentication. Lock all accounts with empty password field onto prevent logins with empty passwords.",
      "impact": 0.7,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then for usr in $(cat /etc/shadow | awk -F: '($2 == \"\" ) { print $1 }'); do passwd -l ${usr} done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gtitle": "Verify Proper Storage and Existence of Password Hashes",
        "gid": "password_storage",
        "rid": "no_empty_passwords",
        "fix_id": "no_empty_passwords"
      },
      "id": "password_storage",
      "title": [
        {
          "#text": "Prevent Login to Accounts With Empty Password",
          "@_lang": "en-US"
        }
      ],
      "desc": "If an account is configured for password authentication but does not have an assigned password, it may be possible to log into the account without authentication. Remove any instances of theinto prevent logins with empty passwords. Note that this rule is not applicable for systems running within a container. Having user with empty password within a container is not considered a risk, because it should not be possible to directly login into a container anyway.",
      "impact": 0.7,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sed --follow-symlinks -i 's/\\&lt;nullok\\&gt;//g' /etc/pam.d/system-auth sed --follow-symlinks -i 's/\\&lt;nullok\\&gt;//g' /etc/pam.d/password-auth else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Proper Storage and Existence of Password Hashes",
        "gid": "password_storage",
        "rid": "no_group_world_readable_netrc_files",
        "fix_id": "no_group_world_readable_netrc_files"
      },
      "id": "password_storage",
      "title": [
        {
          "#text": "Ensure users' .netrc Files are not group or world accessible",
          "@_lang": "en-US"
        }
      ],
      "desc": "While the system administrator can establish secure permissions for users' .netrc files, the users can easily override these. files may contain unencrypted passwords that may be used to attack other systems.",
      "impact": 0.5,
      "descs": {
        "fix": "fetch_users_and_homedir |\\ while read user dir; do chmod -f og-rwx \"${dir}/.netrc\" done"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Proper Storage and Existence of Password Hashes",
        "gid": "password_storage",
        "rid": "no_netrc_files"
      },
      "id": "password_storage",
      "title": [
        {
          "#text": "Verify No netrc Files Exist",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thefiles contain login information used to auto-login into FTP servers and reside in the user's home directory. These files may contain unencrypted passwords to remote FTP servers making them susceptible to access by unauthorized users and should not be used. Anyfiles should be removed.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "gid": "permissions_important_account_files",
        "rid": "file_groupowner_backup_etc_group",
        "fix_id": "file_groupowner_backup_etc_group"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify Group Who Owns Backup group File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chgrp 0 /etc/group-"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "gid": "permissions_important_account_files",
        "rid": "file_groupowner_backup_etc_gshadow",
        "fix_id": "file_groupowner_backup_etc_gshadow"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify Group Who Owns Backup gshadow File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chgrp 42 /etc/gshadow-"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "gid": "permissions_important_account_files",
        "rid": "file_groupowner_backup_etc_passwd",
        "fix_id": "file_groupowner_backup_etc_passwd"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify Group Who Owns Backup passwd File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chgrp 0 /etc/passwd-"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "gid": "permissions_important_account_files",
        "rid": "file_groupowner_backup_etc_shadow",
        "fix_id": "file_groupowner_backup_etc_shadow"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify User Who Owns Backup shadow File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chgrp 42 /etc/shadow-"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "gid": "permissions_important_account_files",
        "rid": "file_groupowner_etc_group",
        "fix_id": "file_groupowner_etc_group"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify Group Who Owns group File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chgrp 0 /etc/group"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "gid": "permissions_important_account_files",
        "rid": "file_groupowner_etc_gshadow",
        "fix_id": "file_groupowner_etc_gshadow"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify Group Who Owns gshadow File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chgrp 42 /etc/gshadow"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "gid": "permissions_important_account_files",
        "rid": "file_groupowner_etc_passwd",
        "fix_id": "file_groupowner_etc_passwd"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify Group Who Owns passwd File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chgrp 0 /etc/passwd"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "gid": "permissions_important_account_files",
        "rid": "file_groupowner_etc_shadow",
        "fix_id": "file_groupowner_etc_shadow"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify Group Who Owns shadow File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chgrp 42 /etc/shadow"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "gid": "permissions_important_account_files",
        "rid": "file_owner_backup_etc_group",
        "fix_id": "file_owner_backup_etc_group"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify User Who Owns Backup group File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chown 0 /etc/group-"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "gid": "permissions_important_account_files",
        "rid": "file_owner_backup_etc_gshadow",
        "fix_id": "file_owner_backup_etc_gshadow"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify User Who Owns Backup gshadow File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chown 0 /etc/gshadow-"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "gid": "permissions_important_account_files",
        "rid": "file_owner_backup_etc_passwd",
        "fix_id": "file_owner_backup_etc_passwd"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify User Who Owns Backup passwd File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chown 0 /etc/passwd-"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "gid": "permissions_important_account_files",
        "rid": "file_owner_backup_etc_shadow",
        "fix_id": "file_owner_backup_etc_shadow"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify Group Who Owns Backup shadow File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chown 0 /etc/shadow-"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "gid": "permissions_important_account_files",
        "rid": "file_owner_etc_group",
        "fix_id": "file_owner_etc_group"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify User Who Owns group File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chown 0 /etc/group"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "gid": "permissions_important_account_files",
        "rid": "file_owner_etc_gshadow",
        "fix_id": "file_owner_etc_gshadow"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify User Who Owns gshadow File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chown 0 /etc/gshadow"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "gid": "permissions_important_account_files",
        "rid": "file_owner_etc_passwd",
        "fix_id": "file_owner_etc_passwd"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify User Who Owns passwd File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chown 0 /etc/passwd"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "gid": "permissions_important_account_files",
        "rid": "file_owner_etc_shadow",
        "fix_id": "file_owner_etc_shadow"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify User Who Owns shadow File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chown 0 /etc/shadow"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "gid": "permissions_important_account_files",
        "rid": "file_permissions_backup_etc_group",
        "fix_id": "file_permissions_backup_etc_group"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify Permissions on Backup group File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chmod 0644 /etc/group-"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "gid": "permissions_important_account_files",
        "rid": "file_permissions_backup_etc_gshadow",
        "fix_id": "file_permissions_backup_etc_gshadow"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify Permissions on Backup gshadow File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chmod 0640 /etc/gshadow-"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "gid": "permissions_important_account_files",
        "rid": "file_permissions_backup_etc_passwd",
        "fix_id": "file_permissions_backup_etc_passwd"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify Permissions on Backup passwd File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chmod 0644 /etc/passwd-"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "gid": "permissions_important_account_files",
        "rid": "file_permissions_backup_etc_shadow",
        "fix_id": "file_permissions_backup_etc_shadow"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify Permissions on Backup shadow File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chmod 0640 /etc/shadow-"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "gid": "permissions_important_account_files",
        "rid": "file_permissions_etc_group",
        "fix_id": "file_permissions_etc_group"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify Permissions on group File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chmod 0644 /etc/group"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "gid": "permissions_important_account_files",
        "rid": "file_permissions_etc_gshadow",
        "fix_id": "file_permissions_etc_gshadow"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify Permissions on gshadow File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chmod 0640 /etc/gshadow"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "gid": "permissions_important_account_files",
        "rid": "file_permissions_etc_passwd",
        "fix_id": "file_permissions_etc_passwd"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify Permissions on passwd File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chmod 0644 /etc/passwd"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files with Local Account Information and Credentials",
        "gid": "permissions_important_account_files",
        "rid": "file_permissions_etc_shadow",
        "fix_id": "file_permissions_etc_shadow"
      },
      "id": "permissions_important_account_files",
      "title": [
        {
          "#text": "Verify Permissions on shadow File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chmod 0640 /etc/shadow"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files within /var/log Directory",
        "gid": "permissions_var_log_dir",
        "rid": "file_groupowner_var_log",
        "fix_id": "file_groupowner_var_log"
      },
      "id": "permissions_var_log_dir",
      "title": [
        {
          "#text": "Verify Group Who Owns /var/log Directory",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chgrp 110 /var/log/"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files within /var/log Directory",
        "gid": "permissions_var_log_dir",
        "rid": "file_groupowner_var_log_messages",
        "fix_id": "file_groupowner_var_log_messages"
      },
      "id": "permissions_var_log_dir",
      "title": [
        {
          "#text": "Verify Group Who Owns /var/log/messages File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chgrp 0 /var/log/messages"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files within /var/log Directory",
        "gid": "permissions_var_log_dir",
        "rid": "file_groupowner_var_log_syslog",
        "fix_id": "file_groupowner_var_log_syslog"
      },
      "id": "permissions_var_log_dir",
      "title": [
        {
          "#text": "Verify Group Who Owns /var/log/syslog File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chgrp 4 /var/log/syslog"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files within /var/log Directory",
        "gid": "permissions_var_log_dir",
        "rid": "file_owner_var_log",
        "fix_id": "file_owner_var_log"
      },
      "id": "permissions_var_log_dir",
      "title": [
        {
          "#text": "Verify User Who Owns /var/log Directory",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chown 0 /var/log/"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files within /var/log Directory",
        "gid": "permissions_var_log_dir",
        "rid": "file_owner_var_log_messages",
        "fix_id": "file_owner_var_log_messages"
      },
      "id": "permissions_var_log_dir",
      "title": [
        {
          "#text": "Verify User Who Owns /var/log/messages File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chown 0 /var/log/messages"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files within /var/log Directory",
        "gid": "permissions_var_log_dir",
        "rid": "file_owner_var_log_syslog",
        "fix_id": "file_owner_var_log_syslog"
      },
      "id": "permissions_var_log_dir",
      "title": [
        {
          "#text": "Verify User Who Owns /var/log/syslog File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chown 104 /var/log/syslog"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files within /var/log Directory",
        "gid": "permissions_var_log_dir",
        "rid": "file_permissions_var_log",
        "fix_id": "file_permissions_var_log"
      },
      "id": "permissions_var_log_dir",
      "title": [
        {
          "#text": "Verify Permissions on /var/log Directory",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chmod 0755 /var/log/ if grep -q \"^z \\/var\\/log \" /usr/lib/tmpfiles.d/00rsyslog.conf; then sed -i --follow-symlinks \"s/\\(^z[[:space:]]\\+\\/var\\/log[[:space:]]\\+\\)\\(\\([[:digit:]]\\+\\)[^ $]*\\)/\\10755/\" /usr/lib/tmpfiles.d/00rsyslog.conf fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files within /var/log Directory",
        "gid": "permissions_var_log_dir",
        "rid": "file_permissions_var_log_messages",
        "fix_id": "file_permissions_var_log_messages"
      },
      "id": "permissions_var_log_dir",
      "title": [
        {
          "#text": "Verify Permissions on /var/log/messages File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chmod 0640 /var/log/messages"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify Permissions on Files within /var/log Directory",
        "gid": "permissions_var_log_dir",
        "rid": "file_permissions_var_log_syslog",
        "fix_id": "file_permissions_var_log_syslog"
      },
      "id": "permissions_var_log_dir",
      "title": [
        {
          "#text": "Verify Permissions on /var/log/syslog File",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "chmod 0640 /var/log/syslog"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify File Permissions Within Some Important Directories",
        "gid": "permissions_within_important_dirs",
        "rid": "dir_groupownership_binary_dirs",
        "fix_id": "dir_groupownership_binary_dirs"
      },
      "id": "permissions_within_important_dirs",
      "title": [
        {
          "#text": "Verify that system commands directories are group owned by root",
          "@_lang": "en-US"
        }
      ],
      "desc": "System commands files are stored in the following directories by default:All these directories should be owned by thegroup. If the directory is found to be owned by a group other than root correct its ownership with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "chgrp 0 /bin/ chgrp 0 /sbin/ chgrp 0 /usr/bin/ chgrp 0 /usr/sbin/ chgrp 0 /usr/local/bin/ chgrp 0 /usr/local/sbin/"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify File Permissions Within Some Important Directories",
        "gid": "permissions_within_important_dirs",
        "rid": "dir_groupownership_library_dirs",
        "fix_id": "dir_groupownership_library_dirs"
      },
      "id": "permissions_within_important_dirs",
      "title": [
        {
          "#text": "Verify that Shared Library Directories Have Root Group Ownership",
          "@_lang": "en-US"
        }
      ],
      "desc": "System-wide shared library files, which are linked to executables during process load time or run time, are stored in the following directories by default:Kernel modules, which can be added to the kernel during runtime, are also stored in. All files in these directories should be group-owned by theuser. If the directories, is found to be owned by a user other than root correct its ownership with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "chgrp 0 /lib/ chgrp 0 /lib64/ chgrp 0 /usr/lib/ chgrp 0 /usr/lib64/"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify File Permissions Within Some Important Directories",
        "gid": "permissions_within_important_dirs",
        "rid": "dir_ownership_binary_dirs",
        "fix_id": "dir_ownership_binary_dirs"
      },
      "id": "permissions_within_important_dirs",
      "title": [
        {
          "#text": "Verify that System Executable Have Root Ownership",
          "@_lang": "en-US"
        }
      ],
      "desc": "All these directories should be owned by theuser. If any directoryin these directories is found to be owned by a user other than root, correct its ownership with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "chown 0 /bin/ chown 0 /sbin/ chown 0 /usr/bin/ chown 0 /usr/sbin/ chown 0 /usr/local/bin/ chown 0 /usr/local/sbin/"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify File Permissions Within Some Important Directories",
        "gid": "permissions_within_important_dirs",
        "rid": "dir_ownership_library_dirs",
        "fix_id": "dir_ownership_library_dirs"
      },
      "id": "permissions_within_important_dirs",
      "title": [
        {
          "#text": "Verify that Shared Library Directories Have Root Ownership",
          "@_lang": "en-US"
        }
      ],
      "desc": "System-wide shared library files, which are linked to executables during process load time or run time, are stored in the following directories by default:Kernel modules, which can be added to the kernel during runtime, are also stored in. All files in these directories should be owned by theuser. If the directories, is found to be owned by a user other than root correct its ownership with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "chown 0 /lib/ chown 0 /lib64/ chown 0 /usr/lib/ chown 0 /usr/lib64/"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify File Permissions Within Some Important Directories",
        "gid": "permissions_within_important_dirs",
        "rid": "dir_permissions_binary_dirs",
        "fix_id": "dir_permissions_binary_dirs"
      },
      "id": "permissions_within_important_dirs",
      "title": [
        {
          "#text": "Verify that System Executable Directories Have Restrictive Permissions",
          "@_lang": "en-US"
        }
      ],
      "desc": "System executables are stored in the following directories by default:These directories should not be group-writable or world-writable. If any directoryin these directories is found to be group-writable or world-writable, correct its permission with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "chmod 0755 /bin/ chmod 0755 /sbin/ chmod 0755 /usr/bin/ chmod 0755 /usr/sbin/ chmod 0755 /usr/local/bin/ chmod 0755 /usr/local/sbin/"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify File Permissions Within Some Important Directories",
        "gid": "permissions_within_important_dirs",
        "rid": "dir_permissions_library_dirs",
        "fix_id": "dir_permissions_library_dirs"
      },
      "id": "permissions_within_important_dirs",
      "title": [
        {
          "#text": "Verify that Shared Library Directories Have Restrictive Permissions",
          "@_lang": "en-US"
        }
      ],
      "desc": "System-wide shared library directories, which contain are linked to executables during process load time or run time, are stored in the following directories by default:Kernel modules, which can be added to the kernel during runtime, are stored in. All sub-directories in these directories should not be group-writable or world-writable. If any file in these directories is found to be group-writable or world-writable, correct its permission with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "DIRS=\"/lib /lib64 /usr/lib /usr/lib64\" for dirPath in $DIRS; do  find \"$dirPath\" -perm /022 -type d -exec chmod go-w '{}' \\; done"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify File Permissions Within Some Important Directories",
        "gid": "permissions_within_important_dirs",
        "rid": "file_groupownership_audit_binaries",
        "fix_id": "file_groupownership_audit_binaries"
      },
      "id": "permissions_within_important_dirs",
      "title": [
        {
          "#text": "Verify that audit tools are owned by group root",
          "@_lang": "en-US"
        }
      ],
      "desc": "The Ubuntu 20.04 operating system audit tools must have the proper ownership configured to protected against unauthorized access. Verify it by running the following command:Audit tools needed to successfully view and manipulate audit information system activity and records. Audit tools include custom queries and report generators",
      "impact": 0.5,
      "descs": {
        "fix": "chgrp 0 /sbin/auditctl chgrp 0 /sbin/aureport chgrp 0 /sbin/ausearch chgrp 0 /sbin/autrace chgrp 0 /sbin/auditd chgrp 0 /sbin/audispd chgrp 0 /sbin/augenrules"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify File Permissions Within Some Important Directories",
        "gid": "permissions_within_important_dirs",
        "rid": "file_groupownership_system_commands_dirs",
        "fix_id": "file_groupownership_system_commands_dirs"
      },
      "id": "permissions_within_important_dirs",
      "title": [
        {
          "#text": "Verify that system commands files are group owned by root",
          "@_lang": "en-US"
        }
      ],
      "desc": "System commands files are stored in the following directories by default:All files in these directories should be owned by thegroup. If the directory, or any file in these directories, is found to be owned by a group other than root correct its ownership with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "for SYSCMDFILES in /bin /sbin /usr/bin /usr/sbin /usr/local/bin /usr/local/sbin do find -L $SYSCMDFILES \\! -group root -type f -exec chgrp root '{}' \\; done"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify File Permissions Within Some Important Directories",
        "gid": "permissions_within_important_dirs",
        "rid": "file_ownership_audit_binaries",
        "fix_id": "file_ownership_audit_binaries"
      },
      "id": "permissions_within_important_dirs",
      "title": [
        {
          "#text": "Verify that audit tools are owned by root",
          "@_lang": "en-US"
        }
      ],
      "desc": "The Ubuntu 20.04 operating system audit tools must have the proper ownership configured to protected against unauthorized access. Verify it by running the following command:Audit tools needed to successfully view and manipulate audit information system activity and records. Audit tools include custom queries and report generators",
      "impact": 0.5,
      "descs": {
        "fix": "chown 0 /sbin/auditctl chown 0 /sbin/aureport chown 0 /sbin/ausearch chown 0 /sbin/autrace chown 0 /sbin/auditd chown 0 /sbin/audispd chown 0 /sbin/augenrules"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify File Permissions Within Some Important Directories",
        "gid": "permissions_within_important_dirs",
        "rid": "file_ownership_binary_dirs",
        "fix_id": "file_ownership_binary_dirs"
      },
      "id": "permissions_within_important_dirs",
      "title": [
        {
          "#text": "Verify that System Executables Have Root Ownership",
          "@_lang": "en-US"
        }
      ],
      "desc": "System executables are stored in the following directories by default:All files in these directories should be owned by theuser. If any filein these directories is found to be owned by a user other than root, correct its ownership with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "find /bin/ \\ /usr/bin/ \\ /usr/local/bin/ \\ /sbin/ \\ /usr/sbin/ \\ /usr/local/sbin/ \\ /usr/libexec \\ \\! -user root -execdir chown root {} \\;"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify File Permissions Within Some Important Directories",
        "gid": "permissions_within_important_dirs",
        "rid": "file_ownership_library_dirs",
        "fix_id": "file_ownership_library_dirs"
      },
      "id": "permissions_within_important_dirs",
      "title": [
        {
          "#text": "Verify that Shared Library Files Have Root Ownership",
          "@_lang": "en-US"
        }
      ],
      "desc": "System-wide shared library files, which are linked to executables during process load time or run time, are stored in the following directories by default:Kernel modules, which can be added to the kernel during runtime, are also stored in. All files in these directories should be owned by theuser. If the directory, or any file in these directories, is found to be owned by a user other than root correct its ownership with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "for LIBDIR in /usr/lib /usr/lib64 /lib /lib64 do if [ -d $LIBDIR ] then find -L $LIBDIR \\! -user root -exec chown root {} \\; fi done"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify File Permissions Within Some Important Directories",
        "gid": "permissions_within_important_dirs",
        "rid": "file_permissions_audit_binaries",
        "fix_id": "file_permissions_audit_binaries"
      },
      "id": "permissions_within_important_dirs",
      "title": [
        {
          "#text": "Verify that audit tools Have Mode 0755 or less",
          "@_lang": "en-US"
        }
      ],
      "desc": "The Ubuntu 20.04 operating system audit tools must have the proper permissions configured to protected against unauthorized access. Verify it by running the following command:Audit tools needed to successfully view and manipulate audit information system activity and records. Audit tools include custom queries and report generators",
      "impact": 0.5,
      "descs": {
        "fix": "chmod 0755 /sbin/auditctl chmod 0755 /sbin/aureport chmod 0755 /sbin/ausearch chmod 0755 /sbin/autrace chmod 0755 /sbin/auditd chmod 0755 /sbin/audispd chmod 0755 /sbin/augenrules"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify File Permissions Within Some Important Directories",
        "gid": "permissions_within_important_dirs",
        "rid": "file_permissions_binary_dirs",
        "fix_id": "file_permissions_binary_dirs"
      },
      "id": "permissions_within_important_dirs",
      "title": [
        {
          "#text": "Verify that System Executables Have Restrictive Permissions",
          "@_lang": "en-US"
        }
      ],
      "desc": "System executables are stored in the following directories by default:All files in these directories should not be group-writable or world-writable. If any filein these directories is found to be group-writable or world-writable, correct its permission with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "DIRS=\"/bin /usr/bin /usr/local/bin /sbin /usr/sbin /usr/local/sbin /usr/libexec\" find -L $DIRS -perm /022 -execdir chmod go-w '{}' \\;"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify File Permissions Within Some Important Directories",
        "gid": "permissions_within_important_dirs",
        "rid": "file_permissions_library_dirs",
        "fix_id": "file_permissions_library_dirs"
      },
      "id": "permissions_within_important_dirs",
      "title": [
        {
          "#text": "Verify that Shared Library Files Have Restrictive Permissions",
          "@_lang": "en-US"
        }
      ],
      "desc": "System-wide shared library files, which are linked to executables during process load time or run time, are stored in the following directories by default:Kernel modules, which can be added to the kernel during runtime, are stored in. All files in these directories should not be group-writable or world-writable. If any file in these directories is found to be group-writable or world-writable, correct its permission with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "DIRS=\"/lib /lib64 /usr/lib /usr/lib64\" for dirPath in $DIRS; do  find \"$dirPath\" -perm /022 -type f -exec chmod go-w '{}' \\; done"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Verify File Permissions Within Some Important Directories",
        "gid": "permissions_within_important_dirs",
        "rid": "root_permissions_syslibrary_files",
        "fix_id": "root_permissions_syslibrary_files"
      },
      "id": "permissions_within_important_dirs",
      "title": [
        {
          "#text": "Verify the system-wide library files in directories \"/lib\", \"/lib64\", \"/usr/lib/\" and \"/usr/lib64\" are owned by root.",
          "@_lang": "en-US"
        }
      ],
      "desc": "System-wide library files are stored in the following directories by default:All system-wide shared library files should be protected from unauthorised access. If any of these files is not owned by root, correct its owner with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "readarray -t files &lt; &lt;(find /lib/) for file in \"${files[@]}\"; do if basename $file | grep -qE '^.*$'; then chgrp 0 $file fi done readarray -t files &lt; &lt;(find /lib64/) for file in \"${files[@]}\"; do if basename $file | grep -qE '^.*$'; then chgrp 0 $file fi done readarray -t files &lt; &lt;(find /usr/lib/) for file in \"${files[@]}\"; do if basename $file | grep -qE '^.*$'; then chgrp 0 $file fi done readarray -t files &lt; &lt;(find /usr/lib64/) for file in \"${files[@]}\"; do if basename $file | grep -qE '^.*$'; then chgrp 0 $file fi done"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Configure SMTP For Mail Clients",
        "gid": "postfix_client",
        "rid": "postfix_client_configure_mail_alias",
        "fix_id": "postfix_client_configure_mail_alias"
      },
      "id": "postfix_client",
      "title": [
        {
          "#text": "Configure System to Forward All Mail For The Root Account",
          "@_lang": "en-US"
        }
      ],
      "desc": "Make sure that mails delivered to root user are forwarded to a monitored email address. Make sure that the addressis a valid email address reachable from the system in question. Use the following command to configure the alias:",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then var_postfix_root_mail_alias='' # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/aliases\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^root\") # shellcheck disable=SC2059 printf -v formatted_output \"%s: %s\" \"$stripped_key\" \"$var_postfix_root_mail_alias\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^root\\\\&gt;\" \"/etc/aliases\"; then \"${sed_command[@]}\" \"s/^root\\\\&gt;.*/$formatted_output/gi\" \"/etc/aliases\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/aliases\" &gt;&gt; \"/etc/aliases\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/aliases\" fi newaliases else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure SMTP For Mail Clients",
        "gid": "postfix_client",
        "rid": "postfix_client_configure_relayhost"
      },
      "id": "postfix_client",
      "title": [
        {
          "#text": "Configure System to Forward All Mail through a specific host",
          "@_lang": "en-US"
        }
      ],
      "desc": "Set up a relay host that will act as a gateway for all outbound email. Edit the fileto ensure that only the followingline appears:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure SMTP For Mail Clients",
        "gid": "postfix_client",
        "rid": "postfix_network_listening_disabled",
        "fix_id": "postfix_network_listening_disabled"
      },
      "id": "postfix_client",
      "title": [
        {
          "#text": "Disable Postfix Network Listening",
          "@_lang": "en-US"
        }
      ],
      "desc": "Edit the fileto ensure that only the followingline appears:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then var_postfix_inet_interfaces='' if [ -e \"/etc/postfix/main.cf\" ] ; then LC_ALL=C sed -i \"/^\\s*inet_interfaces\\s\\+=\\s\\+/Id\" \"/etc/postfix/main.cf\" else touch \"/etc/postfix/main.cf\" fi cp \"/etc/postfix/main.cf\" \"/etc/postfix/main.cf.bak\" # Insert at the end of the file printf '%s ' \"inet_interfaces=$var_postfix_inet_interfaces\" &gt;&gt; \"/etc/postfix/main.cf\" # Clean up after ourselves. rm \"/etc/postfix/main.cf.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Print Support",
        "gid": "printing",
        "rid": "package_cups_removed",
        "fix_id": "package_cups_removed"
      },
      "id": "printing",
      "title": [
        {
          "#text": "Uninstall cups Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be removed with the following command:",
      "impact": 0.3,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove cups #  from the system, and may remove any packages #  that depend on cups. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"cups\""
      }
    },
    {
      "tags": {
        "severity": "critical",
        "gtitle": "Print Support",
        "gid": "printing",
        "rid": "service_cups_disabled",
        "fix_id": "service_cups_disabled"
      },
      "id": "printing",
      "title": [
        {
          "#text": "Disable the CUPS Service",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice can be disabled with the following command:",
      "impact": 1,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" stop 'cups.service' \"$SYSTEMCTL_EXEC\" disable 'cups.service' \"$SYSTEMCTL_EXEC\" mask 'cups.service' # Disable socket activation if we have a unit file for it if \"$SYSTEMCTL_EXEC\" list-unit-files | grep -q '^cups.socket'; then \"$SYSTEMCTL_EXEC\" stop 'cups.socket' \"$SYSTEMCTL_EXEC\" mask 'cups.socket' fi # The service may not be running because it has been started and failed, # so let's reset the state so OVAL checks pass. # Service should be 'inactive', not 'failed' after reboot though. \"$SYSTEMCTL_EXEC\" reset-failed 'cups.service' || true else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gtitle": "Rlogin, Rsh, and Rexec",
        "gid": "r_services",
        "rid": "package_rsh-server_removed",
        "fix_id": "package_rsh-server_removed"
      },
      "id": "r_services",
      "title": [
        {
          "#text": "Uninstall rsh-server Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be removed with the following command:",
      "impact": 0.7,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove rsh-server #  from the system, and may remove any packages #  that depend on rsh-server. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"rsh-server\""
      }
    },
    {
      "tags": {
        "severity": "critical",
        "gtitle": "Rlogin, Rsh, and Rexec",
        "gid": "r_services",
        "rid": "package_rsh_removed",
        "fix_id": "package_rsh_removed"
      },
      "id": "r_services",
      "title": [
        {
          "#text": "Uninstall rsh Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage contains the client commands for the rsh services",
      "impact": 1,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove rsh-client #  from the system, and may remove any packages #  that depend on rsh-client. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"rsh-client\""
      }
    },
    {
      "tags": {
        "severity": "high",
        "gtitle": "Rlogin, Rsh, and Rexec",
        "gid": "r_services",
        "rid": "no_rsh_trust_files",
        "fix_id": "no_rsh_trust_files"
      },
      "id": "r_services",
      "title": [
        {
          "#text": "Remove Rsh Trust Files",
          "@_lang": "en-US"
        }
      ],
      "desc": "The filesand(in each user's home directory) list remote hosts and users that are trusted by the local system when using the rshd daemon. To remove these files, run the following command to delete them from any location:",
      "impact": 0.7,
      "descs": {
        "fix": "find /home -maxdepth 2 -type f -name .rhosts -exec rm -f '{}' \\; if [ -f /etc/hosts.equiv ]; then  /bin/rm -f /etc/hosts.equiv fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Restrict at and cron to Authorized Users if Necessary",
        "gid": "restrict_at_cron_users",
        "rid": "file_groupowner_at_allow",
        "fix_id": "file_groupowner_at_allow"
      },
      "id": "restrict_at_cron_users",
      "title": [
        {
          "#text": "Verify Group Who Owns /etc/at.allow file",
          "@_lang": "en-US"
        }
      ],
      "desc": "Ifexists, it must be group-owned by. To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chgrp 0 /etc/at.allow else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Restrict at and cron to Authorized Users if Necessary",
        "gid": "restrict_at_cron_users",
        "rid": "file_groupowner_cron_allow",
        "fix_id": "file_groupowner_cron_allow"
      },
      "id": "restrict_at_cron_users",
      "title": [
        {
          "#text": "Verify Group Who Owns /etc/cron.allow file",
          "@_lang": "en-US"
        }
      ],
      "desc": "Ifexists, it must be group-owned by. To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chgrp 0 /etc/cron.allow else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Restrict at and cron to Authorized Users if Necessary",
        "gid": "restrict_at_cron_users",
        "rid": "file_owner_at_allow",
        "fix_id": "file_owner_at_allow"
      },
      "id": "restrict_at_cron_users",
      "title": [
        {
          "#text": "Verify User Who Owns /etc/at.allow file",
          "@_lang": "en-US"
        }
      ],
      "desc": "Ifexists, it must be owned by. To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chown 0 /etc/at.allow else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Restrict at and cron to Authorized Users if Necessary",
        "gid": "restrict_at_cron_users",
        "rid": "file_owner_cron_allow",
        "fix_id": "file_owner_cron_allow"
      },
      "id": "restrict_at_cron_users",
      "title": [
        {
          "#text": "Verify User Who Owns /etc/cron.allow file",
          "@_lang": "en-US"
        }
      ],
      "desc": "Ifexists, it must be owned by. To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chown 0 /etc/cron.allow else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Restrict at and cron to Authorized Users if Necessary",
        "gid": "restrict_at_cron_users",
        "rid": "file_permissions_at_allow",
        "fix_id": "file_permissions_at_allow"
      },
      "id": "restrict_at_cron_users",
      "title": [
        {
          "#text": "Verify Permissions on /etc/at.allow file",
          "@_lang": "en-US"
        }
      ],
      "desc": "Ifexists, it must have permissionsor more restrictive. To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chmod 0640 /etc/at.allow else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Restrict at and cron to Authorized Users if Necessary",
        "gid": "restrict_at_cron_users",
        "rid": "file_permissions_cron_allow",
        "fix_id": "file_permissions_cron_allow"
      },
      "id": "restrict_at_cron_users",
      "title": [
        {
          "#text": "Verify Permissions on /etc/cron.allow file",
          "@_lang": "en-US"
        }
      ],
      "desc": "Ifexists, it must have permissionsor more restrictive. To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chmod 0640 /etc/cron.allow else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Restrict at and cron to Authorized Users if Necessary",
        "gid": "restrict_at_cron_users",
        "rid": "restrict_at_users",
        "fix_id": "restrict_at_users"
      },
      "id": "restrict_at_cron_users",
      "title": [
        {
          "#text": "Ensure at is restricted to authorized users",
          "@_lang": "en-US"
        }
      ],
      "desc": "Configure /etc/at.allow to allow specific users to use these services. If /etc/at.allow do not exist, then /etc/at.deny is checked. Any user not specifically defined in these file is allowed to use at. By removing the file, only users in /etc/at.allow is allowed to use at. Note: Other methods, such as systemd timers , exist for scheduling jobs. If another method is used, at should be removed, and the alternate method should be secured in accordance with local site policy.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then rm -rf /etc/at.deny touch /etc/at.allow chmod 640 /etc/at.allow else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Restrict at and cron to Authorized Users if Necessary",
        "gid": "restrict_at_cron_users",
        "rid": "restrict_cron_users",
        "fix_id": "restrict_cron_users"
      },
      "id": "restrict_at_cron_users",
      "title": [
        {
          "#text": "Ensure cron is restricted to authorized users",
          "@_lang": "en-US"
        }
      ],
      "desc": "Configure /etc/cron.allow to allow specific users to use these services. If /etc/cron.allow do not exist, then /etc/cron.deny is checked. Any user not specifically defined in these file is allowed to use cron. By removing the file, only users in /etc/cron.allow is allowed to use cron. Notes: - Other methods, such as systemd timers, exist for scheduling jobs. If another method is used, cron should be removed, and the alternate method should be secured in accordance with local site policy. - Even though a given user is not listed in cron.allow, cron jobs can still be run as that user. - The cron.allow file only controls administrative access to the crontab command for scheduling and modifying cron jobs.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then rm -rf /etc/cron.deny touch /etc/cron.allow chmod 640 /etc/cron.allow else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Restrict Root Logins",
        "gid": "root_logins",
        "rid": "accounts_no_gid_except_zero",
        "fix_id": "accounts_no_gid_except_zero"
      },
      "id": "root_logins",
      "title": [
        {
          "#text": "Ensure default group for the root account is GID 0",
          "@_lang": "en-US"
        }
      ],
      "desc": "The usermod command can be used to specify which group the root user belongs to. This affects permissions of files that are created by the root user. Using GID 0 for the root account helps prevent root-owned files from accidentally becoming accessible to non-privileged users.",
      "impact": 0.5,
      "descs": {
        "fix": "usermod -g 0 root"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gtitle": "Restrict Root Logins",
        "gid": "root_logins",
        "rid": "accounts_no_uid_except_zero",
        "fix_id": "accounts_no_uid_except_zero"
      },
      "id": "root_logins",
      "title": [
        {
          "#text": "Verify Only Root Has UID 0",
          "@_lang": "en-US"
        }
      ],
      "desc": "If any account other than root has a UID of 0, this misconfiguration should be investigated and the accounts other than root should be removed or have their UID changed.If the account is associated with system commands or applications the UID should be changed to one greater than \"0\" but less than \"1000.\" Otherwise assign a UID greater than \"1000\" that has not already been assigned.",
      "impact": 0.7,
      "descs": {
        "fix": "awk -F: '$3 == 0 &amp;&amp; $1 != \"root\" { print $1 }' /etc/passwd | xargs --max-lines=1 passwd -l"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Restrict Root Logins",
        "gid": "root_logins",
        "rid": "ensure_pam_wheel_group_empty",
        "fix_id": "ensure_pam_wheel_group_empty"
      },
      "id": "root_logins",
      "title": [
        {
          "#text": "Ensure the group used by pam_wheel module exists on system and is empty",
          "@_lang": "en-US"
        }
      ],
      "desc": "Ensure that the groupreferenced by the pam_wheelparameter exists and has no members. This ensures that no user can run commands with altered privileges through thecommand.",
      "impact": 0.5,
      "descs": {
        "fix": "#!/bin/bash var_pam_wheel_group_for_su='' GRP_FILE=/etc/group grep -q ^${var_pam_wheel_group_for_su}:[^:]*:[^:]*:[^:]* /etc/group if [ $? -ne 0 ]; then groupadd ${var_pam_wheel_group_for_su} fi # group must be empty grp_memb=$(groupmems -g ${var_pam_wheel_group_for_su} -l) if [ -n \"${grp_memb}\" ]; then for memb in ${grp_memb}; do deluser ${memb} ${var_pam_wheel_group_for_su} done fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Restrict Root Logins",
        "gid": "root_logins",
        "rid": "no_direct_root_logins",
        "fix_id": "no_direct_root_logins"
      },
      "id": "root_logins",
      "title": [
        {
          "#text": "Direct root Logins Not Allowed",
          "@_lang": "en-US"
        }
      ],
      "desc": "To further limit access to theaccount, administrators can disable root logins at the console by editing thefile. This file lists all devices the root user is allowed to login to. If the file does not exist at all, the root user can login through any communication device on the system, whether via the console or via a raw network interface. This is dangerous as user can login to the system as root via Telnet, which sends the password in plain text over the network. By default, Ubuntu 20.04'sfile only allows the root user to login at the console physically attached to the system. To prevent root from logging in, remove the contents of this file. To prevent direct root logins, remove the contents of this file by typing the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then echo &gt; /etc/securetty else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Restrict Root Logins",
        "gid": "root_logins",
        "rid": "no_password_auth_for_systemaccounts"
      },
      "id": "root_logins",
      "title": [
        {
          "#text": "Ensure that System Accounts Are Locked",
          "@_lang": "en-US"
        }
      ],
      "desc": "Some accounts are not associated with a human user of the system, and exist to perform some administrative function. An attacker should not be able to log into these accounts.System accounts are those user accounts with a user ID less than UID_MIN, where value of the UID_MIN directive is set inconfiguration file. In the default configuration UID_MIN is set to 500, thus system accounts are those user accounts with a user ID less than 500. If any system account(other than root) has an unlocked password, disable it with the command:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Restrict Root Logins",
        "gid": "root_logins",
        "rid": "no_shelllogin_for_systemaccounts",
        "fix_id": "no_shelllogin_for_systemaccounts"
      },
      "id": "root_logins",
      "title": [
        {
          "#text": "Ensure that System Accounts Do Not Run a Shell Upon Login",
          "@_lang": "en-US"
        }
      ],
      "desc": "Some accounts are not associated with a human user of the system, and exist to perform some administrative function. Should an attacker be able to log into these accounts, they should not be granted access to a shell.The login shell for each local account is stored in the last field of each line in. System accounts are those user accounts with a user ID less than UID_MIN, where value of UID_MIN directive is set in /etc/login.defs configuration file. In the default configuration UID_MIN is set to 1000, thus system accounts are those user accounts with a user ID less than 1000. The user ID is stored in the third field. If any system account(other than root) has a login shell, disable it with the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# set all system accounts to a non login shell awk -F: '($1!=\"root\" &amp;&amp; $1!=\"sync\" &amp;&amp; $1!=\"shutdown\" &amp;&amp; $1!=\"halt\" &amp;&amp; $1!~/^\\+/ &amp;&amp; $3&lt;'\"$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)\"' &amp;&amp; $7!=\"'\"$(which nologin)\"'\" &amp;&amp; $7!=\"/bin/false\") {print $1}' /etc/passwd |\\ while read -r user; do usermod -s \"$(which nologin)\" \"$user\"; done # lock not root system accounts awk -F: '($1!=\"root\" &amp;&amp; $1!~/^\\+/ &amp;&amp; $3&lt;'\"$(awk '/^\\s*UID_MIN/{print $2}' /etc/login.defs)\"') {print $1}' /etc/passwd |\\ xargs -I '{}' passwd -S '{}' | awk '($2!=\"L\" &amp;&amp; $2!=\"LK\") {print $1}' |\\ while read -r user; do usermod -L \"$user\"; done"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Restrict Root Logins",
        "gid": "root_logins",
        "rid": "prevent_direct_root_logins"
      },
      "id": "root_logins",
      "title": [
        {
          "#text": "Direct root Logins Are Not Allowed",
          "@_lang": "en-US"
        }
      ],
      "desc": "Configure the operating system to prevent direct logins to theaccount by performing the following operations:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Restrict Root Logins",
        "gid": "root_logins",
        "rid": "restrict_serial_port_logins",
        "fix_id": "restrict_serial_port_logins"
      },
      "id": "root_logins",
      "title": [
        {
          "#text": "Restrict Serial Port Root Logins",
          "@_lang": "en-US"
        }
      ],
      "desc": "To restrict root logins on serial ports, ensure lines of this form do not appear in:",
      "impact": 0.5,
      "descs": {
        "fix": "sed -i '/ttyS/d' /etc/securetty"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Restrict Root Logins",
        "gid": "root_logins",
        "rid": "securetty_root_login_console_only",
        "fix_id": "securetty_root_login_console_only"
      },
      "id": "root_logins",
      "title": [
        {
          "#text": "Restrict Virtual Console Root Logins",
          "@_lang": "en-US"
        }
      ],
      "desc": "To restrict root logins through the (deprecated) virtual console devices, ensure lines of this form do not appear in:",
      "impact": 0.5,
      "descs": {
        "fix": "sed -i '/^vc\\//d' /etc/securetty"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Restrict Root Logins",
        "gid": "root_logins",
        "rid": "use_pam_wheel_group_for_su",
        "fix_id": "use_pam_wheel_group_for_su"
      },
      "id": "root_logins",
      "title": [
        {
          "#text": "Enforce usage of pam_wheel with group parameter for su authentication",
          "@_lang": "en-US"
        }
      ],
      "desc": "To ensure that only users who are members of the group set in thepam_wheel parameter can run commands with altered privileges through thecommand, make sure that the following line exists in the file:",
      "impact": 0.5,
      "descs": {
        "fix": "#!/bin/bash var_pam_wheel_group_for_su='' PAM_CONF=/etc/pam.d/su pamstr=$(grep -P '^auth\\s+required\\s+pam_wheel\\.so\\s+(?=[^#]*\\buse_uid\\b)(?=[^#]*\\bgroup=)' ${PAM_CONF}) if [ -z \"$pamstr\" ]; then sed -Ei '/^auth\\b.*\\brequired\\b.*\\bpam_wheel\\.so/d' ${PAM_CONF} # remove any remaining uncommented pam_wheel.so line sed -Ei \"/^auth\\s+sufficient\\s+pam_rootok\\.so.*$/a auth required pam_wheel.so use_uid group=${var_pam_wheel_group_for_su}\" ${PAM_CONF} else group_val=$(echo -n \"$pamstr\" | egrep -o '\\bgroup=[_a-z][-0-9_a-z]*' | cut -d '=' -f 2) if [ -z \"${group_val}\" ] || [ ${group_val} != ${var_pam_wheel_group_for_su} ]; then sed -Ei \"s/(^auth\\s+required\\s+pam_wheel.so\\s+[^#]*group=)[_a-z][-0-9_a-z]*/\\1${var_pam_wheel_group_for_su}/\" ${PAM_CONF} fi fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Ensure that No Dangerous Directories Exist in Root's Path",
        "gid": "root_paths",
        "rid": "accounts_root_path_dirs_no_write",
        "fix_id": "accounts_root_path_dirs_no_write"
      },
      "id": "root_paths",
      "title": [
        {
          "#text": "Ensure that Root's Path Does Not Include World or Group-Writable Directories",
          "@_lang": "en-US"
        }
      ],
      "desc": "For each element in root's path, run:and ensure that write permissions are disabled for group and other.",
      "impact": 0.5,
      "descs": {
        "fix": "fix_path() { local path_segments=\"${1//:/$' '}\" local new_path=\"\" local old_IFS=\"$IFS\" IFS=$' ' for path_part in $path_segments; do if [ -z \"${path_part}\" ] || [ \"${path_part}\" == \".\" ]; then continue fi local old_part=\"$(readlink -f \"${path_part}\")\" local have_part=\"false\" for new_part in ${new_path//:/$' '}; do if [ \"x${old_part}\" == \"x${new_part}\" ]; then have_part=\"true\" break fi done # Do this on the resolved part, not the original part. /bin/chmod o-w,g-w \"${old_part}\" if [ -z \"$new_path\" ]; then new_path=\"${old_part}\" else new_path=\"$new_path:${old_part}\" fi done IFS=\"${old_IFS}\" echo \"$new_path\" } PATH=\"$(fix_path \"$PATH\")\" profile_paths=\"/etc/skel/.profile /etc/environment /etc/crontab /etc/bash.bashrc /etc/profile /root/.profile /root/.bashrc\" /usr/bin/sed -i 's|^PATH=.*|PATH='\"$PATH\"'|g' $profile_paths /usr/bin/sed -i 's|^\\(.*\\s\\)PATH=.*|\\1PATH='\"$PATH\"'|g' $profile_paths defs_path=\"/etc/login.defs\" /usr/bin/sed -i 's|^\\(.*\\s\\)PATH=.*|\\1PATH='\"$PATH\"'|g' $defs_path"
      }
    },
    {
      "tags": {
        "severity": "critical",
        "gtitle": "Ensure that No Dangerous Directories Exist in Root's Path",
        "gid": "root_paths",
        "rid": "root_path_no_dot"
      },
      "id": "root_paths",
      "title": [
        {
          "#text": "Ensure that Root's Path Does Not Include Relative Paths or Null Directories",
          "@_lang": "en-US"
        }
      ],
      "desc": "Ensure that none of the directories in root's path is equal to a singlecharacter, or that it contains any instances that lead to relative path traversal, such asor beginning a path without the slash () character. Also ensure that there are no \"empty\" elements in the path, such as in these examples:These empty elements have the same effect as a singlecharacter.",
      "impact": 1,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure rsyslogd to Accept Remote Messages If Acting as a Log Server",
        "gid": "rsyslog_accepting_remote_messages",
        "rid": "package_syslogng_installed",
        "fix_id": "package_syslogng_installed"
      },
      "id": "rsyslog_accepting_remote_messages",
      "title": [
        {
          "#text": "Ensure syslog-ng is Installed",
          "@_lang": "en-US"
        }
      ],
      "desc": "syslog-ng can be installed in replacement of rsyslog. Thepackage can be installed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"syslogng\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure rsyslogd to Accept Remote Messages If Acting as a Log Server",
        "gid": "rsyslog_accepting_remote_messages",
        "rid": "service_syslogng_enabled",
        "fix_id": "service_syslogng_enabled"
      },
      "id": "rsyslog_accepting_remote_messages",
      "title": [
        {
          "#text": "Enable syslog-ng Service",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theservice (in replacement of rsyslog) provides syslog-style logging by default on Debian. Theservice can be enabled with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" unmask 'syslogng.service' \"$SYSTEMCTL_EXEC\" start 'syslogng.service' \"$SYSTEMCTL_EXEC\" enable 'syslogng.service' else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "critical",
        "gtitle": "Configure rsyslogd to Accept Remote Messages If Acting as a Log Server",
        "gid": "rsyslog_accepting_remote_messages",
        "rid": "rsyslog_accept_remote_messages_tcp"
      },
      "id": "rsyslog_accepting_remote_messages",
      "title": [
        {
          "#text": "Enable rsyslog to Accept Messages via TCP, if Acting As Log Server",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thedaemon should not accept remote messages unless the system acts as a log server. If the system needs to act as a central log server, add the following lines toto enable reception of messages over TCP:",
      "impact": 1,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "critical",
        "gtitle": "Configure rsyslogd to Accept Remote Messages If Acting as a Log Server",
        "gid": "rsyslog_accepting_remote_messages",
        "rid": "rsyslog_accept_remote_messages_udp"
      },
      "id": "rsyslog_accepting_remote_messages",
      "title": [
        {
          "#text": "Enable rsyslog to Accept Messages via UDP, if Acting As Log Server",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thedaemon should not accept remote messages unless the system acts as a log server. If the system needs to act as a central log server, add the following lines toto enable reception of messages over UDP:",
      "impact": 1,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Rsyslog Logs Sent To Remote Host",
        "gid": "rsyslog_sending_messages",
        "rid": "rsyslog_remote_loghost",
        "fix_id": "rsyslog_remote_loghost"
      },
      "id": "rsyslog_sending_messages",
      "title": [
        {
          "#text": "Ensure Logs Sent To Remote Host",
          "@_lang": "en-US"
        }
      ],
      "desc": "To configure rsyslog to send logs to a remote log server, openand read and understand the last section of the file, which describes the multiple directives necessary to activate remote logging. Along with these other directives, the system can be configured to forward its logs to a particular log server by adding or correcting one of the following lines, substitutingappropriately. The choice of protocol depends on the environment of the system; although TCP and RELP provide more reliable message delivery, they may not be supported in all environments.To use UDP for log message delivery:To use TCP for log message delivery:To use RELP for log message delivery:There must be a resolvable DNS CNAME or Alias record set to \"\" for logs to be sent correctly to the centralized logging utility.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then rsyslog_remote_loghost_address='' # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/rsyslog.conf\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^\\*\\.\\*\") # shellcheck disable=SC2059 printf -v formatted_output \"%s %s\" \"$stripped_key\" \"@@$rsyslog_remote_loghost_address\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^\\*\\.\\*\\\\&gt;\" \"/etc/rsyslog.conf\"; then \"${sed_command[@]}\" \"s/^\\*\\.\\*\\\\&gt;.*/$formatted_output/gi\" \"/etc/rsyslog.conf\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/rsyslog.conf\" &gt;&gt; \"/etc/rsyslog.conf\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/rsyslog.conf\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "SELinux",
        "gid": "selinux",
        "rid": "selinux_state"
      },
      "id": "selinux",
      "title": [
        {
          "#text": "Ensure SELinux State is Enforcing",
          "@_lang": "en-US"
        }
      ],
      "desc": "The SELinux state should be set toat system boot time. In the file, add or correct the following line to configure the system to boot into enforcing mode:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Set Password Hashing Algorithm",
        "gid": "set_password_hashing_algorithm",
        "rid": "set_password_hashing_algorithm_logindefs",
        "fix_id": "set_password_hashing_algorithm_logindefs"
      },
      "id": "set_password_hashing_algorithm",
      "title": [
        {
          "#text": "Set Password Hashing Algorithm in /etc/login.defs",
          "@_lang": "en-US"
        }
      ],
      "desc": "In, add or correct the following line to ensure the system will use SHA-512 as the hashing algorithm:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'login' 2&gt;/dev/null | grep -q installed; then var_password_hashing_algorithm='' if grep --silent ^ENCRYPT_METHOD /etc/login.defs ; then  sed -i \"s/^ENCRYPT_METHOD .*/ENCRYPT_METHOD $var_password_hashing_algorithm/g\" /etc/login.defs else  echo \"\" &gt;&gt; /etc/login.defs  echo \"ENCRYPT_METHOD $var_password_hashing_algorithm\" &gt;&gt; /etc/login.defs fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Hardware Tokens for Authentication",
        "gid": "smart_card_login",
        "rid": "package_opensc_installed",
        "fix_id": "package_opensc_installed"
      },
      "id": "smart_card_login",
      "title": [
        {
          "#text": "Install the opensc Package For Multifactor Authentication",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be installed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"opensc-pkcs11\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Hardware Tokens for Authentication",
        "gid": "smart_card_login",
        "rid": "install_smartcard_packages",
        "fix_id": "install_smartcard_packages"
      },
      "id": "smart_card_login",
      "title": [
        {
          "#text": "Install Smart Card Packages For Multifactor Authentication",
          "@_lang": "en-US"
        }
      ],
      "desc": "Configure the operating system to implement multifactor authentication by installing the required package with the following command: Thepackage can be installed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"libpam-pkcs11\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Hardware Tokens for Authentication",
        "gid": "smart_card_login",
        "rid": "smartcard_configure_ca",
        "fix_id": "smartcard_configure_ca"
      },
      "id": "smart_card_login",
      "title": [
        {
          "#text": "Configure Smart Card Certificate Authority Validation",
          "@_lang": "en-US"
        }
      ],
      "desc": "Configure the operating system to do certificate status checking for PKI authentication. Modify all of thelines into includelike so:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ ! -f /etc/pam_pkcs11/pam_pkcs11.conf ]; then cp /usr/share/doc/libpam-pkcs11/examples/pam_pkcs11.conf.example /etc/pam_pkcs11/pam_pkcs11.conf fi if grep -v \"^\\s*\\#+cert_policy\" /etc/pam_pkcs11/pam_pkcs11.conf | grep -qv \"ca\"; then sed -i \"s/\\(^[[:blank:]]*\\)\\(\\(\\#*[[:blank:]]*cert_policy[[:blank:]]*=[[:blank:]]*.*;\\)[^ $]*\\)/\\1cert_policy = ca,signature,ocsp_on;/\" /etc/pam_pkcs11/pam_pkcs11.conf fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Hardware Tokens for Authentication",
        "gid": "smart_card_login",
        "rid": "smartcard_configure_cert_checking",
        "fix_id": "smartcard_configure_cert_checking"
      },
      "id": "smart_card_login",
      "title": [
        {
          "#text": "Configure Smart Card Certificate Status Checking",
          "@_lang": "en-US"
        }
      ],
      "desc": "Configure the operating system to do certificate status checking for PKI authentication. Modify all of thelines into includelike so:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ ! -f /etc/pam_pkcs11/pam_pkcs11.conf ]; then cp /usr/share/doc/libpam-pkcs11/examples/pam_pkcs11.conf.example /etc/pam_pkcs11/pam_pkcs11.conf fi if grep -v \"^\\s*\\#+cert_policy\" /etc/pam_pkcs11/pam_pkcs11.conf | grep -qv \"oscp_on\"; then sed -i \"s/\\(^[[:blank:]]*\\)\\(\\(\\#*[[:blank:]]*cert_policy[[:blank:]]*=[[:blank:]]*.*;\\)[^ $]*\\)/\\1cert_policy = ca,signature,ocsp_on;/\" /etc/pam_pkcs11/pam_pkcs11.conf fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Hardware Tokens for Authentication",
        "gid": "smart_card_login",
        "rid": "smartcard_configure_crl",
        "fix_id": "smartcard_configure_crl"
      },
      "id": "smart_card_login",
      "title": [
        {
          "#text": "Configure Smart Card Local Cache of Revocation Data",
          "@_lang": "en-US"
        }
      ],
      "desc": "Configure the operating system for PKI-based authentication to use local revocation data when unable to access the network to obtain it remotely. Modify all of thelines into includeorlike so:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ ! -f /etc/pam_pkcs11/pam_pkcs11.conf ]; then cp /usr/share/doc/libpam-pkcs11/examples/pam_pkcs11.conf.example /etc/pam_pkcs11/pam_pkcs11.conf sed -i -e 's/debug = true/debug = false/g' -e 's|module = /usr/lib/opensc-pkcs11|module = /usr/lib/x86_64-linux-gnu/pkcs11/opensc-pkcs11|' /etc/pam_pkcs11/pam_pkcs11.conf fi if grep -v \"^\\s*\\#+cert_policy\" /etc/pam_pkcs11/pam_pkcs11.conf | grep -Eqv 'crl_auto|crl_offline'; then sed -i \"s/\\(^[[:blank:]]*\\)\\(\\(\\#*[[:blank:]]*cert_policy[[:blank:]]*=[[:blank:]]*.*;\\)[^ $]*\\)/\\1cert_policy = ca,signature,ocsp_on,crl_auto;/\" /etc/pam_pkcs11/pam_pkcs11.conf fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Hardware Tokens for Authentication",
        "gid": "smart_card_login",
        "rid": "smartcard_pam_enabled",
        "fix_id": "smartcard_pam_enabled"
      },
      "id": "smart_card_login",
      "title": [
        {
          "#text": "Enable Smart Card Logins in PAM",
          "@_lang": "en-US"
        }
      ],
      "desc": "This requirement only applies to components where this is specific to the function of the device or has the concept of an organizational user (e.g., VPN, proxy capability). This does not apply to authentication for the purpose of configuring the device itself (management). Check that theoption is configured in thefile with the following command:For general information about enabling smart card authentication, consult the documentation at:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; thenensure_pam_module_options '/etc/pam.d/common-auth' 'auth' '[success=2 default=ignore]' 'pam_pkcs11.so' '' '' '' else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Hardware Tokens for Authentication",
        "gid": "smart_card_login",
        "rid": "verify_use_mappers",
        "fix_id": "verify_use_mappers"
      },
      "id": "smart_card_login",
      "title": [
        {
          "#text": "Verify that 'use_mappers' is set to 'pwent' in PAM",
          "@_lang": "en-US"
        }
      ],
      "desc": "The operating system must map the authenticated identity to the user or group account for PKI-based authentication. Verify thatis set toinfile with the following command:",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/pam_pkcs11/pam_pkcs11.conf\" ] ; then LC_ALL=C sed -i \"/^\\s*use_mappers = pwent/Id\" \"/etc/pam_pkcs11/pam_pkcs11.conf\" else touch \"/etc/pam_pkcs11/pam_pkcs11.conf\" fi cp \"/etc/pam_pkcs11/pam_pkcs11.conf\" \"/etc/pam_pkcs11/pam_pkcs11.conf.bak\" # Insert at the end of the file printf '%s ' \"use_mappers = pwent\" &gt;&gt; \"/etc/pam_pkcs11/pam_pkcs11.conf\" # Clean up after ourselves. rm \"/etc/pam_pkcs11/pam_pkcs11.conf.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Installing and Maintaining Software",
        "gid": "software",
        "rid": "prefer_64bit_os"
      },
      "id": "software",
      "title": [
        {
          "#text": "Prefer to use a 64-bit Operating System when supported",
          "@_lang": "en-US"
        }
      ],
      "desc": "Prefer installation of 64-bit operating systems when the CPU supports it.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "SSH Server",
        "gid": "ssh",
        "rid": "package_openssh-server_installed",
        "fix_id": "package_openssh-server_installed"
      },
      "id": "ssh",
      "title": [
        {
          "#text": "Install the OpenSSH Server Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage should be installed. Thepackage can be installed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"openssh-server\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "SSH Server",
        "gid": "ssh",
        "rid": "package_openssh-server_removed",
        "fix_id": "package_openssh-server_removed"
      },
      "id": "ssh",
      "title": [
        {
          "#text": "Remove the OpenSSH Server Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage should be removed. Thepackage can be removed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then # CAUTION: This remediation script will remove openssh-server #  from the system, and may remove any packages #  that depend on openssh-server. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"openssh-server\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "SSH Server",
        "gid": "ssh",
        "rid": "service_sshd_enabled",
        "fix_id": "service_sshd_enabled"
      },
      "id": "ssh",
      "title": [
        {
          "#text": "Enable the OpenSSH Service",
          "@_lang": "en-US"
        }
      ],
      "desc": "The SSH server service, sshd, is commonly needed. Theservice can be enabled with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" unmask 'ssh.service' \"$SYSTEMCTL_EXEC\" start 'ssh.service' \"$SYSTEMCTL_EXEC\" enable 'ssh.service' else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "critical",
        "gtitle": "SSH Server",
        "gid": "ssh",
        "rid": "service_sshd_disabled",
        "fix_id": "service_sshd_disabled"
      },
      "id": "ssh",
      "title": [
        {
          "#text": "Disable SSH Server If Possible (Unusual)",
          "@_lang": "en-US"
        }
      ],
      "desc": "The SSH server service, sshd, is commonly needed. However, if it can be disabled, do so. Theservice can be disabled with the following command:This is unusual, as SSH is a common method for encrypted and authenticated remote access.",
      "impact": 1,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then SYSTEMCTL_EXEC='/usr/bin/systemctl' \"$SYSTEMCTL_EXEC\" stop 'sshd.service' \"$SYSTEMCTL_EXEC\" disable 'sshd.service' \"$SYSTEMCTL_EXEC\" mask 'sshd.service' # Disable socket activation if we have a unit file for it if \"$SYSTEMCTL_EXEC\" list-unit-files | grep -q '^sshd.socket'; then \"$SYSTEMCTL_EXEC\" stop 'sshd.socket' \"$SYSTEMCTL_EXEC\" mask 'sshd.socket' fi # The service may not be running because it has been started and failed, # so let's reset the state so OVAL checks pass. # Service should be 'inactive', not 'failed' after reboot though. \"$SYSTEMCTL_EXEC\" reset-failed 'sshd.service' || true else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "SSH Server",
        "gid": "ssh",
        "rid": "file_groupowner_sshd_config",
        "fix_id": "file_groupowner_sshd_config"
      },
      "id": "ssh",
      "title": [
        {
          "#text": "Verify Group Who Owns SSH Server config file",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the group owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chgrp 0 /etc/ssh/sshd_config else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "SSH Server",
        "gid": "ssh",
        "rid": "file_owner_sshd_config",
        "fix_id": "file_owner_sshd_config"
      },
      "id": "ssh",
      "title": [
        {
          "#text": "Verify Owner on SSH Server config file",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the owner of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chown 0 /etc/ssh/sshd_config else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "SSH Server",
        "gid": "ssh",
        "rid": "file_permissions_sshd_config",
        "fix_id": "file_permissions_sshd_config"
      },
      "id": "ssh",
      "title": [
        {
          "#text": "Verify Permissions on SSH Server config file",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then chmod 0600 /etc/ssh/sshd_config else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "SSH Server",
        "gid": "ssh",
        "rid": "file_permissions_sshd_private_key",
        "fix_id": "file_permissions_sshd_private_key"
      },
      "id": "ssh",
      "title": [
        {
          "#text": "Verify Permissions on SSH Server Private *_key Key Files",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then readarray -t files &lt; &lt;(find /etc/ssh/) for file in \"${files[@]}\"; do if basename $file | grep -qE '^.*_key$'; then chmod 0600 $file fi done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "SSH Server",
        "gid": "ssh",
        "rid": "file_permissions_sshd_pub_key",
        "fix_id": "file_permissions_sshd_pub_key"
      },
      "id": "ssh",
      "title": [
        {
          "#text": "Verify Permissions on SSH Server Public *.pub Key Files",
          "@_lang": "en-US"
        }
      ],
      "desc": "To properly set the permissions of, run the command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then readarray -t files &lt; &lt;(find /etc/ssh/) for file in \"${files[@]}\"; do if basename $file | grep -qE '^.*.pub$'; then chmod 0644 $file fi done else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "critical",
        "gtitle": "SSH Server",
        "gid": "ssh",
        "rid": "iptables_sshd_disabled"
      },
      "id": "ssh",
      "title": [
        {
          "#text": "Remove SSH Server iptables Firewall exception (Unusual)",
          "@_lang": "en-US"
        }
      ],
      "desc": "By default, inbound connections to SSH's port are allowed. If the SSH server is not being used, this exception should be removed from the firewall configuration.Edit the filesand(if IPv6 is in use). In each file, locate and delete the line:This is unusual, as SSH is a common method for encrypted and authenticated remote access.",
      "impact": 1,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "disable_host_auth",
        "fix_id": "disable_host_auth"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Disable Host-Based Authentication",
          "@_lang": "en-US"
        }
      ],
      "desc": "SSH's cryptographic host-based authentication is more secure thanauthentication. However, it is not recommended that hosts unilaterally trust one another, even within an organization.To disable host-based authentication, add or correct the following line in:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*HostbasedAuthentication\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"HostbasedAuthentication no\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"HostbasedAuthentication no\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_allow_only_protocol2"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Allow Only SSH Protocol 2",
          "@_lang": "en-US"
        }
      ],
      "desc": "Only SSH protocol version 2 connections should be permitted. The default setting inis correct, and can be verified by ensuring that the following line appears:",
      "impact": 0.7,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_disable_compression"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Disable Compression Or Set Compression to delayed",
          "@_lang": "en-US"
        }
      ],
      "desc": "Compression is useful for slow network connections over long distances but can cause performance issues on local LANs. If use of compression is required, it should be enabled only after a user has authenticated; otherwise, it should be disabled. To disable compression or delay compression until after a user has successfully authenticated, add or correct the following line in thefile:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_disable_empty_passwords",
        "fix_id": "sshd_disable_empty_passwords"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Disable SSH Access via Empty Passwords",
          "@_lang": "en-US"
        }
      ],
      "desc": "To explicitly disallow SSH login from accounts with empty passwords, add or correct the following line in:Any accounts with empty passwords should be disabled immediately, and PAM configuration should prevent users from being able to assign themselves empty passwords.",
      "impact": 0.7,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*PermitEmptyPasswords\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"PermitEmptyPasswords no\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"PermitEmptyPasswords no\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_disable_gssapi_auth",
        "fix_id": "sshd_disable_gssapi_auth"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Disable GSSAPI Authentication",
          "@_lang": "en-US"
        }
      ],
      "desc": "Unless needed, SSH should not permit extraneous or unnecessary authentication mechanisms like GSSAPI. To disable GSSAPI authentication, add or correct the following line in thefile:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*GSSAPIAuthentication\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"GSSAPIAuthentication no\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"GSSAPIAuthentication no\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_disable_kerb_auth",
        "fix_id": "sshd_disable_kerb_auth"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Disable Kerberos Authentication",
          "@_lang": "en-US"
        }
      ],
      "desc": "Unless needed, SSH should not permit extraneous or unnecessary authentication mechanisms like Kerberos. To disable Kerberos authentication, add or correct the following line in thefile:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*KerberosAuthentication\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"KerberosAuthentication no\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"KerberosAuthentication no\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_disable_pubkey_auth",
        "fix_id": "sshd_disable_pubkey_auth"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Disable PubkeyAuthentication Authentication",
          "@_lang": "en-US"
        }
      ],
      "desc": "Unless needed, SSH should not permit extraneous or unnecessary authentication mechanisms. To disable PubkeyAuthentication authentication, add or correct the following line in thefile:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*PubkeyAuthentication\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"PubkeyAuthentication no\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"PubkeyAuthentication no\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_disable_rhosts",
        "fix_id": "sshd_disable_rhosts"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Disable SSH Support for .rhosts Files",
          "@_lang": "en-US"
        }
      ],
      "desc": "SSH can emulate the behavior of the obsolete rsh command in allowing users to enable insecure access to their accounts viafiles.To ensure this behavior is disabled, add or correct the following line in:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*IgnoreRhosts\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"IgnoreRhosts yes\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"IgnoreRhosts yes\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_disable_rhosts_rsa"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Disable SSH Support for Rhosts RSA Authentication",
          "@_lang": "en-US"
        }
      ],
      "desc": "SSH can allow authentication through the obsolete rsh command through the use of the authenticating user's SSH keys. This should be disabled.To ensure this behavior is disabled, add or correct the following line in:",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_disable_root_login",
        "fix_id": "sshd_disable_root_login"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Disable SSH Root Login",
          "@_lang": "en-US"
        }
      ],
      "desc": "The root user should never be allowed to login to a system directly over a network. To disable root login via SSH, add or correct the following line in:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*PermitRootLogin\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"PermitRootLogin no\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"PermitRootLogin no\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_disable_root_password_login",
        "fix_id": "sshd_disable_root_password_login"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Disable SSH root Login with a Password (Insecure)",
          "@_lang": "en-US"
        }
      ],
      "desc": "To disable password-based root logins over SSH, add or correct the following line in:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*PermitRootLogin\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"PermitRootLogin prohibit-password\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"PermitRootLogin prohibit-password\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_disable_tcp_forwarding",
        "fix_id": "sshd_disable_tcp_forwarding"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Disable SSH TCP Forwarding",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theparameter specifies whether TCP forwarding is permitted. To disable TCP forwarding, add or correct the following line in:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*AllowTcpForwarding\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"AllowTcpForwarding no\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"AllowTcpForwarding no\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_disable_user_known_hosts",
        "fix_id": "sshd_disable_user_known_hosts"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Disable SSH Support for User Known Hosts",
          "@_lang": "en-US"
        }
      ],
      "desc": "SSH can allow system users to connect to systems if a cache of the remote systems public keys is available. This should be disabled.To ensure this behavior is disabled, add or correct the following line in:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*IgnoreUserKnownHosts\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"IgnoreUserKnownHosts yes\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"IgnoreUserKnownHosts yes\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_disable_x11_forwarding",
        "fix_id": "sshd_disable_x11_forwarding"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Disable X11 Forwarding",
          "@_lang": "en-US"
        }
      ],
      "desc": "The X11Forwarding parameter provides the ability to tunnel X11 traffic through the connection to enable remote graphic connections. SSH has the capability to encrypt remote X11 connections when SSH'soption is enabled.To disable X11 Forwarding, add or correct the following line in:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*X11Forwarding\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"X11Forwarding no\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"X11Forwarding no\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_do_not_permit_user_env",
        "fix_id": "sshd_do_not_permit_user_env"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Do Not Allow SSH Environment Options",
          "@_lang": "en-US"
        }
      ],
      "desc": "To ensure users are not able to override environment variables of the SSH daemon, add or correct the following line in:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*PermitUserEnvironment\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"PermitUserEnvironment no\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"PermitUserEnvironment no\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_enable_gssapi_auth",
        "fix_id": "sshd_enable_gssapi_auth"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Enable GSSAPI Authentication",
          "@_lang": "en-US"
        }
      ],
      "desc": "Sites setup to use Kerberos or other GSSAPI Authenticaion require setting sshd to accept this authentication. To enable GSSAPI authentication, add or correct the following line in thefile:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*GSSAPIAuthentication\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"GSSAPIAuthentication yes\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"GSSAPIAuthentication yes\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_enable_pam",
        "fix_id": "sshd_enable_pam"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Enable PAM",
          "@_lang": "en-US"
        }
      ],
      "desc": "UsePAM Enables the Pluggable Authentication Module interface. If set to yes this will enable PAM authentication using ChallengeResponseAuthentication and PasswordAuthentication in addition to PAM account and session module processing for all authentication types. To enable PAM authentication, add or correct the following line in thefile:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*UsePAM\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"UsePAM yes\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"UsePAM yes\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_enable_pubkey_auth",
        "fix_id": "sshd_enable_pubkey_auth"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Enable PubkeyAuthentication",
          "@_lang": "en-US"
        }
      ],
      "desc": "Verify the sshd daemon allows public key authentication with the following:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*PubkeyAuthentication\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"PubkeyAuthentication yes\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"PubkeyAuthentication yes\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_enable_strictmodes",
        "fix_id": "sshd_enable_strictmodes"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Enable Use of Strict Mode Checking",
          "@_lang": "en-US"
        }
      ],
      "desc": "SSHsoption checks file and ownership permissions in the user's home directoryfolder before accepting login. If world- writable permissions are found, logon is rejected. To enablein SSH, add or correct the following line in thefile:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*StrictModes\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"StrictModes yes\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"StrictModes yes\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_enable_warning_banner",
        "fix_id": "sshd_enable_warning_banner"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Enable SSH Warning Banner",
          "@_lang": "en-US"
        }
      ],
      "desc": "To enable the warning banner and ensure it is consistent across the system, add or correct the following line in:Another section contains information on how to create an appropriate system-wide warning banner.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*Banner\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"Banner /etc/issue\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"Banner /etc/issue\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_enable_warning_banner_net",
        "fix_id": "sshd_enable_warning_banner_net"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Enable SSH Warning Banner",
          "@_lang": "en-US"
        }
      ],
      "desc": "To enable the warning banner and ensure it is consistent across the system, add or correct the following line in:Another section contains information on how to create an appropriate system-wide warning banner.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*Banner\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"Banner /etc/issue.net\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"Banner /etc/issue.net\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_enable_x11_forwarding",
        "fix_id": "sshd_enable_x11_forwarding"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Enable Encrypted X11 Forwarding",
          "@_lang": "en-US"
        }
      ],
      "desc": "By default, remote X11 connections are not encrypted when initiated by users. SSH has the capability to encrypt remote X11 connections when SSH'soption is enabled.To enable X11 Forwarding, add or correct the following line in:",
      "impact": 0.7,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*X11Forwarding\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"X11Forwarding yes\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"X11Forwarding yes\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "critical",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_limit_user_access"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Limit Users' SSH Access",
          "@_lang": "en-US"
        }
      ],
      "desc": "By default, the SSH configuration allows any user with an account to access the system. In order to specify the users that are allowed to login via SSH and deny all other users, add or correct the following line in thefile:Whereandare valid user names.",
      "impact": 1,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_print_last_log",
        "fix_id": "sshd_print_last_log"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Enable SSH Print Last Log",
          "@_lang": "en-US"
        }
      ],
      "desc": "When enabled, SSH will display the date and time of the last successful account logon. To enable LastLog in SSH, add or correct the following line in thefile:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*PrintLastLog\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"PrintLastLog yes\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"PrintLastLog yes\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_rekey_limit",
        "fix_id": "sshd_rekey_limit"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Force frequent session key renegotiation",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theparameter specifies how often the session key of the is renegotiated, both in terms of amount of data that may be transmitted and the time elapsed. To decrease the default limits, put lineto file.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then var_rekey_limit_size='' var_rekey_limit_time='' if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*RekeyLimit\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"RekeyLimit $var_rekey_limit_size $var_rekey_limit_time\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"RekeyLimit $var_rekey_limit_size $var_rekey_limit_time\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_set_idle_timeout",
        "fix_id": "sshd_set_idle_timeout"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Set SSH Idle Timeout Interval",
          "@_lang": "en-US"
        }
      ],
      "desc": "SSH allows administrators to set an idle timeout interval. After this interval has passed, the idle user will be automatically logged out.To set an idle timeout interval, edit the following line inas follows:The timeoutis given in seconds. For example, have a timeout of 10 minutes, setto 600.If a shorter timeout has already been set for the login shell, that value will preempt any SSH setting made in. Keep in mind that some processes may stop SSH from correctly detecting that the user is idle.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sshd_idle_timeout_value='' if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*ClientAliveInterval\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"ClientAliveInterval $sshd_idle_timeout_value\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"ClientAliveInterval $sshd_idle_timeout_value\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_set_keepalive",
        "fix_id": "sshd_set_keepalive"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Set SSH Client Alive Count Max",
          "@_lang": "en-US"
        }
      ],
      "desc": "The SSH server sends at mostmessages during a SSH session and waits for a response from the SSH client. The optionconfigures timeout after eachmessage. If the SSH server does not receive a response from the client, then the connection is considered idle and terminated. For SSH earlier than v8.2, avalue ofcauses an idle timeout precisely when theis set. Starting with v8.2, a value ofdisables the timeout functionality completely. If the option is set to a number greater than, then the idle session will be disconnected afterseconds.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then var_sshd_set_keepalive='' if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*ClientAliveCountMax\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"ClientAliveCountMax $var_sshd_set_keepalive\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"ClientAliveCountMax $var_sshd_set_keepalive\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_set_keepalive_0",
        "fix_id": "sshd_set_keepalive_0"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Set SSH Client Alive Count Max to zero",
          "@_lang": "en-US"
        }
      ],
      "desc": "The SSH server sends at mostmessages during a SSH session and waits for a response from the SSH client. The optionconfigures timeout after eachmessage. If the SSH server does not receive a response from the client, then the connection is considered idle and terminated. To ensure the SSH idle timeout occurs precisely when theis set, set theto value of.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*ClientAliveCountMax\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"ClientAliveCountMax 0\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"ClientAliveCountMax 0\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_set_login_grace_time",
        "fix_id": "sshd_set_login_grace_time"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Set SSH LoginGraceTime limit",
          "@_lang": "en-US"
        }
      ],
      "desc": "The LoginGraceTime parameter specifies the time allowed for successful authentication to the SSH server. The longer the Grace period is the more open unauthenticated connections can exist. Like other session controls in this session the Grace Period should be limited to appropriate organizational limits to ensure the service is available for needed access. To set LoginGraceTime editas follows:Note: Local site policy may be more restrictive.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then var_sshd_login_grace_time='' if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*LoginGraceTime\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"LoginGraceTime $var_sshd_login_grace_time\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"LoginGraceTime $var_sshd_login_grace_time\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_set_loglevel_info",
        "fix_id": "sshd_set_loglevel_info"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Set LogLevel to INFO",
          "@_lang": "en-US"
        }
      ],
      "desc": "The INFO parameter specifices that record login and logout activity will be logged. To specify the log level in SSH, add or correct the following line in thefile:",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*LogLevel\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"LogLevel INFO\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"LogLevel INFO\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_set_loglevel_info_or_verbose",
        "fix_id": "sshd_set_loglevel_info_or_verbose"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Set LogLevel to INFO or VERBOSE",
          "@_lang": "en-US"
        }
      ],
      "desc": "The LogLevel parameter specifices that record login and logout activity will be logged. To specify the log level in SSH, add or correct the following line in thefile:or",
      "impact": 0.3,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then #!/bin/bash var_sshd_set_loglevel='' if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*LogLevel\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"LogLevel $var_sshd_set_loglevel\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"LogLevel $var_sshd_set_loglevel\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_set_loglevel_verbose",
        "fix_id": "sshd_set_loglevel_verbose"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Set SSH Daemon LogLevel to VERBOSE",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theparameter configures the SSH daemon to record login and logout activity. To specify the log level in SSH, add or correct the following line in thefile:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*LogLevel\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"LogLevel VERBOSE\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"LogLevel VERBOSE\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_set_max_auth_tries",
        "fix_id": "sshd_set_max_auth_tries"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Set SSH authentication attempt limit",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theparameter specifies the maximum number of authentication attempts permitted per connection. Once the number of failures reaches half this value, additional failures are logged. to set MaxAUthTries editas follows:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sshd_max_auth_tries_value='' if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*MaxAuthTries\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"MaxAuthTries $sshd_max_auth_tries_value\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"MaxAuthTries $sshd_max_auth_tries_value\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_set_max_sessions",
        "fix_id": "sshd_set_max_sessions"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Set SSH MaxSessions limit",
          "@_lang": "en-US"
        }
      ],
      "desc": "Theparameter specifies the maximum number of open sessions permitted from a given connection. To set MaxSessions editas follows:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then var_sshd_max_sessions='' if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*MaxSessions\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"MaxSessions $var_sshd_max_sessions\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"MaxSessions $var_sshd_max_sessions\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_set_maxstartups",
        "fix_id": "sshd_set_maxstartups"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Ensure SSH MaxStartups is configured",
          "@_lang": "en-US"
        }
      ],
      "desc": "The MaxStartups parameter specifies the maximum number of concurrent unauthenticated connections to the SSH daemon. Additional connections will be dropped until authentication succeeds or the LoginGraceTime expires for a connection. To confgure MaxStartups, you should add or correct the following line in thefile:CIS recommends a MaxStartups value of '10:30:60', or more restrictive where dictated by site policy.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then var_sshd_set_maxstartups='' if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*MaxStartups\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"MaxStartups $var_sshd_set_maxstartups\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"MaxStartups $var_sshd_set_maxstartups\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_use_approved_ciphers",
        "fix_id": "sshd_use_approved_ciphers"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Use Only Approved Ciphers",
          "@_lang": "en-US"
        }
      ],
      "desc": "Limit the ciphers to those algorithms which are approved. Counter (CTR) mode is also preferred over cipher-block chaining (CBC) mode. The following line indemonstrates use of approved ciphers:The man pagecontains a list of supported ciphers. The rule is parametrized to use the following ciphers:.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sshd_approved_ciphers='' # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/ssh/sshd_config\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^Ciphers\") # shellcheck disable=SC2059 printf -v formatted_output \"%s %s\" \"$stripped_key\" \"$sshd_approved_ciphers\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^Ciphers\\\\&gt;\" \"/etc/ssh/sshd_config\"; then \"${sed_command[@]}\" \"s/^Ciphers\\\\&gt;.*/$formatted_output/gi\" \"/etc/ssh/sshd_config\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/ssh/sshd_config\" &gt;&gt; \"/etc/ssh/sshd_config\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/ssh/sshd_config\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_use_approved_ciphers_ordered_stig",
        "fix_id": "sshd_use_approved_ciphers_ordered_stig"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Use Only FIPS 140-2 Validated Ciphers",
          "@_lang": "en-US"
        }
      ],
      "desc": "Limit the ciphers to those algorithms which are FIPS-approved. The following line indemonstrates use of FIPS-approved ciphers:This rule ensures that there are configured ciphers mentioned above (or their subset), keeping the given order of algorithms.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if grep -q -P '^\\s*[Cc]iphers\\s+' /etc/ssh/sshd_config; then sed -i 's/^\\s*[Cc]iphers.*/Ciphers aes256-ctr,aes192-ctr,aes128-ctr/' /etc/ssh/sshd_config else echo \"Ciphers aes256-ctr,aes192-ctr,aes128-ctr\" &gt;&gt; /etc/ssh/sshd_config fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_use_approved_kexs",
        "fix_id": "sshd_use_approved_kexs"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Use Only Approved KEXs",
          "@_lang": "en-US"
        }
      ],
      "desc": "Limit the KEXs to those key exchange algorithms which are approved. The following line indemonstrates use of approved KEXs:The man pagecontains a list of supported MACs. The rule is parametrized to use the following KEXs:.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sshd_approved_kexs='' # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/ssh/sshd_config\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^KexAlgorithms\") # shellcheck disable=SC2059 printf -v formatted_output \"%s %s\" \"$stripped_key\" \"$sshd_approved_kexs\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^KexAlgorithms\\\\&gt;\" \"/etc/ssh/sshd_config\"; then \"${sed_command[@]}\" \"s/^KexAlgorithms\\\\&gt;.*/$formatted_output/gi\" \"/etc/ssh/sshd_config\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/ssh/sshd_config\" &gt;&gt; \"/etc/ssh/sshd_config\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/ssh/sshd_config\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_use_approved_macs",
        "fix_id": "sshd_use_approved_macs"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Use Only Approved MACs",
          "@_lang": "en-US"
        }
      ],
      "desc": "Limit the MACs to those hash algorithms which are approved. The following line indemonstrates use of approved MACs:The man pagecontains a list of supported MACs. The rule is parametrized to use the following MACs:.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then sshd_approved_macs='' # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/ssh/sshd_config\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^MACs\") # shellcheck disable=SC2059 printf -v formatted_output \"%s %s\" \"$stripped_key\" \"$sshd_approved_macs\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^MACs\\\\&gt;\" \"/etc/ssh/sshd_config\"; then \"${sed_command[@]}\" \"s/^MACs\\\\&gt;.*/$formatted_output/gi\" \"/etc/ssh/sshd_config\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/ssh/sshd_config\" &gt;&gt; \"/etc/ssh/sshd_config\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/ssh/sshd_config\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_use_approved_macs_ordered_stig",
        "fix_id": "sshd_use_approved_macs_ordered_stig"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Use Only FIPS 140-2 Validated MACs",
          "@_lang": "en-US"
        }
      ],
      "desc": "Limit the MACs to those hash algorithms which are FIPS-approved. The following line indemonstrates use of FIPS-approved MACs:This rule ensures that there are configured MACs mentioned above (or their subset), keeping the given order of algorithms.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if grep -q -P '^\\s*MACs\\s+' /etc/ssh/sshd_config; then sed -i 's/^\\s*MACs.*/MACs hmac-sha2-512,hmac-sha2-256/' /etc/ssh/sshd_config else echo \"MACs hmac-sha2-512,hmac-sha2-256\" &gt;&gt; /etc/ssh/sshd_config fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_use_priv_separation",
        "fix_id": "sshd_use_priv_separation"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Enable Use of Privilege Separation",
          "@_lang": "en-US"
        }
      ],
      "desc": "When enabled, SSH will create an unprivileged child process that has the privilege of the authenticated user. To enable privilege separation in SSH, add or correct the following line in thefile:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then var_sshd_priv_separation='' if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*UsePrivilegeSeparation\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"UsePrivilegeSeparation $var_sshd_priv_separation\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"UsePrivilegeSeparation $var_sshd_priv_separation\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Configure OpenSSH Server if Necessary",
        "gid": "ssh_server",
        "rid": "sshd_x11_use_localhost",
        "fix_id": "sshd_x11_use_localhost"
      },
      "id": "ssh_server",
      "title": [
        {
          "#text": "Prevent remote hosts from connecting to the proxy display",
          "@_lang": "en-US"
        }
      ],
      "desc": "The SSH daemon should prevent remote hosts from connecting to the proxy display. Make sure that the optionis set towithin the SSH server configuration file.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*X11UseLocalhost\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"X11UseLocalhost yes\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"X11UseLocalhost yes\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Ensure SSH Access is Limited",
        "gid": "sshd_user_access_limited",
        "rid": "sshd_configure_allow_groups",
        "fix_id": "sshd_configure_allow_groups"
      },
      "id": "sshd_user_access_limited",
      "title": [
        {
          "#text": "Restrict sshd user access via AllowGroups",
          "@_lang": "en-US"
        }
      ],
      "desc": "AllowGroups gives the system administrator the option of allowing specific groups to ssh into the system. - The list consists of space separated group names - Numeric group IDs are not recognized with this variable",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then var_sshd_allow_groups_valid='' # We don't add the default magic value to the sshd config file, since it's a security risk. default_value=\"e39d05b72f25767869d44391919434896bb055772d7969f74472032b03bc18418911f3b0e6dd47ff8f3b2323728225286c3cb36914d28dc7db40bdd786159c0a\" if [ \"${var_sshd_allow_groups_valid}\" != ${default_value} ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*AllowGroups\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"AllowGroups $var_sshd_allow_groups_valid\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"AllowGroups $var_sshd_allow_groups_valid\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Ensure SSH Access is Limited",
        "gid": "sshd_user_access_limited",
        "rid": "sshd_configure_allow_users",
        "fix_id": "sshd_configure_allow_users"
      },
      "id": "sshd_user_access_limited",
      "title": [
        {
          "#text": "Restrict sshd user access via AllowUsers",
          "@_lang": "en-US"
        }
      ],
      "desc": "AllowUsers gives the system administrator the option of allowing specific users to ssh into the system. - The list consists of space separated user names - Numeric user IDs are not recognized with this variable - A system administrator may restrict user access further by only allowing the allowed users to log in from a particular host by specifying the entry as user@host.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then var_sshd_allow_users_valid='' # We don't add the default magic value to the sshd config file, since it's a security risk. default_value=\"e39d05b72f25767869d44391919434896bb055772d7969f74472032b03bc18418911f3b0e6dd47ff8f3b2323728225286c3cb36914d28dc7db40bdd786159c0a\" if [ \"${var_sshd_allow_users_valid}\" != ${default_value} ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*AllowUsers\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"AllowUsers $var_sshd_allow_users_valid\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"AllowUsers $var_sshd_allow_users_valid\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Ensure SSH Access is Limited",
        "gid": "sshd_user_access_limited",
        "rid": "sshd_configure_deny_groups",
        "fix_id": "sshd_configure_deny_groups"
      },
      "id": "sshd_user_access_limited",
      "title": [
        {
          "#text": "Restrict sshd user access via DenyGroups",
          "@_lang": "en-US"
        }
      ],
      "desc": "DenyGroups gives the system administrator the option of denying specific groups to ssh into the system. - The list consists of space separated group names. - Numeric group IDs are not recognized with this variable.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then var_sshd_deny_groups_valid='' # We don't add the default magic value to the sshd config file, since it's a security risk. default_value=\"e39d05b72f25767869d44391919434896bb055772d7969f74472032b03bc18418911f3b0e6dd47ff8f3b2323728225286c3cb36914d28dc7db40bdd786159c0a\" if [ \"${var_sshd_deny_groups_valid}\" != ${default_value} ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*DenyGroups\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"DenyGroups $var_sshd_deny_groups_valid\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"DenyGroups $var_sshd_deny_groups_valid\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Ensure SSH Access is Limited",
        "gid": "sshd_user_access_limited",
        "rid": "sshd_configure_deny_users",
        "fix_id": "sshd_configure_deny_users"
      },
      "id": "sshd_user_access_limited",
      "title": [
        {
          "#text": "Restrict sshd user access via DenyUsers",
          "@_lang": "en-US"
        }
      ],
      "desc": "DenyUsers gives the system administrator the option of denying specific users to ssh into the system. - The list consists of space separated user names - Numeric user IDs are not recognized with this variable - A system administrator may restrict user access further by only allowing the allowed users to log in from a particular host by specifying the entry as user@host.",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then var_sshd_deny_users_valid='' # We don't add the default magic value to the sshd config file, since it's a security risk. default_value=\"e39d05b72f25767869d44391919434896bb055772d7969f74472032b03bc18418911f3b0e6dd47ff8f3b2323728225286c3cb36914d28dc7db40bdd786159c0a\" if [ \"${var_sshd_deny_users_valid}\" != ${default_value} ]; then if [ -e \"/etc/ssh/sshd_config\" ] ; then LC_ALL=C sed -i \"/^\\s*DenyUsers\\s\\+/Id\" \"/etc/ssh/sshd_config\" else touch \"/etc/ssh/sshd_config\" fi cp \"/etc/ssh/sshd_config\" \"/etc/ssh/sshd_config.bak\" # Insert before the line matching the regex '^Match'. line_number=\"$(LC_ALL=C grep -n \"^Match\" \"/etc/ssh/sshd_config.bak\" | LC_ALL=C sed 's/:.*//g')\" if [ -z \"$line_number\" ]; then # There was no match of '^Match', insert at # the end of the file. printf '%s ' \"DenyUsers $var_sshd_deny_users_valid\" &gt;&gt; \"/etc/ssh/sshd_config\" else head -n \"$(( line_number - 1 ))\" \"/etc/ssh/sshd_config.bak\" &gt; \"/etc/ssh/sshd_config\" printf '%s ' \"DenyUsers $var_sshd_deny_users_valid\" &gt;&gt; \"/etc/ssh/sshd_config\" tail -n \"+$(( line_number ))\" \"/etc/ssh/sshd_config.bak\" &gt;&gt; \"/etc/ssh/sshd_config\" fi # Clean up after ourselves. rm \"/etc/ssh/sshd_config.bak\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "System Security Services Daemon",
        "gid": "sssd",
        "rid": "sssd_offline_cred_expiration",
        "fix_id": "sssd_offline_cred_expiration"
      },
      "id": "sssd",
      "title": [
        {
          "#text": "Configure SSSD to Expire Offline Credentials",
          "@_lang": "en-US"
        }
      ],
      "desc": "SSSD should be configured to expire offline credentials after 1 day. To configure SSSD to expire offline credentials, settounder thesection in. For example:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'sssd-common' 2&gt;/dev/null | grep -q installed &amp;&amp; { [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; }; then SSSD_CONF=\"/etc/sssd/sssd.conf\" SSSD_OPT=\"offline_credentials_expiration\" SSSD_OPT_VAL=1 PAM_REGEX=\"[[:space:]]*\\[pam]\" PAM_OPT_REGEX=\"${PAM_REGEX}([^ \\[]* +)+?[[:space:]]*${SSSD_OPT}\" # Try find [pam] and offline_credentials_expiration in sssd.conf, if it exists # set it to 1, if it doesn't exist add it, if [pam] section doesn't exist add # the section and the configuration option. if grep -qzosP $PAM_OPT_REGEX $SSSD_CONF; then  sed -i \"s/${SSSD_OPT}[^( )]*/${SSSD_OPT} = ${SSSD_OPT_VAL}/\" $SSSD_CONF elif grep -qs $PAM_REGEX $SSSD_CONF; then  sed -i \"/$PAM_REGEX/a ${SSSD_OPT} = ${SSSD_OPT_VAL}\" $SSSD_CONF else  mkdir -p /etc/sssd  touch $SSSD_CONF  echo -e \"[pam] ${SSSD_OPT} = ${SSSD_OPT_VAL}\" &gt;&gt; $SSSD_CONF fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Sudo",
        "gid": "sudo",
        "rid": "package_sudo_installed",
        "fix_id": "package_sudo_installed"
      },
      "id": "sudo",
      "title": [
        {
          "#text": "Install sudo Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be installed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then DEBIAN_FRONTEND=noninteractive apt-get install -y \"sudo\" else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "high",
        "gtitle": "Sudo",
        "gid": "sudo",
        "rid": "sudo_add_noexec",
        "fix_id": "sudo_add_noexec"
      },
      "id": "sudo",
      "title": [
        {
          "#text": "Ensure Privileged Escalated Commands Cannot Execute Other Commands - sudo NOEXEC",
          "@_lang": "en-US"
        }
      ],
      "desc": "The sudotag, when specified, prevents user executed commands from executing other commands, like a shell for example. This should be enabled by making sure that thetag exists inconfiguration file or any sudo configuration snippets in.",
      "impact": 0.7,
      "descs": {
        "fix": "if /usr/sbin/visudo -qcf /etc/sudoers; then cp /etc/sudoers /etc/sudoers.bak if ! grep -P '^[\\s]*Defaults.*\\bnoexec\\b.*$' /etc/sudoers; then # sudoers file doesn't define Option noexec echo \"Defaults noexec\" &gt;&gt; /etc/sudoers fi # Check validity of sudoers and cleanup bak if /usr/sbin/visudo -qcf /etc/sudoers; then rm -f /etc/sudoers.bak else echo \"Fail to validate remediated /etc/sudoers, reverting to original file.\" mv /etc/sudoers.bak /etc/sudoers false fi else echo \"Skipping remediation, /etc/sudoers failed to validate\" false fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Sudo",
        "gid": "sudo",
        "rid": "sudo_add_requiretty",
        "fix_id": "sudo_add_requiretty"
      },
      "id": "sudo",
      "title": [
        {
          "#text": "Ensure Only Users Logged In To Real tty Can Execute Sudo - sudo requiretty",
          "@_lang": "en-US"
        }
      ],
      "desc": "The sudotag, when specified, will only execute sudo commands from users logged in to a real tty. This should be enabled by making sure that thetag exists inconfiguration file or any sudo configuration snippets in.",
      "impact": 0.5,
      "descs": {
        "fix": "if /usr/sbin/visudo -qcf /etc/sudoers; then cp /etc/sudoers /etc/sudoers.bak if ! grep -P '^[\\s]*Defaults.*\\brequiretty\\b.*$' /etc/sudoers; then # sudoers file doesn't define Option requiretty echo \"Defaults requiretty\" &gt;&gt; /etc/sudoers fi # Check validity of sudoers and cleanup bak if /usr/sbin/visudo -qcf /etc/sudoers; then rm -f /etc/sudoers.bak else echo \"Fail to validate remediated /etc/sudoers, reverting to original file.\" mv /etc/sudoers.bak /etc/sudoers false fi else echo \"Skipping remediation, /etc/sudoers failed to validate\" false fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Sudo",
        "gid": "sudo",
        "rid": "sudo_add_use_pty",
        "fix_id": "sudo_add_use_pty"
      },
      "id": "sudo",
      "title": [
        {
          "#text": "Ensure Only Users Logged In To Real tty Can Execute Sudo - sudo use_pty",
          "@_lang": "en-US"
        }
      ],
      "desc": "The sudotag, when specified, will only execute sudo commands from users logged in to a real tty. This should be enabled by making sure that thetag exists inconfiguration file or any sudo configuration snippets in.",
      "impact": 0.5,
      "descs": {
        "fix": "if /usr/sbin/visudo -qcf /etc/sudoers; then cp /etc/sudoers /etc/sudoers.bak if ! grep -P '^[\\s]*Defaults.*\\buse_pty\\b.*$' /etc/sudoers; then # sudoers file doesn't define Option use_pty echo \"Defaults use_pty\" &gt;&gt; /etc/sudoers fi # Check validity of sudoers and cleanup bak if /usr/sbin/visudo -qcf /etc/sudoers; then rm -f /etc/sudoers.bak else echo \"Fail to validate remediated /etc/sudoers, reverting to original file.\" mv /etc/sudoers.bak /etc/sudoers false fi else echo \"Skipping remediation, /etc/sudoers failed to validate\" false fi"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Sudo",
        "gid": "sudo",
        "rid": "sudo_custom_logfile",
        "fix_id": "sudo_custom_logfile"
      },
      "id": "sudo",
      "title": [
        {
          "#text": "Ensure Sudo Logfile Exists - sudo logfile",
          "@_lang": "en-US"
        }
      ],
      "desc": "A custom log sudo file can be configured with the 'logfile' tag. This rule configures a sudo custom logfile at the default location suggested by CIS, which uses /var/log/sudo.log.",
      "impact": 0.3,
      "descs": {
        "fix": "var_sudo_logfile='' if /usr/sbin/visudo -qcf /etc/sudoers; then cp /etc/sudoers /etc/sudoers.bak if ! grep -P '^[\\s]*Defaults.*\\blogfile=(\"(?:\\\\\"|\\\\\\\\|[^\"\\\\ ])*\"\\B|[^\"](?:(?:\\\\,|\\\\\"|\\\\ |\\\\\\\\|[^\", \\\\ ])*)\\b)\\b.*$' /etc/sudoers; then # sudoers file doesn't define Option logfile echo \"Defaults logfile=${var_sudo_logfile}\" &gt;&gt; /etc/sudoers else # sudoers file defines Option logfile, remediate if appropriate value is not set if ! grep -P \"^[\\s]*Defaults.*\\blogfile=${var_sudo_logfile}\\b.*$\" /etc/sudoers; then sed -Ei \"s/(^[\\s]*Defaults.*\\blogfile=)[-]?\\w+(\\b.*$)/\\1${var_sudo_logfile}\\2/\" /etc/sudoers fi fi # Check validity of sudoers and cleanup bak if /usr/sbin/visudo -qcf /etc/sudoers; then rm -f /etc/sudoers.bak else echo \"Fail to validate remediated /etc/sudoers, reverting to original file.\" mv /etc/sudoers.bak /etc/sudoers false fi else echo \"Skipping remediation, /etc/sudoers failed to validate\" false fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Sudo",
        "gid": "sudo",
        "rid": "sudo_remove_no_authenticate",
        "fix_id": "sudo_remove_no_authenticate"
      },
      "id": "sudo",
      "title": [
        {
          "#text": "Ensure Users Re-Authenticate for Privilege Escalation - sudo !authenticate",
          "@_lang": "en-US"
        }
      ],
      "desc": "The sudooption, when specified, allows a user to execute commands using sudo without having to authenticate. This should be disabled by making sure that theoption does not exist inconfiguration file or any sudo configuration snippets in.",
      "impact": 0.5,
      "descs": {
        "fix": "for f in /etc/sudoers /etc/sudoers.d/* ; do if [ ! -e \"$f\" ] ; then continue fi matching_list=$(grep -P '^(?!#).*[\\s]+\\!authenticate.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do # comment out \"!authenticate\" matches to preserve user data sed -i \"s/^${entry}$/# &amp;/g\" $f done &lt;&lt;&lt; \"$matching_list\" /usr/sbin/visudo -cf $f &amp;&gt; /dev/null || echo \"Fail to validate $f with visudo\" fi done"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Sudo",
        "gid": "sudo",
        "rid": "sudo_remove_nopasswd",
        "fix_id": "sudo_remove_nopasswd"
      },
      "id": "sudo",
      "title": [
        {
          "#text": "Ensure Users Re-Authenticate for Privilege Escalation - sudo NOPASSWD",
          "@_lang": "en-US"
        }
      ],
      "desc": "The sudotag, when specified, allows a user to execute commands using sudo without having to authenticate. This should be disabled by making sure that thetag does not exist inconfiguration file or any sudo configuration snippets in.",
      "impact": 0.5,
      "descs": {
        "fix": "for f in /etc/sudoers /etc/sudoers.d/* ; do if [ ! -e \"$f\" ] ; then continue fi matching_list=$(grep -P '^(?!#).*[\\s]+NOPASSWD[\\s]*\\:.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do # comment out \"NOPASSWD\" matches to preserve user data sed -i \"s/^${entry}$/# &amp;/g\" $f done &lt;&lt;&lt; \"$matching_list\" /usr/sbin/visudo -cf $f &amp;&gt; /dev/null || echo \"Fail to validate $f with visudo\" fi done"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Sudo",
        "gid": "sudo",
        "rid": "sudo_require_authentication",
        "fix_id": "sudo_require_authentication"
      },
      "id": "sudo",
      "title": [
        {
          "#text": "Ensure Users Re-Authenticate for Privilege Escalation - sudo",
          "@_lang": "en-US"
        }
      ],
      "desc": "The sudoandoption, when specified, allows a user to execute commands using sudo without having to authenticate. This should be disabled by making sure thatand/ordo not exist inconfiguration file or any sudo configuration snippets in.\"",
      "impact": 0.5,
      "descs": {
        "fix": "for f in /etc/sudoers /etc/sudoers.d/* ; do if [ ! -e \"$f\" ] ; then continue fi matching_list=$(grep -P '^(?!#).*[\\s]+NOPASSWD[\\s]*\\:.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do # comment out \"NOPASSWD\" matches to preserve user data sed -i \"s/^${entry}$/# &amp;/g\" $f done &lt;&lt;&lt; \"$matching_list\" /usr/sbin/visudo -cf $f &amp;&gt; /dev/null || echo \"Fail to validate $f with visudo\" fi done for f in /etc/sudoers /etc/sudoers.d/* ; do if [ ! -e \"$f\" ] ; then continue fi matching_list=$(grep -P '^(?!#).*[\\s]+\\!authenticate.*$' $f | uniq ) if ! test -z \"$matching_list\"; then while IFS= read -r entry; do # comment out \"!authenticate\" matches to preserve user data sed -i \"s/^${entry}$/# &amp;/g\" $f done &lt;&lt;&lt; \"$matching_list\" /usr/sbin/visudo -cf $f &amp;&gt; /dev/null || echo \"Fail to validate $f with visudo\" fi done"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Sudo",
        "gid": "sudo",
        "rid": "sudo_vdsm_nopasswd"
      },
      "id": "sudo",
      "title": [
        {
          "#text": "Only the VDSM User Can Use sudo NOPASSWD",
          "@_lang": "en-US"
        }
      ],
      "desc": "The sudotag, when specified, allows a user to execute commands using sudo without having to authenticate. Only theuser should have this capability in any sudo configuration snippets in.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Sudo",
        "gid": "sudo",
        "rid": "sudoers_explicit_command_args"
      },
      "id": "sudo",
      "title": [
        {
          "#text": "Explicit arguments in sudo specifications",
          "@_lang": "en-US"
        }
      ],
      "desc": "All commands in the sudoers file must strictly specify the arguments allowed to be used for a given user. If the command is supposed to be executed only without arguments, pass \"\" as an argument in the corresponding user specification.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Sudo",
        "gid": "sudo",
        "rid": "sudoers_no_command_negation"
      },
      "id": "sudo",
      "title": [
        {
          "#text": "Don't define allowed commands in sudoers by means of exclusion",
          "@_lang": "en-US"
        }
      ],
      "desc": "Policies applied by sudo through the sudoers file should not involve negation. Each user specification in thefile contains a comma-delimited list of command specifications. The definition can make use glob patterns, as well as of negations. Indirect definition of those commands by means of exclusion of a set of commands is trivial to bypass, so it is not allowed to use such constructs.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Sudo",
        "gid": "sudo",
        "rid": "sudoers_no_root_target"
      },
      "id": "sudo",
      "title": [
        {
          "#text": "Don't target root user in the sudoers file",
          "@_lang": "en-US"
        }
      ],
      "desc": "The targeted users of a user specification should be, as much as possible, non privileged users (i.e.: non-root). User specifications have to explicitly list the runas spec (i.e. the list of target users that can be impersonated), andorshould not be used.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "System Tooling / Utilities",
        "gid": "system-tools",
        "rid": "package_gnutls-utils_installed",
        "fix_id": "package_gnutls-utils_installed"
      },
      "id": "system-tools",
      "title": [
        {
          "#text": "Ensure gnutls-utils is installed",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be installed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "DEBIAN_FRONTEND=noninteractive apt-get install -y \"gnutls-utils\""
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "System Tooling / Utilities",
        "gid": "system-tools",
        "rid": "package_nss-tools_installed",
        "fix_id": "package_nss-tools_installed"
      },
      "id": "system-tools",
      "title": [
        {
          "#text": "Ensure nss-tools is installed",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage can be installed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "DEBIAN_FRONTEND=noninteractive apt-get install -y \"nss-tools\""
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Chat/Messaging Services",
        "gid": "talk",
        "rid": "package_talk_removed",
        "fix_id": "package_talk_removed"
      },
      "id": "talk",
      "title": [
        {
          "#text": "Uninstall talk Package",
          "@_lang": "en-US"
        }
      ],
      "desc": "Thepackage contains the client program for the Internet talk protocol, which allows the user to chat with other users on different systems. Talk is a communication program which copies lines from one terminal to the terminal of another user. Thepackage can be removed with the following command:",
      "impact": 0.5,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove talk #  from the system, and may remove any packages #  that depend on talk. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"talk\""
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Telnet",
        "gid": "telnet",
        "rid": "package_telnet_removed",
        "fix_id": "package_telnet_removed"
      },
      "id": "telnet",
      "title": [
        {
          "#text": "Remove telnet Clients",
          "@_lang": "en-US"
        }
      ],
      "desc": "The telnet client allows users to start connections to other systems via the telnet protocol.",
      "impact": 0.3,
      "descs": {
        "fix": "# CAUTION: This remediation script will remove telnet #  from the system, and may remove any packages #  that depend on telnet. Execute this #  remediation AFTER testing on a non-production #  system! DEBIAN_FRONTEND=noninteractive apt-get remove -y \"telnet\""
      }
    },
    {
      "tags": {
        "severity": "high",
        "gtitle": "UEFI GRUB2 bootloader configuration",
        "gid": "uefi",
        "rid": "grub2_uefi_password"
      },
      "id": "uefi",
      "title": [
        {
          "#text": "Set the UEFI Boot Loader Password",
          "@_lang": "en-US"
        }
      ],
      "desc": "The grub2 boot loader should have a superuser account and password protection enabled to protect boot-time settings.Since plaintext passwords are a security risk, generate a hash for the password by running the following command:When prompted, enter the password that was selected.Using the hash from the output, modify thefile with the following content:NOTE: the bootloader superuser account and password MUST differ from the root account and password. Once the superuser password has been added, update thefile by running:",
      "impact": 0.7,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Ensure loopback traffic is configured",
        "gid": "ufw_ensure_loopback_configured",
        "rid": "ufw_allow_in_lo"
      },
      "id": "ufw_ensure_loopback_configured",
      "title": [
        {
          "#text": "Trafic in on lo is allowed",
          "@_lang": "en-US"
        }
      ],
      "desc": "UFW should be configured to allow all inbound traffic on the loopback interface.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Ensure loopback traffic is configured",
        "gid": "ufw_ensure_loopback_configured",
        "rid": "ufw_allow_out_lo"
      },
      "id": "ufw_ensure_loopback_configured",
      "title": [
        {
          "#text": "Traffic out on lo is allowed",
          "@_lang": "en-US"
        }
      ],
      "desc": "UFW should be configured to allow all outbound traffic on the loopback interface.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Ensure loopback traffic is configured",
        "gid": "ufw_ensure_loopback_configured",
        "rid": "ufw_deny_in_other_for_localhost"
      },
      "id": "ufw_ensure_loopback_configured",
      "title": [
        {
          "#text": "Inbound traffic for 127.0.0.0/8 on any other interface is denied.",
          "@_lang": "en-US"
        }
      ],
      "desc": "UFW should be configured to forbid all traffic for the localhost addresses (127.0.0.0/8) on interfaces other than the designated lo interface.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Ensure loopback traffic is configured",
        "gid": "ufw_ensure_loopback_configured",
        "rid": "ufw_deny_in_other_for_localhost6"
      },
      "id": "ufw_ensure_loopback_configured",
      "title": [
        {
          "#text": "Inbound traffic for ::1/128 on any other interface is denied.",
          "@_lang": "en-US"
        }
      ],
      "desc": "UFW should be configured to forbid all traffic for the localhost6 addresses (::1/128) on interfaces other than the designated lo interface.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "low",
        "gtitle": "Updating Software",
        "gid": "updating",
        "rid": "clean_components_post_updating",
        "fix_id": "clean_components_post_updating"
      },
      "id": "updating",
      "title": [
        {
          "#text": "Ensure apt_get Removes Previous Package Versions",
          "@_lang": "en-US"
        }
      ],
      "desc": "should be configured to remove previous software components after new versions have been installed. To configureto remove the previous software components after updating, set theandtoin.",
      "impact": 0.3,
      "descs": {
        "fix": "flag1=1 flag2=1 for file in /etc/apt/apt.conf.d/*; do if [ -e \"$file\" ]; then if grep -qi \"Unattended-Upgrade::Remove-Unused-Dependencies\" $file; then sed -i --follow-symlinks \"s/^.*Unattended-Upgrade::Remove-Unused-Dependencies.*/Unattended-Upgrade::Remove-Unused-Dependencies \\\"true\\\";/I\" $file flag1=0 fi if grep -qi \"Unattended-Upgrade::Remove-Unused-Kernel-Packages\" $file; then sed -i --follow-symlinks \"s/^.*Unattended-Upgrade::Remove-Unused-Kernel-Packages.*/Unattended-Upgrade::Remove-Unused-Kernel-Packages \\\"true\\\";/I\" $file flag2=0 fi fi done if [ $flag1 ] || [ $flag2 ]; then echo \"Unattended-Upgrade::Remove-Unused-Dependencies \\\"true\\\";\" &gt;&gt; /etc/apt/apt.conf.d/50unattended-upgrades echo \"Unattended-Upgrade::Remove-Unused-Kernel-Packages \\\"true\\\";\" &gt;&gt; /etc/apt/apt.conf.d/50unattended-upgrades fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Ensure that Users Have Sensible Umask Values",
        "gid": "user_umask",
        "rid": "accounts_umask_etc_bashrc",
        "fix_id": "accounts_umask_etc_bashrc"
      },
      "id": "user_umask",
      "title": [
        {
          "#text": "Ensure the Default Bash Umask is Set Correctly",
          "@_lang": "en-US"
        }
      ],
      "desc": "To ensure the default umask for users of the Bash shell is set properly, add or correct thesetting into read as follows:",
      "impact": 0.5,
      "descs": {
        "fix": "var_accounts_user_umask='' grep -q umask /etc/bashrc &amp;&amp; \\ sed -i \"s/umask.*/umask $var_accounts_user_umask/g\" /etc/bashrc if ! [ $? -eq 0 ]; then echo \"umask $var_accounts_user_umask\" &gt;&gt; /etc/bashrc fi"
      }
    },
    {
      "tags": {
        "severity": "critical",
        "gtitle": "Ensure that Users Have Sensible Umask Values",
        "gid": "user_umask",
        "rid": "accounts_umask_etc_csh_cshrc",
        "fix_id": "accounts_umask_etc_csh_cshrc"
      },
      "id": "user_umask",
      "title": [
        {
          "#text": "Ensure the Default C Shell Umask is Set Correctly",
          "@_lang": "en-US"
        }
      ],
      "desc": "To ensure the default umask for users of the C shell is set properly, add or correct thesetting into read as follows:",
      "impact": 1,
      "descs": {
        "fix": "var_accounts_user_umask='' grep -q umask /etc/csh.cshrc &amp;&amp; \\ sed -i \"s/umask.*/umask $var_accounts_user_umask/g\" /etc/csh.cshrc if ! [ $? -eq 0 ]; then echo \"umask $var_accounts_user_umask\" &gt;&gt; /etc/csh.cshrc fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Ensure that Users Have Sensible Umask Values",
        "gid": "user_umask",
        "rid": "accounts_umask_etc_login_defs",
        "fix_id": "accounts_umask_etc_login_defs"
      },
      "id": "user_umask",
      "title": [
        {
          "#text": "Ensure the Default Umask is Set Correctly in login.defs",
          "@_lang": "en-US"
        }
      ],
      "desc": "To ensure the default umask controlled byis set properly, add or correct thesetting into read as follows:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if dpkg-query --show --showformat='${db:Status-Status} ' 'login' 2&gt;/dev/null | grep -q installed; then var_accounts_user_umask='' # Test if the config_file is a symbolic link. If so, use --follow-symlinks with sed. # Otherwise, regular sed command will do. sed_command=('sed' '-i') if test -L \"/etc/login.defs\"; then sed_command+=('--follow-symlinks') fi # If the cce arg is empty, CCE is not assigned. if [ -z \"\" ]; then cce=\"CCE\" else cce=\"\" fi # Strip any search characters in the key arg so that the key can be replaced without # adding any search characters to the config file. stripped_key=$(sed 's/[\\^=\\$,;+]*//g' &lt;&lt;&lt; \"^UMASK\") # shellcheck disable=SC2059 printf -v formatted_output \"%s %s\" \"$stripped_key\" \"$var_accounts_user_umask\" # If the key exists, change it. Otherwise, add it to the config_file. # We search for the key string followed by a word boundary (matched by \\&gt;), # so if we search for 'setting', 'setting2' won't match. if LC_ALL=C grep -q -m 1 -i -e \"^UMASK\\\\&gt;\" \"/etc/login.defs\"; then \"${sed_command[@]}\" \"s/^UMASK\\\\&gt;.*/$formatted_output/gi\" \"/etc/login.defs\" else # is precaution for case where file ends without trailing newline printf ' # Per %s: Set %s in %s ' \"$cce\" \"$formatted_output\" \"/etc/login.defs\" &gt;&gt; \"/etc/login.defs\" printf '%s ' \"$formatted_output\" &gt;&gt; \"/etc/login.defs\" fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    },
    {
      "tags": {
        "severity": "critical",
        "gtitle": "Ensure that Users Have Sensible Umask Values",
        "gid": "user_umask",
        "rid": "accounts_umask_etc_profile",
        "fix_id": "accounts_umask_etc_profile"
      },
      "id": "user_umask",
      "title": [
        {
          "#text": "Ensure the Default Umask is Set Correctly in /etc/profile",
          "@_lang": "en-US"
        }
      ],
      "desc": "To ensure the default umask controlled byis set properly, add or correct thesetting into read as follows:",
      "impact": 1,
      "descs": {
        "fix": "var_accounts_user_umask='' grep -q umask /etc/profile &amp;&amp; \\ sed -i \"s/umask.*/umask $var_accounts_user_umask/g\" /etc/profile if ! [ $? -eq 0 ]; then echo \"umask $var_accounts_user_umask\" &gt;&gt; /etc/profile fi"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Ensure that Users Have Sensible Umask Values",
        "gid": "user_umask",
        "rid": "accounts_umask_interactive_users"
      },
      "id": "user_umask",
      "title": [
        {
          "#text": "Ensure the Default Umask is Set Correctly For Interactive Users",
          "@_lang": "en-US"
        }
      ],
      "desc": "Remove theenvironment variable from all interactive users initialization files.",
      "impact": 0.5,
      "descs": {
        "fix": "Missing fix text"
      }
    },
    {
      "tags": {
        "severity": "medium",
        "gtitle": "Disable Wireless Through Software Configuration",
        "gid": "wireless_software",
        "rid": "wireless_disable_interfaces",
        "fix_id": "wireless_disable_interfaces"
      },
      "id": "wireless_software",
      "title": [
        {
          "#text": "Deactivate Wireless Network Interfaces",
          "@_lang": "en-US"
        }
      ],
      "desc": "Deactivating wireless network interfaces should prevent normal usage of the wireless capability.Verify that there are no wireless interfaces configured on the system with the following command:For each interface, configure the system to disable wireless network interfaces with the following command:For each interface listed, find their respective module with the following command:wheremust be substituted by the actual interface name. Create a file in thedirectory and for each module, add the following line:For each module from the system, execute the following command to remove it:",
      "impact": 0.5,
      "descs": {
        "fix": "# Remediation is applicable only in certain platforms if [ ! -f /.dockerenv ] &amp;&amp; [ ! -f /run/.containerenv ]; then if [ -n \"$(find /sys/class/net/*/ -type d -name wireless)\" ]; then interfaces=$(ls -L -d /sys/class/net/*/wireless | xargs dirname | xargs basename) for i in $interfaces; do ifdown $i drivers=$(basename $(readlink -f /sys/class/net/$i/device/driver)) echo \"install $drivers /bin/true\" &gt;&gt; /etc/modprobe.d/disable_wireless.conf modprobe -r $drivers done if command -v nmcli &gt;/dev/null 2&gt;&amp;1 ; then nmcli radio all off fi fi else &gt;&amp;2 echo 'Remediation is not applicable, nothing was done' fi"
      }
    }
  ],
  "name": "UBUNTU_20-04",
  "title": "Guide to the Secure Configuration of Ubuntu 20.04",
  "summary": "This guide presents a catalog of security-relevant configuration settings for Ubuntu 20.04. It is a rendering of content structured in the eXtensible Configuration Checklist Description Format (XCCDF) in order to support security automation. The SCAP content is is available in thepackage which is developed at.Providing system administrators with such guidance informs them how to securely configure systems under their control in a variety of network roles. Policy makers and baseline creators can use this catalog of settings, with its associated references to higher-level security control catalogs, in order to assist them in security baseline creation. This guide is a, and satisfaction of every item is not likely to be possible or sensible in many operational scenarios. However, the XCCDF format enables granular selection and adjustment of settings, and their association with OVAL and OCIL content provides an automated checking capability. Transformations of this document, and its associated automated checking content, are capable of providing baselines that meet a diverse set of policy objectives. Some example XCCDF, which are selections of items that form checklists and can be used as baselines, are available with this guide. They can be processed, in an automated fashion, with tools that support the Security Content Automation Protocol (SCAP). The DISA STIG, which provides required settings for US Department of Defense systems, is one example of a baseline created from this guidance."
}